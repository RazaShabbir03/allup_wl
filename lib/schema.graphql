type AcceptOrRejectInvitePayload {
  success: Boolean
  errorMessage: String
  error: ReferFriendError
  errors: [ReferFriendError]
}

type AccessLevelsPayload {
  list: [GymAccessLevel!]
  paging: PaginatorOutputUpdated
}

type AccountDeletionRequest {
  id: ID!
  customerId: ID!
  responsibleAdminId: ID
  createdAt: Date!
  requestStatus: AccountDeletionRequestStatus!
  reason: String
  note: String
  adminNote: String
}

enum AccountDeletionRequestError {
  INVALID_ID
  INVALID_REASON
  INVALID_CUSTOMER_ID
  REQUIRED_FIELD
  INTERNAL_SERVER_ERROR
  ALREADY_REQUESTED
}

input AccountDeletionRequestsFilter {
  searchText: String
  requestStatus: AccountDeletionRequestStatus
  responsibleAdminId: ID
  customerId: ID
}

type AccountDeletionRequestsPayload {
  list: [AccountDeletionRequest]
  paging: PaginatorOutput
}

enum AccountDeletionRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

input AddGymAccessGateInput {
  id: ID
  gymId: ID!
  gateId: Int!
  areaId: Int!
  name: String!
}

input AddGymAccessLevelInput {
  id: ID
  gymId: ID!
  accessLevelId: String!
  name: String!
}

input AddGymDeviceInput {
  gymId: ID!
  deviceId: String!
}

input AddIntructorEventInput {
  customerPrivateCoachSessionId: ID!
  eventType: InstructorSessionEventType!
}

type AddIntructorEventInputPayload {
  success: Boolean!
  errorMessage: String
  error: OrderPrivateCoachSessionHistoryError
  errors: [OrderPrivateCoachSessionHistoryError!]
}

type AddReportResponse {
  id: ID
  status: ResponseStatus
}

type AddressField {
  # the id of the field
  id: ID!
  # the name of the field
  title: String!
  # the type of the field
  type: AddressFieldType!
  # if the field is required
  isRequired: Boolean!
  # The order of the field
  orderNo: Int!
  status: StatusType!
  countryId: ID!
}

enum AddressFieldError {
  DUPLICATE_TITLE
  INVALID_ID
  INVALID_DATA
}

input AddressFieldFilter {
  searchText: String
  type: AddressFieldType
  isRequired: Boolean
  countryId: ID
  status: StatusType
}

input AddressFieldInput {
  id: ID
  title: String!
  type: AddressFieldType!
  isRequired: Boolean!
  countryId: ID!
  status: StatusType!
}

type AddressFieldPayload {
  list: [AddressField]
  paging: PaginatorOutput
}

enum AddressFieldType {
  OTHER
  NICKNAME
  STREET
  BLOCK
  AVENUE
  CITY
  NEIGHBOURHOOD
  SULOCALITY
  COUNTRY
  POSTAL_CODE
  EMAIL
  TELEPHONE
  NOTE
}

input addressInput {
  id: ID
  shortAddress: String
  floorNo: String
  building: String
  street: String
  unitNumber: String!
  zipCode: String
  city: String!
  state: String
  countryId: ID!
  # The longitude component of the geo coordinates for this address, in degrees
  longitude: Float!
  # The longitude component of the geo coordinates for this address, in degrees
  latitude: Float!
}

input AddVideoInput {
  title: String!
  description: String!
  videoId: String!
  url: String!
  hero: String!
  duration: Int!
  brandId: ID!
  gymId: ID
  status: GlobalStatusType!
  instructorId: ID
  videoTypeId: ID!
  difficulty: VideoDifficulty!
  equipment: String!
  caloriesBurned: String!
}

# Admins to manage brand, branches, admin platform..
type Admin {
  id: ID!
  firstName: String!
  lastName: String
  fullName: String!
  email: String!
  adminType: AdminType!
  contactNumber: String
  photo: String
  gender: GlobalGenderType
  authId: String!
  status: GlobalStatusType!
  instructorId: ID
  createdBy: Admin
  lastUpdatedBy: Admin
  createdAt: Datetime!
  updatedAt: Datetime!
  brands: [Brand!]
  gyms: [Gym!]
  brand: Brand
  gym: Gym
  roles: [VendorRole_Common!]
  permissions: [String!]
  permissionsOld: [String!]
  brandNames: String
  gymNames: String
  isSysAdmin: Boolean
}

type Admin_POS {
  id: ID!
  fullName: String!
}

enum AdminError {
  DUPLICATE_EMAIL
  INVALID_ID
  DUPLICATE_CONTACT_NUMBER
  FIREBASE
  INVALID_BRAND_ID
  INVALID_GYM_ID
  ROLES_REQUIRED
  INVALID_CONTACT_NUMBER
  REFERENCE_ID_REQUIRED
  REQUIRED_FIELD
  NOT_ALLOWED
  NON_UNIQUE_BATCH_NO
  INVALID_FILE_EXTENSION
  FILE_NOT_FOUND
  EMPTY_FILE_CONTENT
  GYM_NOT_FOUND
}

# Admins to roles
type AdminRole {
  id: ID!
  admin: Admin!
  role: VendorRole_Common!
  createdById: ID
  lastUpdatedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum AdminRoleError {
  DUPLICATE_EMAIL
  INVALID_ID
}

type AdminsByGymIdAndRoles {
  id: ID!
  first_name: String!
  last_name: String
}

type AdminsByGymIdAndRolesPayload {
  list: [AdminsByGymIdAndRoles!]
}

input AdminsFilter {
  searchText: String
  status: GlobalStatusType
  adminType: AdminType
}

type AdminsPayload {
  list: [Admin!]
  paging: PaginatorOutputUpdated
}

enum AdminType {
  GLOBAL
  BRAND
  BRANCH
}

type Age {
  from: Int!
  to: Int!
}

input AgeInput {
  from: Int!
  to: Int!
}

input AllBookedPTClassSessionsParams {
  customerId: ID
  instructorId: ID
  instructorIds: [ID!]
  startDate: Date
  endDate: Date
  date: Date
  openTime: LocalTime
  gymClassId: ID
  gymId: ID
  isAttended: Boolean
}

input AllBookedPTClassSessionsParamsV2 {
  customerId: ID
  instructorId: ID
  instructorIds: [ID!]
  startDate: Date
  endDate: Date
  date: Date
  openTime: LocalTime
  scheduleId: ID
  scheduleGroupId: ID
  gymId: ID
  isAttended: Boolean
}

input AllBookedPTSessionsParams {
  customerId: ID
  instructorId: ID
  instructorIds: [ID!]
  sessionContractId: ID
  startDate: Date!
  endDate: Date!
  gymId: ID
}

type AllEventReviewsResponse {
  reviews: [EventReview]
  reviewCount: Int
  averageRating: EventAverageRating!
  canReview: Boolean
}

input AllSessionContractFilter {
  gymId: ID!
  customerId: String
}

type AllSessionContractPayload {
  sessionContracts: [SessionContract]
}

enum AllupProGlobalGenderType {
  FEMALE
  MALE
  ANY
  ALL
}

type AllupProLead {
  id: ID!
  fullName: String!
  photo: String
  activeMembership: AllupProLeadMembership
  membershipDetails: LeadMembershipDetails
  leadCreatedByName: String
  leadType: LeadType
  leadStatus: LeadStatus
  salesId: ID
  salesName: String
  trainerId: ID
  gymId: ID
  trainerName: String
  customerId: ID
  phoneNumber: String
  contacts: [LeadContact]
  createdAt: Date
  membershipActionDate: Date
  isParent: Boolean!
  customerCode: String
  paymentStatus: LeadPaymentStatus
}

type AllupProLeadMembership {
  id: ID!
  membershipPlanName: String
  membershipCode: String
  gymName: String
  startDate: Date
  endDate: Date
  trainerName: String
  membershipType: MembershipType
}

input AllupProLeadsFilter {
  name: String
  type: AllupProLeadsFilterType
  gender: AllupProGlobalGenderType
  status: AllupProLeadsFilterStatus
  sorting: AllupProLeadsFilterSorting
  addedToday: Boolean
  addedThisMonth: Boolean
  addedLastWeek: Boolean
  expiresWithinAWeek: Boolean
  activeLeads: Boolean
  reccuringLeads: Boolean
  addedLastMonth: Boolean
  birthdayLeads: Boolean
  gymId: ID
  leadCreatedById: ID
}

enum AllupProLeadsFilterSorting {
  DATE_ASC
  DATE_DESC
  ALPHABETIC
}

enum AllupProLeadsFilterStatus {
  ACTIVE
  EXPIRED
}

enum AllupProLeadsFilterType {
  LEAD
  MEMBER
}

type AllupProLeadsPayload {
  list: [AllupProLead]
  paging: PaginatorOutputUpdated
}

type AllupProLeadStats {
  nbLeadsAddedLastWeek: Int
  nbTodaysActiveLeads: Int
  nbTodaysRecurringActiveLeads: Int
  nbLeadsAddedLastMonth: Int
  nbLeadsExpiringNextWeek: Int
  nbBirthdayLeads: Int
}

type AllWhiteListedNumberPayload {
  list: [WhiteListedPhoneNumber]
  paging: PaginatorOutputUpdated
}

input AllWhiteListedPhoneNumbersInput {
  phoneNumber: String
}

type Amenity {
  id: ID!
  name: String!
  icon: String
  status: GlobalStatusType!
  isNotIncludeToPrice: Boolean
}

enum AmenityError {
  DUPLICATE_NAME
  INVALID_ID
}

input AmenityFilter {
  status: GlobalStatusType
}

input AmenityInput {
  id: ID
  name: String!
  icon: String
  status: GlobalStatusType!
  isNotIncludeToPrice: Boolean
}

input AnaltyicsInput {
  gymId: ID
}

type AnyUserSchema {
  id: ID!
  firstName: String!
  lastName: String!
  email: String
  description: String
  isEmailVerified: Boolean!
  contactNumber: String
  phoneNumberLocal: String
  phoneCountryCode: String
  countryIsoCode: String
  countryId: ID
  isPhoneVerified: Boolean!
  accessedByMobile: Boolean
  photo: String
  dob: Date
  gender: CustomerGenderType
  authId: String!
  isOnline: Boolean
  ptPref: PtPref
  gymClassPref: GymClassPref
  gymPref: GymPref
  socialMediaReferences: [UserSocialMediaReference!]
  parqHealth: ParqHealthType
  gfpHealth: GfpHealthType
  tAndCSignatureLink: String
  slots: [AnyUserSchema!]
  # Fields for sub accounts (slot)
  gym: ExternalGym_Customer
  parentLead(gymId: ID): Lead
}

type AppId {
  id: String
  appId: String!
  status: GlobalStatusType
  name: String
  brands: [Brand]
  wlAndroidAppLink: String
  wlIosAppLink: String
  minVersionIOS: String
  minVersionAndroid: String
}

type AppIdBrand {
  id: ID!
  name: String!
  email: String!
  logo: String!
  image: String
  legalName: String!
  phone: String!
  street: String!
  unitNumber: String!
  zipCode: String
  status: BrandStatus!
  gymCount: Int!
  appId: ID
}

enum AppIdErrors {
  ALREADY_EXIST
  NOT_FOUND
  INTERNAL_SERVER_ERROR
}

type AppIdPayload {
  appId: AppId
  errors: [AppIdErrors]
  error: AppIdErrors
  errorMessage: String
}

type AppIdsPayload {
  list: [AppId]
  paging: PaginatorOutputUpdated
  errors: [AppIdErrors]
  error: AppIdErrors
  errorMessage: String
}

enum ApplicationEnum {
  SOCIAL_APP
  ALLUP_PRO
  ADMIN_PANEL
  WHITE_LABEL
}

enum AppointmentOutcome {
  NO_SHOW
  RESCHEDULED
  NOT_INTERESTED
  JOINED
}

input ApproveMembershipRequestMutationInput {
  requestId: ID!
  type: MembershipActionRequestTypeEnum!
  note: String
}

type ArrayBox {
  arrayVal: [String!]
}

enum ascOrDesc {
  ASC
  DESC
}

type AssignedAmenities {
  courtId: ID!
  courtAmenityId: ID!
  courtAmenity: CourtAmenity!
}

type AssignedCategories {
  courtId: ID!
  courtCategoryId: ID!
  courtCategory: CourtCategory!
}

input AssignLeadTaskInput {
  id: ID!
  assigneeId: ID!
}

type AssignSingleMembership {
  success: Boolean
}

input AssignSingleMembershipMutationInput {
  paymentMethod: MembershipPaymentMethod!
  csvPrefix: String
  fileUrl: String
  membershipPlanGroupId: String
}

type AssignSingleMembershipMutationResponse {
  data: AssignSingleMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input AttendABookingByQrCodeInput {
  qrCode: String!
  customerId: ID!
}

type AttendABookingByQrCodePayload {
  orderCourtBookedSlot: OrderCourtBookedSlot
  error: OrderCourtBookedSlotError
  errors: [OrderCourtBookedSlotError!]
  errorMessage: String
}

input AttendAGymTrialInput {
  qrCode: String!
}

type AttendAGymTrialPayload {
  orderTrialAttendance: OrderTrialAttendance
  error: OrderTrialError
  errors: [OrderTrialError!]
  errorMessage: String
}

type AttendanceArray {
  date: String
  attended: Boolean
  paid: Boolean
}

input AttendAnEventInput {
  qrCode: String!
  userId: ID
}

input AttendBookedGymClassByQrCodeInput {
  qrCode: String!
}

type AttendEvent {
  data: EventPurchase
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

type AttendGymClass {
  id: ID!
}

input AttendGymClassByQrCodeInput {
  gymClassId: ID!
  code: String!
  bookedFor: Date!
  bookedTime: LocalTime!
}

enum AttendGymClassError {
  INVALID_CLASS_ID
  ALREADY_ATTENDED
  INVALID_CLASS_DATETIME
  INVALID_CUSTOMER
  INVALID_CODE
  EXPIRED
  UNKNOWN
  NOT_PAID
  NOT_ACTIVE
  NOT_ALLOWED
  NOT_FOUND
}

input AttendGymClassInput {
  gymClassId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
}

type AttendGymClassPayload {
  success: Boolean
  error: AttendGymClassError
  errors: [AttendGymClassError!]
  errorMessage: String
}

type AttendSession {
  id: ID!
}

enum AttendSessionError {
  ALREADY_ATTENDED
  INVALID_SESSION_ID
  INVALID_CUSTOMER
  EXPIRED
  INVALID_CLASS_DATETIME
}

input AttendSessionInput {
  customerPrivateCoachSessionId: ID!
  code: String!
}

type AttendSessionPayload {
  success: Boolean
  error: AttendSessionError
  errors: [AttendSessionError!]
  errorMessage: String
}

type availableRefundAmount {
  amount: Float
  currency: String
  method: String
}

type AvailableSlots {
  date: Date!
  openTimeDisplay: LocalTime!
  closeTimeDisplay: LocalTime!
  openTimeKey: LocalTime!
  closeTimeKey: LocalTime!
  available: Boolean!
}

type AverageRatingType {
  accessToGym: String
  qualityOfService: String
  hygiene: String
  avarageRatingLabel: String
}

type avergeMembershipFeeQueryResponse {
  data: avergeMembershipFees
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type avergeMembershipFees {
  average_amount_day: Float
  average_amount_week: Float
  average_amount_month: Float
  average_amount_year: Float
  average_amount_day_current_month: Float
  average_amount_week_current_month: Float
  average_amount_month_current_month: Float
  average_amount_year_current_month: Float
}

input BillingDateRange {
  startDate: String
  endDate: String
}

input BillingEfficiencyReportCSVFilters {
  gymIds: [ID!]
  dateRange: BillingDateRange
}

type BillingEfficiencyReportCSVType {
  data: [BillingInfo]
}

input BillingEfficiencyReportFilters {
  countryId: ID!
  gymIds: [ID!]
}

type BillingEfficiencyReportType {
  total: CurrencyValue!
  successful: CurrencyValue!
  efficiency: CurrencyValue!
}

type BillingInfo {
  invoiceDate: Date!
  invoiceNumber: String!
  id: ID!
  clientName: String
  orderCategory: String!
  amount: CurrencyValue!
  paymentStatus: String!
}

input BookAGymClassInput {
  gymClassId: ID!
  gymStudioId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
  paymentMethod: GCPaymentMethodInput
  cocCardId: ID
  # card over counter id
  notes: String
}

input BookAGymClassInputV2 {
  scheduleGroupId: ID!
  scheduleId: ID!
  gymStudioId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
  paymentMethod: GCPaymentMethodInput
  cocCardId: ID
  # card over counter id
  notes: String
}

type BookAGymClassPayload {
  orderGymClass: OrderGymClass
  paymentUrl: String
  error: OrderGymClassError
  errors: [OrderGymClassError!]
  errorMessage: String
}

type BookAGymClassPayloadV2 {
  orderGymClass: OrderGymClassV2
  paymentUrl: String
  error: OrderGymClassError
  errors: [OrderGymClassError!]
  errorMessage: String
}

input BookAPrivateCoachFromAdminPlatformInput {
  message: String
  sessionContractId: ID!
  instructorId: ID
  sessions: BookAPrivateCoachSessionsFromAdminPlatformInput!
  groupMembers: [String!]
}

input BookAPrivateCoachInput {
  instructorId: ID!
  message: String
  sessions: [BuyAPrivateCoachInstructorSessionsInput!]!
}

type BookAPrivateCoachPayload {
  orderPrivateCoach: OrderPrivateCoach
  bookingId: ID
  error: OrderPrivateCoachError
  errors: [OrderPrivateCoachError!]
  errorMessage: String
}

input BookAPrivateCoachSessionsFromAdminPlatformInput {
  forDate: Date!
  openTime: LocalTime!
  closeTime: LocalTime!
  gymStudioId: ID
}

input BookedClassQRCodeParams {
  gymClassId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
}

input BookedClassQRCodeParamsV2 {
  scheduleId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
}

type BookedClassQRCodePayload {
  qrCode: String!
}

type BookedGymClassesListing {
  id: ID!
  name: String!
  weekDay: String!
  date: String!
  openTime: LocalTime!
  scheduleGroupId: ID!
  scheduleId: ID!
  duration: Float!
  age: Age
  instructors: [ExternalInstructor_VP]
  categoryName: String
  description: String
  gymClassCategoryIds: [ID!]
  instructorIds: [ID!]
  instructorNames: String
  defaultInstructorNames: String
  instructorFirstName: String
  instructorLastName: String
  countryId: ID
  images: [String]
  gender: GlobalGenderType
  startDate: Date!
  endDate: Date
  estimatedCaloriesBurnt: String
  difficultyLevel: DifficultyLevel
  distance: Float
  distanceInKm: Float
  gymLongitude: Float
  gymLatitude: Float
  status: GlobalStatusType
  scheduleGroupStatus: GlobalStatusType
  dropInClientPrice: CurrencyValue
  gymMemberClientPrice: CurrencyValue
  currencyCode: String
  vat: CurrencyValue
  gymStudioId: ID
  soldOut: Boolean
  gymId: ID!
  gymName: String
  brandName: String
  gymClassMembershipPrices: [ClassMembershipPrices]
  recentMemberPhotos: [GymClassRecentMemberPhotos!]
  spots: Int
  spotsAllotted: Int
  membership: Boolean
  membershipName: String
  lead: VendorPlanLead
  customer: VendorPlanCustomer
  isPrivate: Boolean!
  isMember: Boolean
  qrCode: String
  isAttended: Boolean
  isAttendable: Boolean
  isPurchased: Boolean
  isCancellable: Boolean
  isExpired: Boolean
  equipment: String
  equipmentLink: String
}

type BookedGymClassesPayload {
  list: [BookedGymClassesListing!]
  paging: PaginatorOutputUpdated
}

input BookedPTSessionsCountParams {
  type: CountType!
  gymId: ID
}

type BookedSlots {
  booked: Int!
  used: Int!
  remaining: Int!
}

input BookFromMembershipAGymClassFromAdminPlatformInput {
  customerId: ID!
  gymClassId: ID!
  gymStudioId: ID!
  bookedFor: Date!
  bookedTill: Date
  bookedTime: LocalTime!
  paymentMethod: GCPaymentMethodInput
  cocCardId: ID
  # card over counter id
  notes: String
  salesBy: ID!
}

input BookFromMembershipAGymClassFromAdminPlatformInputV2 {
  customerId: ID!
  scheduleGroupId: ID!
  scheduleId: ID!
  gymStudioId: ID!
  bookedFor: Date!
  bookedTill: Date
  bookedTime: LocalTime!
  paymentMethod: GCPaymentMethodInput
  cocCardId: ID
  # card over counter id
  notes: String
  salesBy: ID!
}

type BookingInvoice {
  subTotal: CurrencyValue!
  total: CurrencyValue!
  unitPrice: CurrencyValue!
  vat: CurrencyValue!
  vatAmount: CurrencyValue!
  currencyCode: String
  member: Boolean
}

input BookingInvoiceParams {
  gymClassId: ID!
  gymId: ID!
  customerId: ID!
  forDate: Date
  tillDate: Date
}

input BookingInvoiceParamsV2 {
  scheduleGroupId: ID!
  scheduleId: ID!
  gymId: ID!
  customerId: ID!
  forDate: Date
  bookedTime: String
  tillDate: Date
}

type BookingInvoicePayload {
  data: BookingInvoice!
  success: Boolean!
  noOfClasses: Int
  bookable: Boolean
  error: OrderGymClassError
  errorMessage: String
}

type BooleanBox {
  boolVal: Boolean
}

union BooleanOrString = BooleanBox | StringBox | ArrayBox
# Brands/Gyms
type Brand {
  id: ID!
  name: String!
  email: String!
  logo: String!
  image: String
  legalName: String!
  phone: String!
  street: String!
  unitNumber: String!
  city: String!
  zipCode: String
  country: VendorCountry_Common!
  state: String!
  status: BrandStatus!
  gyms: [Gym]
  gymCount: Int!
  createdBy: Admin!
  lastUpdatedBy: Admin!
  createdAt: Datetime!
  updatedAt: Datetime!
  admins: [Admin!]
  signupEnabled: Boolean
}

# BrandAdmin
type BrandAdmin {
  id: ID!
  brand: Brand!
  admin: Admin!
  createdBy: Admin!
  lastUpdatedBy: Admin!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum BrandAdminError {
  DUPLICATE_ADMIN
  INVALID_ID
  INVALID_BRAND
}

input BrandAdminsFilter {
  searchText: String
  brandId: ID
  adminId: ID
}

type BrandAdminsPayload {
  list: [BrandAdmin]
  paging: PaginatorOutput
}

enum BrandError {
  DUPLICATE_NAME
  INVALID_ID
  ADMIN_ALREADY_EXISTS
  INVALID_PHONE_NUMBER
  NOT_ALLOWED
}

input BrandsFilter {
  searchText: String
  status: BrandStatus
  countryId: ID
  appId: String
}

type BrandsPayload {
  list: [Brand]
  paging: PaginatorOutputUpdated
}

enum BrandStatus {
  ACTIVE
  INACTIVE
}

# Compose Bulk Emails
type BulkEmails {
  id: ID!
  type: BulkEmailsTypeEnum!
  to: [String!]
  memberships: [BulkEmailsMembershipPayload!]
  gymId: ID!
  subject: String!
  content: String!
  createdByName: String
  cc: [String!]
  bcc: [String!]
  createdById: ID!
  createdAt: Datetime!
  startDate: Date
  endDate: Date
}

type BulkEmailsMembershipPayload {
  id: ID!
  name: String!
}

enum BulkEmailsTypeEnum {
  ALL
  LEADS
  MEMBERS
  WOMEN
  MEN
  MEMBERSHIP
  EXPIRING_MEMBERS
  EXPIRED_MEMBERS
  ACTIVE_MEMBERS
}

# Compose Bulk Emails
type BulkNotifications {
  id: ID!
  type: BulkNotificationsTypeEnum!
  to: [String!]
  gymId: ID!
  memberships: [BulkNotificationsMembershipPayload!]
  title: String!
  content: String!
  createdById: ID!
  createdByName: String
  createdAt: Datetime!
  startDate: Date
  endDate: Date
}

type BulkNotificationsMembershipPayload {
  id: ID!
  name: String!
}

enum BulkNotificationsTypeEnum {
  ALL
  LEADS
  MEMBERS
  WOMEN
  MEN
  MEMBERSHIP
  EXPIRING_MEMBERS
  EXPIRED_MEMBERS
  ACTIVE_MEMBERS
}

input BuyACourtInput {
  courtId: ID!
  packageId: ID!
  customerIds: [ID!]
  message: String
  slots: [BuyACourtSlot!]
  paymentMethod: CourtPaymentMethodInput!
}

type BuyACourtPayload {
  orderCourt: OrderCourt
  paymentUrl: String
  error: CourtError
  errors: [CourtError!]
  errorMessage: String
}

input BuyACourtSlot {
  date: Date!
  openTimeKey: LocalTime!
  closeTimeKey: LocalTime!
}

input BuyADebQrSessionInput {
  paymentToken: String!
  paymentMethod: PaymentMethodInput!
}

input BuyAGymClassFromAdminPlatformInput {
  customerId: ID!
  gymClassId: ID!
  gymStudioId: ID!
  bookedFor: Date!
  bookedTill: Date
  bookedTime: LocalTime!
  paymentMethod: GCPaymentMethodInput
  cocCardId: ID
  # card over counter id
  notes: String
  salesBy: ID
}

input BuyAGymClassFromAdminPlatformInputV2 {
  customerId: ID!
  scheduleGroupId: ID!
  scheduleId: ID!
  gymStudioId: ID!
  bookedFor: Date!
  bookedTill: Date
  externalId: String
  bookedTime: LocalTime!
  paymentMethod: GCPaymentMethodInput
  cocCardId: ID
  # card over counter id
  notes: String
  salesBy: ID
}

input BuyAGymClassInput {
  gymClassId: ID!
  gymStudioId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
  paymentMethod: GCPaymentMethodInput
  cocCardId: ID
  # card over counter id
  notes: String
}

input BuyAGymClassInputV2 {
  scheduleGroupId: ID!
  scheduleId: ID!
  gymStudioId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
  paymentMethod: GCPaymentMethodInput
  cocCardId: ID
  # card over counter id
  notes: String
}

type BuyAGymClassPayload {
  orderGymClass: OrderGymClass
  paymentUrl: String
  error: OrderGymClassError
  errors: [OrderGymClassError!]
  errorMessage: String
}

type BuyAGymClassPayloadV2 {
  orderGymClass: OrderGymClassV2
  paymentUrl: String
  error: OrderGymClassError
  errors: [OrderGymClassError!]
  errorMessage: String
}

input BuyAGymTrialAdminInput {
  gymId: ID!
  customerId: ID!
  countryId: ID!
  message: String
  startDate: Date
  slots: [BuyAGymTrialSlotInput!]
}

input BuyAGymTrialInput {
  gymId: ID!
  countryId: ID!
  message: String
  startDate: Date
  slots: [BuyAGymTrialSlotInput!]
}

type BuyAGymTrialPayload {
  orderTrial: OrderTrial
  paymentUrl: String
  error: OrderTrialError
  errors: [OrderTrialError!]
  errorMessage: String
}

input BuyAGymTrialSlotInput {
  date: Date!
  startTimeKey: LocalTime!
  endTimeKey: LocalTime!
}

input BuyAnEventInput {
  eventId: ID!
  count: Int!
  countryId: ID!
  paymentMethod: EventPaymentMethodInput!
}

type BuyAnEventPayload {
  eventOrder: EventOrder
  paymentUrl: String
  error: String
}

input BuyAPosStoreFromAdminPlatformInput {
  products: [PosOrderProductItemInput!]!
  gymId: ID!
  brandId: ID!
  customerId: ID!
  message: String
  cocCardId: ID
  paymentMethod: PosOrderPaymentMethodInput!
  walkinCustomer: Boolean!
  salesById: ID
  discountId: String
}

type BuyAPosStoreFromAdminPlatformPayload {
  posOrder: PosOrder
  paymentUrl: String
  error: PosOrderError
  errors: [PosOrderError!]
  errorMessage: String
}

input BuyAPrivateCoachFromAdminPlatformInput {
  sessionContractId: ID!
  message: String
  discountId: ID
  paymentMethod: InstructorPaymentMethodInput!
  cocCardId: ID
}

input BuyAPrivateCoachInput {
  instructors: [BuyAPrivateCoachInstructorsInput!]!
  message: String
  paymentMethod: InstructorPaymentMethodInput!
  cocCardId: ID
}

input BuyAPrivateCoachInstructorSessionsInput {
  forDate: Date!
  openTime: LocalTime!
}

input BuyAPrivateCoachInstructorsInput {
  serviceId: ID!
  instructorId: ID!
  discountId: ID
  sessions: [BuyAPrivateCoachInstructorSessionsInput!]!
}

type BuyAPrivateCoachPayload {
  orderPrivateCoach: OrderPrivateCoach
  paymentUrl: String
  error: OrderPrivateCoachError
  errors: [OrderPrivateCoachError!]
  errorMessage: String
}

input BuyAQrSessionInput {
  qrCode: String!
  paymentToken: String!
  paymentMethod: PaymentMethodInput!
}

type BuyAQrSessionPayload {
  orderQrSession: OrderQrSession
  paymentUrl: String
  error: OrderQrSessionError
  errors: [OrderQrSessionError!]
  errorMessage: String
}

enum CallConnectedStatus {
  IDLE
  FOLLOW_UP
  APPOINTMENT
  NOT_INTERESTED
}

enum CallOutcome {
  CONNECTED
  NO_ANSWER
}

enum CallUnreachedStatus {
  WRONG_NUMBER
  UNREACHABLE
}

input CancelABookingMobileInput {
  bookingId: ID!
}

type CancelABookingMobilePayload {
  orderCourtBookedSlot: OrderCourtBookedSlot
  error: OrderCourtBookedSlotError
  errors: [OrderCourtBookedSlotError!]
  errorMessage: String
}

input CancelAGymClassInput {
  gymClassId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
  customerId: ID
}

input CancelAGymClassInputV2 {
  scheduleGroupId: ID!
  scheduleId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
  customerId: ID
}

type CancelAGymClassPayload {
  success: Boolean
  error: OrderGymClassError
  errors: [OrderGymClassError!]
  errorMessage: String
}

input CancelAttendanceInput {
  scheduleId: ID!
  customerId: String!
  bookedFor: Date!
  bookedTime: LocalTime!
}

input CancelEventPurchaseInput {
  eventId: ID!
  code: String!
}

type CancelEventPurchasePayload {
  eventOrder: EventOrder
  paymentUrl: String
  error: String
}

input cancelGymClassScheduleInput {
  scheduleGroupId: ID!
  scheduleId: ID!
  modifiedDate: Date!
  modifiedTime: LocalTime!
  oldDate: Date!
  oldTime: LocalTime!
}

enum CancellationReasonEnum {
  CHANGE_MEMBERSHIP
  DISLIKE_GYM
  BREACH_POLICIES
  OTHER
}

type CancellationReasonType {
  key: CancellationReasonEnum!
  description: String!
}

type cancelMembershipByAdmin {
  amount: Float
  currency: String
}

input CancelMembershipByAdminMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  customerId: ID!
  refundType: RefundType!
  refundCustomAmount: Float
  cancellationReason: CancellationReasonEnum!
  note: String
  cashRefundConfirmation: Boolean
}

type CancelMembershipByAdminMutationResponse {
  data: cancelMembershipByAdmin
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input CancelMembershipMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  customerId: ID!
  reason: CancellationReasonEnum!
  note: String
}

enum ChampionType {
  UNIVERSAL
  DOMESTIC
  SUB_DOMESTIC
}

type changeMembership {
  amount: Float
  currency: String
  action: String
  membershipId: ID
  membershipType: String
  paymentUrl: String
}

input ChangeMembershipMutationInput {
  singleMembershipId: ID
  singleMembershipPlanId: ID
  cocCardId: ID
  groupMembershipId: ID
  groupMembershipPlanId: ID
  sessionPackId: ID
  sessionPackPlanId: ID
  paymentPlanId: ID
  customerId: ID!
  amount: Float
  paymentMethod: MembershipPaymentMethod!
  startDate: String
  adminId: ID
  note: String
}

type ChangeMembershipMutationResponse {
  data: changeMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type changeMembershipSalesBy {
  adminId: ID
}

input ChangeSalesByMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  adminId: ID
}

type ChangeSalesByMutationResponse {
  data: changeMembershipSalesBy
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input CheckCardWithReccuringMembershipsInput {
  cardId: ID
}

type CheckCardWithReccuringMembershipsResponse {
  data: found
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type CheckInUser {
  gymQrSession: GymQrSession
}

input CheckInUserMutationInput {
  qrCode: String!
  customerId: String
}

type CheckInUserMutationResponse {
  data: CheckInUser
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input CheckMembershipActionQueryFilter {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  type: MembershipActionRequestTypeEnum!
}

type CheckoutComConfig {
  publicKey: String!
}

type CheckQrSessionPayload {
  error: QrSessionError
  errors: [QrSessionError!]
  errorMessage: String
}

type ClassAttendanceReport {
  srNo: Int
  name: String
  totalClasses: Int
  totalAttendees: Int
}

input ClassAttendanceReportInput {
  instructorIds: [String]
  gymClassId: String
  gymBrandId: String
  gymId: String
  startDate: Date
  endDate: Date
  sort: DateSortingCCR
  isExport: Boolean
}

type ClassAttendanceReportResponse {
  records: [ClassAttendanceReport]
  paging: PaginatorOutputUpdated
}

type ClassMembershipPrices {
  membershipIds: [String!]
  price: CurrencyValue!
}

input ClassMembershipPricesInput {
  membershipIds: [String!]
  price: CurrencyValue!
}

type ClassReport {
  customerId: String
  sessionPrice: Float
  className: String
  customerName: String
  instructorsName: String
  planName: String
  attendance: [AttendanceArray]
  paidCount: Int
  attendedCount: Int
  totalBilledAmount: Float
}

input ClassReportInput {
  instructorIds: [String]
  gymClassId: String
  startDate: Date
  endDate: Date
  sort: DateSortingCCR
  isExport: Boolean
}

type ClassReportResponse {
  records: [ClassReport]
  paging: PaginatorOutputUpdated
}

type ClassSubscriptionAndAttendanceReport {
  name: String
  scheduleId: ID
  date: String
  openTime: String
  totalSubscribers: Int
  totalAttendees: Int
  totalCancelled: Int
  totalAbsences: Int
  instructorNames: String
}

input classSubscriptionAndAttendanceReportInput {
  instructorIds: [String]
  gymClassId: String
  searchText: String
  startDate: Date
  endDate: Date
  sort: DateSortingCCR
  isExport: Boolean
}

type ClassSubscriptionAndAttendanceReportResponse {
  list: [ClassSubscriptionAndAttendanceReport!]
  paging: PaginatorOutputUpdated
}

enum CocCardType {
  Visa
  UPayment
  KNet
  Mastercard
  Mada
  Tamara
  Tabby
  Online_Payment
  Bank_Transfer
}

enum CocStatus {
  ACTIVE
  INACTIVE
}

type Comment {
  id: ID
  createdById: ID
  lastEditedById: ID
  description: String
  review: GymQrReview
  gym: Gym!
  createdAt: Datetime
}

enum CommentError {
  INVALID_REVIEW
  UNAUTHORIZED
  DUPLICATE_COMMENT
  COMMENT_NOT_FOUND
  TX_ERROR
}

input CommentsFilter {
  searchText: String
  gymId: ID
  reviewId: ID
  createdById: ID
}

type CommentsPayload {
  list: [Comment!]
  paging: PaginatorOutput
}

enum CommentStatus {
  APPROVED
  REJECTED
  PENDING
  DELETED
}

enum CompanyIndustry {
  INDUSTRY
  ACCOUNTING
  AIRLINES_OR_AVIATION
  ALTERNATIVE_DISPUTE_RESOLUTION
  ALTERNATIVE_MEDICINE
  ANIMATION
  APPAREL_OR_FASHION
  ARCHITECTURE_OR_PLANNING
  ARTS_OR_CRAFTS
  AUTOMOTIVE
  AVIATION_OR_AEROSPACE
  BANKING_OR_MORTGAGE
  BIOTECHNOLOGY_OR_GREENTECH
  BROADCAST_MEDIA
  BUILDING_MATERIALS
  BUSINESS_SUPPLIES_OR_EQUIPMENT
  CAPITAL_MARKETS_OR_HEDGE_FUND_OR_PRIVATE_EQUITY
  CHEMICALS
  CIVIC_OR_SOCIAL_ORGANIZATION
  CIVIL_ENGINEERING
  COMMERCIAL_REAL_ESTATE
  COMPUTER_GAMES
  COMPUTER_HARDWARE
  COMPUTER_NETWORKING
  COMPUTER_SOFTWARE_OR_ENGINEERING
  COMPUTER_OR_NETWORK_SECURITY
  CONSTRUCTION
  CONSUMER_ELECTRONICS
  CONSUMER_GOODS
  CONSUMER_SERVICES
  COSMETICS
  DAIRY
  DEFENSE_OR_SPACE
  DESIGN
  E_LEARNING
  EDUCATION_MANAGEMENT
  ELECTRICAL_OR_ELECTRONIC_MANUFACTURING
  ENTERTAINMENT_OR_MOVIE_PRODUCTION
  ENVIRONMENTAL_SERVICES
  EVENTS_SERVICES
  EXECUTIVE_OFFICE
  FACILITIES_SERVICES
  FARMING
  FINANCIAL_SERVICES
  FINE_ART
  FISHERY
  FOOD_PRODUCTION
  FOOD_OR_BEVERAGES
  FUNDRAISING
  FURNITURE
  GAMBLING_OR_CASINOS
  GLASS_OR_CERAMICS_OR_CONCRETE
  GOVERNMENT_ADMINISTRATION
  GOVERNMENT_RELATIONS
  GRAPHIC_DESIGN_OR_WEB_DESIGN
  HEALTH_OR_FITNESS
  HIGHER_EDUCATION_OR_ACADAMIA
  HOSPITAL_OR_HEALTH_CARE
  HOSPITALITY
  HUMAN_RESOURCES_OR_HR
  IMPORT_OR_EXPORT
  INDIVIDUAL_OR_FAMILY_SERVICES
  INDUSTRIAL_AUTOMATION
  INFORMATION_SERVICES
  INFORMATION_TECHNOLOGY_OR_IT
  INSURANCE
  INTERNATIONAL_AFFAIRS
  INTERNATIONAL_TRADE_OR_DEVELOPMENT
  INTERNET
  INVESTMENT_BANKING_OR_VENTURE
  INVESTMENT_MANAGEMENT_OR_HEDGE_FUND_OR_PRIVATE_EQUITY
  JUDICIARY
  LAW_ENFORCEMENT
  LAW_PRACTICE_OR_LAW_FIRMS
  LEGAL_SERVICES
  LEGISLATIVE_OFFICE
  LEISURE_OR_TRAVEL
  LIBRARY
  LOGISTICS_OR_PROCUREMENT
  LUXURY_GOODS_OR_JEWELRY
  MACHINERY
  MANAGEMENT_CONSULTING
  MARITIME
  MARKET_RESEARCH
  MARKETING_OR_ADVERTISING_OR_SALES
  MECHANICAL_OR_INDUSTRIAL_ENGINEERING
  MEDIA_PRODUCTION
  MEDICAL_EQUIPMENT
  MEDICAL_PRACTICE
  MENTAL_HEALTH_CARE
  MILITARY_INDUSTRY
  MINING_OR_METALS
  MOTION_PICTURES_OR_FILM
  MUSEUMS_OR_INSTITUTIONS
  MUSIC
  NANOTECHNOLOGY
  NEWSPAPERS_OR_JOURNALISM
  NON_PROFIT_OR_VOLUNTEERING
  OIL_OR_ENERGY_OR_SOLAR_OR_GREENTECH
  ONLINE_PUBLISHING
  OTHER_INDUSTRY
  OUTSOURCING_OR_OFFSHORING
  PACKAGE_OR_FREIGHT_DELIVERY
  PACKAGING_OR_CONTAINERS
  PAPER_OR_FOREST_PRODUCTS
  PERFORMING_ARTS
  PHARMACEUTICALS
  PHILANTHROPY
  PHOTOGRAPHY
  PLASTICS
  POLITICAL_ORGANIZATION
  PRIMARY_OR_SECONDARY_EDUCATION
  PRINTING
  PROFESSIONAL_TRAINING
  PROGRAM_DEVELOPMENT
  PUBLIC_RELATIONS_OR_PR
  PUBLIC_SAFETY
  PUBLISHING_INDUSTRY
  RAILROAD_MANUFACTURE
  RANCHING
  REAL_ESTATE_OR_MORTGAGE
  RECREATIONAL_FACILITIES_OR_SERVICES
  RELIGIOUS_INSTITUTIONS
  RENEWABLES_OR_ENVIRONMENT
  RESEARCH_INDUSTRY
  RESTAURANTS
  RETAIL_INDUSTRY
  SECURITY_OR_INVESTIGATIONS
  SEMICONDUCTORS
  SHIPBUILDING
  SPORTING_GOODS
  SPORTS
  STAFFING_OR_RECRUITING
  SUPERMARKETS
  TELECOMMUNICATIONS
  TEXTILES
  THINK_TANKS
  TOBACCO
  TRANSLATION_OR_LOCALIZATION
  TRANSPORTATION
  UTILITIES
  VENTURE_CAPITAL_OR_VC
  VETERINARY
  WAREHOUSING
  WHOLESALE
  WINE_OR_SPIRITS
  WIRELESS
  WRITING_OR_EDITING
}

enum ComposeBulkEmailsError {
  INVALID_START_DATE
  INVALID_END_DATE
  INVALID_DATE_RANGE
  INVALID_MEMBERSHIPS
}

input ComposeBulkEmailsInput {
  type: BulkEmailsTypeEnum!
  subject: String!
  content: String!
  gymId: ID!
  cc: [String!]
  bcc: [String!]
  memberships: [String!]
  startDate: Date
  endDate: Date
}

type ComposeBulkEmailsPayload {
  data: BulkEmails
  error: ComposeBulkEmailsError
  errors: [ComposeBulkEmailsError!]
  errorMessage: String
}

enum ComposeBulkNotificationsError {
  INVALID_START_DATE
  INVALID_END_DATE
  INVALID_DATE_RANGE
  INVALID_MEMBERSHIPS
}

input ComposeBulkNotificationsInput {
  type: BulkNotificationsTypeEnum!
  title: String!
  content: String!
  gymId: ID!
  memberships: [String!]
  startDate: Date
  endDate: Date
}

type ComposeBulkNotificationsPayload {
  data: BulkNotifications
  error: ComposeBulkNotificationsError
  errors: [ComposeBulkNotificationsError!]
  errorMessage: String
}

enum ConfigStatus {
  ACTIVE
  INACTIVE
  DELETED
}

type Configuration {
  id: ID!
  key: String!
  value: String!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum ConfigurationError {
  DUPLICATE_NAME
  INVALID_ID
}

input ConfigurationFilter {
  searchText: String
}

input ConfigurationInput {
  id: ID
  key: String!
  value: String!
}

type ConfigurationPayload {
  list: [Configuration]
  paging: PaginatorOutputUpdated
}

enum ConsentStatusEnum {
  APPROVED
  REJECTED
  PENDING
}

type ContentElement {
  id: ID!
  orderNo: Int!
  reference: String!
  type: ContentElementType!
  data: ContentElementData
  status: GlobalStatusType!
  contentType: ContentType!
  contentGroup: ContentGroup!
  createdById: ID!
  lastUpdatedById: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

type ContentElementData {
  name: String!
  placeHolder: String
  description: String
  value: String
  required: Boolean!
  options: [ContentElementDataOption]
}

input ContentElementDataInput {
  name: String!
  placeHolder: String
  description: String
  value: String
  required: Boolean!
  options: [ContentElementDataOptionInput]
}

type ContentElementDataOption {
  id: String!
  label: String!
}

input ContentElementDataOptionInput {
  id: String!
  label: String!
}

enum ContentElementError {
  INVALID_ID
  DUPLICATE_REFERENCE
  INVALID_DATA
}

input ContentElementsFilter {
  searchText: String
  status: GlobalStatusType
  type: ContentElementType
  reference: String
  contentTypeId: ID
  contentGroupId: ID
}

type ContentElementsPayload {
  list: [ContentElement]
  paging: PaginatorOutput
}

enum ContentElementType {
  DATE
  TEXTBOX
  TEXTAREA
  CHECKBOX
  RADIO
  DROPDOWN
  MULTISELECT
  BUTTON
}

type ContentElementValue {
  id: ID!
  customer: Customer!
  contentElement: ContentElement
  orderNo: Int!
  reference: String!
  fieldValue: String!
  type: ContentElementType!
  data: ContentElementData
  status: GlobalStatusType!
  contentType: ContentType
  contentGroup: ContentGroup
  createdById: ID
  lastUpdatedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum ContentElementValueError {
  INVALID_ID
  DUPLICATE_FIELD
  INVALID_CONTENT_ELEMENT_ID
}

input ContentElementValuesFilter {
  searchText: String
  status: GlobalStatusType
  type: ContentElementType
  reference: String
  fieldValue: String
  customerId: ID
  contentElementId: ID
  contentTypeId: ID
  contentGroupId: ID
}

type ContentElementValuesPayload {
  list: [ContentElementValue]
  paging: PaginatorOutput
}

type ContentGroup {
  id: ID!
  orderNo: Int!
  name: String!
  description: String
  status: GlobalStatusType!
  contentType: ContentType!
  contentElements(customerId: ID): [ContentElement]
  createdById: ID!
  lastUpdatedById: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum ContentGroupError {
  INVALID_ID
  DUPLICATE_NAME
  INVALID_DATA
}

input ContentGroupsFilter {
  searchText: String
  status: GlobalStatusType
  contentTypeId: ID
}

type ContentGroupsPayload {
  list: [ContentGroup]
  paging: PaginatorOutput
}

type ContentType {
  id: ID!
  type: ContentTypes!
  status: GlobalStatusType!
  createdById: ID!
  lastUpdatedById: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
  contentElements: [ContentElement]
  contentGroups: [ContentGroup]
}

enum ContentTypeError {
  INVALID_ID
  DUPLICATE_TYPE
}

enum ContentTypes {
  MEDICAL_ID
}

input ContentTypesFilter {
  searchText: String
  status: GlobalStatusType
  type: ContentTypes
}

type ContentTypesPayload {
  list: [ContentType]
  paging: PaginatorOutput
}

input ConvertLeadChildToParentInput {
  id: ID!
}

input ConvertLeadParentToChildInput {
  id: ID!
  leadId: ID!
}

type ConvertLeadPayload {
  lead: Lead
  error: LeadError
  errors: [LeadError]
  errorMessage: String
}

input CountAttendedClassesParams {
  customerId: ID!
  gymId: ID
}

input CountAttendedPTSessionsParams {
  customerId: ID!
  gymId: ID
}

type CountriesPayload {
  list: [Country]
  paging: PaginatorOutputUpdated
  fromCache: Boolean
}

type Country {
  id: ID
  name: String
  status: StatusType
  currency: CurrencyDetails
  isoCode: String
  dialCode: String
  flagPhoto: String
  vat: Float
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
  languages: [Language]
  addressFields: [AddressField]
  cities: [CountryCity]
  states: [CountryState]
  citiesCount: Int
  statesCount: Int
}

input CountryCitiesFilter {
  searchText: String
}

type CountryCitiesPayload {
  list: [CountryCity]
  paging: PaginatorOutput
}

type CountryCity {
  id: ID
  name: String
  countryId: ID
  stateId: ID
}

enum CountryCityError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_COUNTRY_ID
}

enum CountryError {
  DUPLICATE_NAME
  INVALID_ID
  ALL_DATA_ARE_REQUIRED
}

input CountryFilter {
  status: String
  searchText: String
}

input CountryInput {
  id: ID
  name: String!
  status: StatusType!
  isoCode: String!
  dialCode: String!
  flagPhoto: String
  vat: Float
  servicePhoneNumber: String!
  timeZoneIdentifier: String!
  vatId: String
  currency: CurrencyDetailsInput
  cities: [SaveCityPerCountryInput]
}

type CountryState {
  id: ID
  name: String
  isCapital: Boolean
  cities: [CountryCity]
  citiesCount: Int
  countryId: ID
}

enum CountryStateError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_COUNTRY_ID
}

input CountrystatesFilter {
  searchText: String
}

type CountrystatesPayload {
  list: [CountryState]
  paging: PaginatorOutput
}

enum CountType {
  TODAY
  MONTH
}

# Courts
type Court {
  id: ID!
  name: String
  status: CourtStatus!
  description: String
  email: String
  phone: String!
  minCapacityFromAll: Int!
  ratingScore: Float!
  noOfReviews: Int!
  images: [String!]
  videos: [CourtVideoType!]
  location: CourtLocation!
  assignedCategories: [AssignedCategories!]!
  assignedAmenities: [AssignedAmenities!]!
  slotDivider: Int!
  schedule: [CourtSchedule!]!
  packages: [CourtPackage!]!
  policy: String
  createdById: ID
  lastUpdatedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
  # Dynamic
  openTime: String
  closeTime: String
  operatingTimeStr: String
  isOpen: Boolean!
  isFavourite: Boolean!
  bookedSlots: BookedSlots
}

type CourtAmenity {
  id: ID!
  name: String!
  description: String
  image: String
  status: ConfigStatus!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum CourtAmenityError {
  DUPLICATE_NAME
  INVALID_ID
  UNAUTHORIZED
  ALREADY_DELETED
}

input CourtAmenityFilter {
  searchText: String
  status: ConfigStatus
}

type CourtAmenityPayload {
  list: [CourtAmenity!]
  paging: PaginatorOutput
}

input CourtAvailablityFilter {
  date: Date!
  timeZoneIdentifier: String!
}

input CourtBookingParams {
  customerIds: [ID!]
  searchText: String
  categoryIds: [ID!]
  courtIds: [ID!]
  paymentStatus: PaymentStatus
}

type CourtBookingsMobilePayload {
  list: [OrderCourtBookedSlot!]
  paging: PaginatorOutputUpdated!
}

type CourtCategory {
  id: ID!
  name: String!
  description: String
  image: String
  status: ConfigStatus!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum CourtCategoryError {
  DUPLICATE_NAME
  INVALID_ID
  UNAUTHORIZED
  ALREADY_DELETED
}

input CourtCategoryFilter {
  searchText: String
  status: ConfigStatus
}

type CourtCategoryPayload {
  list: [CourtCategory!]
  paging: PaginatorOutputUpdated
}

type CourtComment {
  id: ID
  courtId: ID!
  court: Court!
  customerId: ID!
  customer: Customer_Court
  description: String
  rating: [CRatingTypes!]
  ratingScore: Float!
  status: CourtCommentStatus!
  createdAt: Datetime
}

enum CourtCommentErrors {
  INVALID_REVIEW
  INVALID_SCORE
  UNAUTHORIZED
  DUPLICATE_COMMENT
  COMMENT_NOT_FOUND
  TX_ERROR
  INVALID_ID
  ALREADY_COMMENTED
  CANT_COMMENT
}

input CourtCommentsFilter {
  searchText: String
  courtId: ID!
  status: CourtCommentStatus!
}

type CourtCommentsPayload {
  list: [CourtComment!]
  total: CtotalPayload
  canComment: Boolean!
  paging: PaginatorOutput
}

enum CourtCommentStatus {
  APPROVED
  REJECTED
  PENDING
  DELETED
}

type CourtCountry_Common {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: CourtCurrency_Common!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type CourtCurrency_Common {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

input CourtDetailMobileParams {
  location: GISLocationInput!
  date: Date
}

enum CourtError {
  INVALID_ID
  INVALID_CUSTOMER
  ALREADY_A_MEMBER
  UNAUTHORIZED
  INVALID_CONTACT_NUMBER
  CATEGORY_REQUIRED
  AMENITY_REQUIRED
  ALREADY_DELETED
  INVALID_SCHEDULE
  SCHEDULE_REQUIRED
  INVALID_SCHEDULE_TIME
  PACKAGE_REQUIRED
  INVALID_PACKAGE_DATA
  FEATURE_LIMIT_EXCEED
  INVALID_CUSTOM_RENTAL_PRICE
  INVALID_COURT
  INVALID_PACKAGE
  MAX_PLAYER_LIMIT_EXCEEDED
  MAX_SLOT_LIMIT_EXCEEDED
  SELECT_ALL_SLOTS
  INVALID_SLOT_TIME
  PAYMENT_EXCEPTION
  EXCEPTION
  SLOT_NOT_AVAILABLE
}

type CourtGeoLocation {
  type: String
  coordinates: [Float]
}

type CourtInvitationsCountMobilePayload {
  count: Int!
}

input CourtListMobileParams {
  searchText: String
  distanceInKm: Float
  price: CurrencyValue
  date: Date
  favouriteOnly: Boolean
  categoryIds: [ID!]
  location: GISLocationInput!
  countryId: ID!
  timeZoneIdentifier: String!
  filterType: String
}

type CourtListMobilePayload {
  list: [CourtListMobileType!]
  paging: PaginatorOutput!
}

type CourtListMobileType {
  id: ID!
  name: String!
  description: String!
  shortAddress: String!
  images: [String!]
  # use as max capacity
  minCapacityFromAll: Int!
  slotDivider: Int!
  ratingScore: Float!
  noOfReviews: Int!
  distanceInKm: Float!
  longitude: Float!
  latitude: Float!
  openTime: String
  closeTime: String
  operatingTimeStr: String
  isOpen: Boolean!
  isFavourite: Boolean!
  countryName: String!
  currencyCode: String!
  currencySymbol: String!
}

type CourtLocation {
  shortAddress: String!
  streetName: String!
  geoLocation: CourtGeoLocation
  city: String!
  state: String!
  postalCode: String!
  countryId: ID!
  country: CourtCountry_Common!
}

input CourtLocationInput {
  shortAddress: String!
  longitude: Float
  latitude: Float
  streetName: String!
  city: String!
  state: String!
  postalCode: String!
  countryId: ID!
}

enum CourtOrderBookingStatus {
  ACTIVE
  INACTIVE
  CANCELED
}

enum CourtOrderStatus {
  ACTIVE
  INACTIVE
  CANCELED
}

type CourtPackage {
  id: ID!
  courtId: ID!
  status: GlobalStatusType!
  name: String!
  description: String
  maxPlayers: Int!
  defaultRentalPrice: CurrencyValue!
  offerRentalPrice: CurrencyValue
  maxSlots: Int!
  customRentalPrices: [CustomRentalPriceType!]
  features: [String!]
}

input CourtPackageInput {
  id: ID
  status: GlobalStatusType!
  name: String!
  description: String
  maxPlayers: Int!
  defaultRentalPrice: CurrencyValue!
  maxSlots: Int!
  customRentalPrices: [CustomRentalPriceInput!]
  features: [String!]
}

input CourtPaymentMethodInput {
  paymentScheme: CourtPaymentScheme!
  name: String!
  imageUrl: String
  subText: String
  sourceId: String
}

enum CourtPaymentScheme {
  SAVED_CARD
}

input CourtRadiusFilter {
  # User's current location
  location: GISLocationInput!
  # Search Radius
  radius: Float!
}

type CourtSchedule {
  courtId: ID!
  day: Int!
  openAllDay: Boolean!
  closeAllDay: Boolean!
  openTime: LocalTime
  closeTime: LocalTime
}

input CourtScheduleInput {
  day: Int!
  open: Boolean!
  openTime: LocalTime
  closeTime: LocalTime
}

input CourtsFilter {
  searchText: String
  status: CourtStatus
  countryId: ID
  categoryId: ID
}

type CourtsPayload {
  list: [Court!]
  paging: PaginatorOutputUpdated
}

enum CourtStatus {
  ACTIVE
  INACTIVE
  DELETED
}

input CourtVideoInput {
  title: String!
  url: String!
  thumbnail: String!
}

type CourtVideoType {
  title: String!
  url: String!
  thumbnail: String!
}

input CrateAppIdInput {
  appId: String!
  status: GlobalStatusType
  name: String
  brandIds: [String!]
  wlIosAppLink: String
  wlAndroidAppLink: String
  minVersionIOS: String
  minVersionAndroid: String
}

type CRatingTypes {
  type: String!
  score: Float!
}

input CRatingTypesInput {
  type: String!
  score: Float!
}

type CreateAppIdPayload {
  appId: AppId
  errors: [AppIdErrors]
  error: AppIdErrors
  errorMessage: String
}

input CreateCustomerInput {
  firstName: String!
  lastName: String!
  email: String!
  contactNumber: String
  gender: CustomerGenderType
  dob: Date
  countryId: ID
  isEmailVerified: Boolean
  isPhoneVerified: Boolean
  accessedByMobile: Boolean
  authId: String
}

type CreateEvent {
  data: Event
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

input CreateEventInput {
  name: String!
  description: String!
  startDate: String!
  endDate: String!
  latitude: Float!
  longitude: Float!
  address: String!
  capacity: Int!
  price: Float!
  pictures: [String]!
  videos: [String]
  difficulty: EventDifficulty!
  equipment: String!
  rules: String!
  cancelationPolicy: String!
  status: EventStatus!
  trainers: [ID]
  creatorPhoneNumber: String!
  gymId: ID!
  countryId: ID!
}

type CreateEventReview {
  data: EventReview
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

input CreateEventReviewInput {
  eventId: ID!
  hostRating: Float!
  participantRating: Float!
  generalRating: Float!
  comment: String!
}

type CreateGroupMembershipPlan {
  groupMembershipPlan: GroupMembershipPlan
}

input CreateGroupMembershipPlanMutationInput {
  name: String!
  description: String!
  status: MembershipPlanTypeStatus!
  color: String
  visible: Boolean!
  maxMemberCount: Int!
  paymentIds: [ID]
  gymId: ID!
  groupId: ID!
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
  isChampion: Boolean
  championType: ChampionType
  subDomesticGymIds: [String]
}

type CreateGroupMembershipPlanMutationResponse {
  data: CreateGroupMembershipPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type CreateGuestPayload {
  accessToken: String
  guest: GuestUser
  error: GuestErrors
  errors: [GuestErrors]
  errorMessage: String
}

type CreateMembershipFreezeType {
  membershipFreezeType: MembershipFreezeType
}

input CreateMembershipFreezeTypeMutationInput {
  name: String!
  status: MembershipGlobalStatusEnum!
  numberDays: Int!
  price: Float!
  singleMembershipPlansIds: [ID]
  groupMembershipPlansIds: [ID]
  gymId: ID!
  brandId: ID!
}

type CreateMembershipFreezeTypeMutationResponse {
  data: CreateMembershipFreezeType
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type CreateMembershipPlanGroup {
  membershipPlanGroup: MembershipPlanGroup
}

input CreateMembershipPlanGroupMutationInput {
  name: String!
  description: String!
  gymId: ID!
}

type CreateMembershipPlanGroupMutationResponse {
  data: CreateMembershipPlanGroup
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type CreatePaymentPlan {
  paymentPlan: PaymentPlan
}

input CreatePaymentPlanMutationInput {
  name: String!
  type: PaymentTypeEnum!
  price: Float
  installmentAmount: Float
  surcharge: Float
  installmentRounds: Int
  installmentFrequencyType: InstallmentFrequencyTypeEnum
  joiningFee: Float
  paymentRecursionDuration: Int
  paymentRecursionType: PaymentRecursionTypeEnum
  hasEndDate: Boolean
  recursionDuration: Int
  recursionPeriod: MembershipPlanTypePeriod
  chargeOnFirst: Boolean
  giftPeriodFree: Boolean
  gracePeriodDays: Int
  allowFreeze: Boolean
  freezesList: [MembershipFreezeDetailsInput]
  gymId: String!
  countryId: String!
  singleMembershipPlanId: String
  groupMembershipPlanId: String
  sessionPackPlanId: String
  servicePacks: [ServicePackInputType]
}

type CreatePaymentPlanMutationResponse {
  data: CreatePaymentPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input CreatePosBrandInput {
  name: String!
  description: String
  image: String
  gymId: ID!
  status: PosStatusInput!
}

input CreatePosCategoryInput {
  name: String!
  description: String
  image: String
  gymId: ID!
  status: PosStatusInput!
}

input CreatePosProductInput {
  name: String!
  description: String
  images: [String!]
  posBrandId: ID!
  posCategoryId: ID!
  price: CurrencyValue!
  sku: String!
  status: PosStatusInput!
  vatAdjusted: Boolean!
}

type CreateSessionPackPlan {
  sessionPackPlan: SessionPackPlan
}

input CreateSessionPackPlanMutationInput {
  name: String!
  description: String!
  status: MembershipPlanTypeStatus!
  color: String
  visible: Boolean!
  classes: Int
  allClasses: Boolean
  classIds: [ID]
  classCategories: [ID]
  classRecursionDuration: Int
  classRecursionPeriod: MembershipPlanTypePeriod
  sessions: Int
  allSessions: Boolean
  sessionIds: [ID]
  sessionCategories: [ID]
  sessionRecursionDuration: Int
  sessionRecursionPeriod: MembershipPlanTypePeriod
  courts: Int
  paymentIds: [ID]
  gymId: ID!
  groupId: ID!
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
}

type CreateSessionPackPlanMutationResponse {
  data: CreateSessionPackPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type CreateSingleMembershipPlan {
  singleMembershipPlan: SingleMembershipPlan
}

input CreateSingleMembershipPlanMutationInput {
  name: String!
  description: String!
  status: MembershipPlanTypeStatus!
  color: String
  trial: Boolean
  visible: Boolean!
  targetGender: GenderEnum
  targetMinAge: Int
  targetMaxAge: Int
  paymentIds: [ID]
  gymId: ID!
  groupId: ID!
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
  isChampion: Boolean
  championType: ChampionType
  subDomesticGymIds: [String]
}

type CreateSingleMembershipPlanMutationResponse {
  data: CreateSingleMembershipPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input CreateTempInstructorInput {
  firstName: String!
  lastName: String
  gymId: ID!
}

input CreateTemporaryLeadInput {
  firstName: String!
  lastName: String!
  email: String
  contactNumber: String!
  gymId: String!
}

type CtotalPayload {
  totalComments: Int!
  avgRatingScore: Float
}

type CurrencyDetails {
  name: String
  code: String
  symbol: String
  decimalPlace: Int
  lowestDenomination: Float
  subUnitName: String
}

input CurrencyDetailsInput {
  name: String!
  code: String!
  symbol: String!
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

# Scalar used to describe currency amounts. Serialized as a string to retain decimal precision.
scalar CurrencyValue

# Customer/Users...
type Customer {
  id: ID!
  firstName: String
  lastName: String
  fullName: String
  email: String
  isEmailVerified: Boolean!
  accessedByMobile: Boolean
  contactNumber: String
  isPhoneVerified: Boolean!
  photo: String
  dob: Date
  gender: CustomerGenderType
  authId: String
  status: GlobalStatusType!
  customToken: String
  createdAt: Datetime!
  updatedAt: Datetime!
  defaultAddress: CustomerAddress
  addresses: [CustomerAddress!]
  country: CustomerCountry
  medicalForm: [ContentGroup!]
  ptPref: PtPref
  xAppSource: String
  xAppVersion: String
  xAppOs: String
  gymClassPref: GymClassPref
  gymPref: GymPref
  isParent: Boolean
  isLinkedAccount: Boolean
  lead: Lead
  isLead: Boolean
  linkedAccount: LinkedAccount
  parentCustomer: Customer
  childern: [Customer!]
  linkedCustomers: [Customer]
  gymBuddyId: ID!
  parqHealth: ParqHealthType
  gfpHealth: GfpHealthType
  tAndCSignatureLink: String
}

type Customer_Court {
  id: ID!
  firstName: String!
  lastName: String
  fullName: String!
  email: String
  contactNumber: String
  photo: String
}

type Customer_Pass {
  id: ID!
  firstName: String!
  lastName: String
  fullName: String!
  email: String
  contactNumber: String
  photo: String
}

type Customer_Pos {
  id: ID!
  firstName: String!
  lastName: String
  fullName: String!
  email: String
  contactNumber: String
  photo: String
}

# CustomerAddress..
type CustomerAddress {
  id: ID!
  customer: Customer!
  isDefault: Boolean!
  country: CustomerCountry!
  # The longitude component of the geo coordinates for this address, in degrees
  geoLocation: CustomerAddressGeoLocation
  # Dynamic fields
  dynamicFullData: [DynamicAddressFieldsFullData!]
  dynamicData: [DynamicAddressFieldsData!]
  status: String!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum CustomerAddressError {
  INVALID_ID
  INVALID_CUSTOMER
}

input CustomerAddressFilter {
  countryId: ID
}

type CustomerAddressGeoLocation {
  type: String
  coordinates: [Float]
}

type CustomerAddressPayload {
  list: [CustomerAddress]
  paging: PaginatorOutput
}

enum CustomerAddressType {
  HOUSE
  APARTMENT
  OFFICE_BUILDING
  AIRPORT
}

type CustomerCanCommentOnGymClassPayload {
  canComment: Boolean!
  error: GymClassCommentErrors
  errors: [GymClassCommentErrors!]
}

type CustomerCanCommentOnInstructorPayload {
  canComment: Boolean!
  error: InstructorCommentError
  errors: [InstructorCommentError!]
}

# A saved customer card token
type CustomerCardToken {
  id: ID!
  # token type: e.g. card
  sourceToken: String
  type: String
  # card expiry month
  expiryMonth: Int!
  # card expiry year
  expiryYear: Int!
  # name on the card
  name: String
  # Visa, Mastercard,UPayment, KNet
  scheme: String
  # card no. last 4 digits
  last4: String!
  # the card issuer BIN usually card no. first 6 digits
  bin: String
  # debit / credit ...
  cardType: String
  # consumer / commercial
  cardCategory: String
  # bank who issued the card
  issuer: String
  # issuer country ISO-2 code
  issuerCountry: String
  # the issuer/card scheme product identifier
  productId: String
  # the issuer/card scheme product type
  productType: String
  # what payment provider issued this card token
  paymentProvider: PaymentProvider!
  # mark the card token as default to use
  isDefault: Boolean!
  # card token status. e.g.
  status: CustomerCardTokenStatus!
  gymId: ID
}

input CustomerCardTokenFromAdminInput {
  token: String!
  customerId: ID!
  gymId: ID!
}

input CustomerCardTokenInput {
  token: String!
}

enum CustomerCardTokenSaveError {
  # This token is already saved
  DUPLICATE_TOKEN
  # Customer must exist
  INVALID_CUSTOMER
  NO_DATA_PROVIDED
  INVALID_TOKEN
  INVALID_AMOUNT
  INVALID_CURRENCY
  INVALID_CUSTOMER_ID
  SOURCE_WAS_NOT_RECEIVED_FROM_CKO
  CUSTOMER_WAS_NOT_RECEIVED_FROM_CKO
  PROCESSING_ERROR
}

type CustomerCardTokenSavePayload {
  # The Customer card token which was saved/updated
  customerCardToken: CustomerCardToken
  # The first validation error that occured
  error: CustomerCardTokenSaveError
  # All validation errors
  errors: [CustomerCardTokenSaveError!]
  # Used to handle when 3ds was ON
  paymentUrl: String
  # Error message as string
  errorMessage: String
}

enum CustomerCardTokenSource {
  MOBILE
  ADMIN_PLATFORM
}

enum CustomerCardTokenStatus {
  ACTIVE
  INACTIVE
}

type CustomerCoc {
  id: ID!
  customerId: ID!
  leadId: ID
  last4: String!
  isDefault: Boolean
  cardType: CocCardType!
  gymId: ID!
  status: CocStatus
}

input CustomerCocInput {
  customerId: ID!
  gymId: ID!
}

input CustomerCocSaveInput {
  customerId: ID!
  leadId: ID
  last4: String!
  cardType: CocCardType!
  isDefault: Boolean
  gymId: ID!
}

type CustomerCocSavePayload {
  customerCoc: CustomerCoc
  errorMessage: String
}

input CustomerCocUpdateInput {
  id: ID!
  isDefault: Boolean
  status: CocStatus
}

type CustomerCountry {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: CustomerCurrency!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type CustomerCountryCity {
  id: ID!
  name: String!
}

type CustomerCurrency {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

input CustomerDeliveryAddressInput {
  countryId: ID!
  longitude: Float!
  latitude: Float!
  dynamicData: [CustomerDeliveryDynamicData!]
}

input CustomerDeliveryDynamicData {
  id: ID!
  title: String!
  type: String!
  value: String
  isRequired: Boolean!
}

enum CustomerError {
  ACCOUNT_NOT_FOUND
  DUPLICATE_EMAIL
  INVALID_ID
  DUPLICATE_CONTACT_NUMBER
  FIREBASE
  FIREBASE_AUTH_FAILED
  FIELD_REQUIRED
  INVALID_FIELD_DATA
  INVALID_CUSTOMER
  NEW_PASSWORD_REQUIRED
  INVALID_CURRENT_PASSWORD
  INVALID_COUNTRY_ID
  OLD_PASSWORD_REQUIRED
  WRONG_PASSWORD
  INTERNAL_SERVER_ERROR
  INVALID_DOB
  PHONE_NOT_FOUND
}

type CustomerFavouriteInstructorsPayload {
  list: [Instructor!]
}

enum CustomerGenderType {
  MALE
  FEMALE
  RATHER_NOT_SAY
}

input CustomerGfpHealthInput {
  customerId: ID!
  answers: [GfpHealthQuestions!]!
  notes: String
}

type CustomerGfpHealthPayload {
  customer: Customer
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

input CustomerGymClassDefaultPrefInput {
  distance: Float
  price: Float
  forDate: Date
  # normally it will be retreived from customer preferences, but to see for only
  # one category just pass one category id in the array
  categories: [ID!]
}

type CustomerGymClassLight {
  id: ID
  gymClassId: ID!
  gymClassCategoryId: ID
  instructorIds: [ID!]
  shortCode: String!
  name: String!
  isPrivate: Boolean!
  code: ID
  description: String
  images: [String!]
  status: GymClassStatus!
  amount: CurrencyValue!
  currencyCode: String!
  bookedFor: Date!
  bookedTime: LocalTime!
  startTime: LocalTime
  endTime: LocalTime
  duration: Float!
  spots: Int!
  operatingTimeStr: String
  countryName: String!
  brandName: String!
  gymName: String!
  instructorFirstName: String!
  instructorLastName: String
  isExpired: Boolean!
  isAttended: Boolean!
  qrCode: String
}

input CustomerGymClassPrefInput {
  distance: Float!
  price: Float!
  availableDate: Date
  categories: [ID!]
}

type CustomerGymClassPrefPayload {
  customer: Customer
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

input CustomerGymDrfaultPrefInput {
  # Search Radius, sent in  km
  distance: Float!
  isOpen: Boolean
}

input CustomerGymPrefInput {
  distance: Float!
  isOpen: Boolean!
}

type CustomerGymPrefPayload {
  customer: Customer
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

enum CustomerListType {
  ALL
  NEW
  DISABLED
}

input CustomerMedicalForm {
  contentElements: [CustomerMedicalFormField]
}

input CustomerMedicalFormField {
  contentElementId: ID!
  fieldValue: String!
}

type CustomerMedicalFormPayload {
  medicalForm: [ContentElementValue]
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

input CustomerParqHealthInput {
  customerId: ID!
  answers: [ParqHealthQuestions!]!
  notes: String
  signatureLink: String!
}

type CustomerParqHealthPayload {
  customer: Customer
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

input CustomerPhotoInput {
  photo: String!
}

input CustomerPtDefaultPrefInput {
  distance: Float!
  price: Float!
  forDate: Date
  specialities: [ID!]
}

input CustomerPtPrefInput {
  distance: Float!
  price: Float!
  availableDate: Date
  specialities: [ID!]
}

type CustomerPtPrefPayload {
  customer: Customer
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

enum CustomerSessionsWithInstructorListType {
  PREVIOUS
  TODAY
  UPCOMMING
  CANCELED
}

input CustomerSessionsWithInstructorParams {
  type: CustomerSessionsWithInstructorListType!
}

input CustomersFilter {
  searchText: String
  status: GlobalStatusType
  gender: CustomerGenderType
  countryId: ID
  listType: CustomerListType!
}

type CustomerSignInPayload {
  authorization: String
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

type CustomersPayload {
  list: [Customer]
  paging: PaginatorOutput
}

type CustomerTermsConditions {
  id: ID!
  content: String!
  contentHTML: String!
  version: String!
  createdById: ID
  lastUpdatedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
}

input CustomRentalPriceInput {
  day: Int!
  price: CurrencyValue!
}

type CustomRentalPriceType {
  day: Int!
  price: CurrencyValue!
}

type DashboardCountsPayload {
  count: Int!
}

type DashboardVendorCounts {
  active: Int!
  inactive: Int!
}

type DashboardVendorPayload {
  brand: DashboardVendorCounts!
  gym: DashboardVendorCounts!
  instructor: DashboardVendorCounts!
}

type DashboardVendorShopCounts {
  active: Int!
  inactive: Int!
}

type DashboardVendorShopPayload {
  product: DashboardVendorShopCounts!
}

# A day in format 'yyyy-mm-dd'
scalar Date

input DateRange {
  from: Date!
  to: Date!
}

input DateRangePT {
  startDate: String
  endDate: String
}

enum DateSorting {
  DATE_ASC
  DATE_DESC
}

enum DateSortingCCR {
  DATE_ASC
  DATE_DESC
}

# An iso 8601 date-time string
scalar Datetime

type daysToRenew {
  days: Int!
}

type DeleteAccessGatePayload {
  success: Boolean
  error: GymAccessGateError
  errors: [GymAccessGateError!]
}

type DeleteAccessLevelPayload {
  success: Boolean
  error: GymAccessLevelError
  errors: [GymAccessLevelError!]
}

input DeleteAGymClassInput {
  gymClassId: ID!
  deletedFor: String!
  deletedTime: String!
}

type DeleteAGymClassPayload {
  success: Boolean
  error: GymClassError
  errors: [GymClassError!]
  errorMessage: String
}

type DeleteAGymClassPayloadV2 {
  success: Boolean
  error: GymClassError
  errors: [GymClassError!]
  errorMessage: String
}

type DeleteAllCustomersPayload {
  status: Boolean
  message: String
}

type DeleteCommentPayload {
  success: Boolean
  error: CommentError
  errors: [CommentError!]
}

type DeleteCourtCommentPayload {
  success: Boolean
  error: CourtCommentErrors
  errors: [CourtCommentErrors!]
}

input DeleteCustomerAccountInput {
  reason: String
  note: String
}

type DeleteCustomerAccountPayload {
  status: Boolean
  error: AccountDeletionRequestError
  errorMessage: String
}

type DeleteCustomerAddressPayload {
  customerAddresses: [CustomerAddress!]
  error: CustomerAddressError
  errors: [CustomerAddressError!]
  errorMessage: String
}

type DeleteCustomerPayload {
  status: Boolean
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

type DeleteDiscountPayload {
  success: Boolean
  error: DiscountError
  errors: [DiscountError!]
}

input DeleteFileInput {
  id: ID!
}

type DeleteFilePayload {
  status: Boolean
  errorMessage: String
  error: FileError
  errors: [FileError!]
}

type DeleteGymClassCommentPayload {
  success: Boolean
  error: GymClassCommentErrors
  errors: [GymClassCommentErrors!]
}

type DeleteInstructorCommentPayload {
  success: Boolean
  error: InstructorCommentError
  errors: [InstructorCommentError!]
}

type DeleteLeadPayload {
  status: Boolean
  error: LeadError
  errors: [LeadError]
  errorMessage: String
}

input DeleteMembershipFreezeTypeMutationInput {
  id: ID!
}

input DeleteMembershipMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
}

type DeleteTaskPayload {
  status: Boolean!
  error: FollowUpError
  errors: [FollowUpError]
  errorMessage: String
}

input DeleteWhiteListedNumber {
  id: String!
}

enum DifficultyLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCE
}

# Discounts
type Discount {
  id: ID!
  name: String!
  status: DiscountStatus!
  gymId: ID!
  percentage: Float
  fixedAmount: Float
  currency: String
  maxLimit: Int
  forMembers: Boolean
  forNonMembers: Boolean
  startDate: Date!
  endDate: Date!
  externalId: String
  membershipIds: [String!]
  sessionContractIds: [String!]
  classIds: [String!]
  posProductIds: [String!]
}

type DiscountDetails {
  id: ID
  name: String
  percentage: Float
  fixedAmount: Float
  maxLimit: Float
}

enum DiscountError {
  NOT_ALLOWED
  DISCOUNT_NOT_FOUND
  INVALID_ID
  OFFER_VALUE_MISSING
  MULTI_OFFER_ERROR
}

input DiscountsFilter {
  searchText: String
  status: DiscountStatus
  gymId: ID
  startDate: Date
  endDate: Date
  membershipId: String
  sessionContractId: String
  classId: String
  posProductId: String
}

type DiscountsPayload {
  list: [Discount!]
  paging: PaginatorOutputUpdated
  error: DiscountError
  errors: [DiscountError!]
  errorMessage: String
}

enum DiscountStatus {
  ACTIVE
  INACTIVE
  EXPIRED
}

input DislikeAnEventInput {
  eventId: ID!
}

type DislikeEvent {
  data: EventLike
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

type dueAmount {
  amount: Float
}

type dueAmountPerCustomer {
  amount: Float
}

type DuplicateLeadCount {
  gymId: ID
  phoneNumber: String
  status: String
  count: String
}

type DuplicateLeadResponse {
  leads: [DuplicateLeadCount]
}

type DynamicAddressFieldsData {
  # the id of the field
  id: ID!
  # value set by the customer
  value: String
}

type DynamicAddressFieldsFullData {
  # the id of the field
  id: ID!
  # the name of the field
  title: String!
  # the type of the field
  type: AddressFieldType!
  # value set by the customer
  value: String
  # is the field required
  isRequired: Boolean!
}

input DynamicAddressFieldsInput {
  id: ID!
  value: String
}

type DynamicPropertyPair {
  key: String!
  value: String!
}

type ElgibleForFreeTrialPayload {
  allowed: Boolean!
}

input EligibleToBookGymClassParams {
  scheduleGroupId: ID!
  scheduleId: ID!
  gymId: ID!
  customerId: ID!
  forDate: Date
}

type EligibleToBookGymClassPayload {
  success: Boolean!
  error: String
  errorMessage: String
  data: TestCustomerData
}

type enumValues {
  name: String!
}

type EnumValuesPayLoad {
  enumValues: [enumValues!]
}

type EstimateCancelRefund {
  amount: Float
  currency: String
}

input EstimateCancelRefundQueryArgs {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
}

type EstimateCancelRefundQueryResponse {
  data: EstimateCancelRefund
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type Event {
  id: ID!
  name: String!
  description: String!
  startDate: String!
  endDate: String!
  latitude: Float!
  longitude: Float!
  distance: Float
  address: String!
  capacity: Int!
  reservedSpotCount: Int!
  price: Float
  pictures: [String]!
  videos: [String]
  difficulty: EventDifficulty!
  equipment: String
  rules: String!
  cancelationPolicy: String!
  status: EventStatus!
  creatorPhoneNumber: String!
  reviewCount: Int!
  averageRating: Float!
  isLiked: Boolean!
  createdById: ID!
  createdAt: String!
  updatedAt: String!
  registeredUsers: [User]
  registeredPTs: [Trainer]
  admin: EventsAdmin!
  gym: EventGym!
  trainers: [Trainer]
  country: EventCountry!
  likes: [EventLike]
  reviews: [EventReview]
  purchases: [EventPurchase]
}

type EventAverageRating {
  hostRating: Float
  participantRating: Float
  generalRating: Float
  allAverage: Float
}

type EventCount {
  data: Int
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

type EventCountry {
  id: ID!
  name: String!
  currency: String!
}

enum EventDifficulty {
  beginner
  medium
  advanced
}

input EventFilterInput {
  longitude: Float
  latitude: Float
  distance: Float
  minPrice: Float
  maxPrice: Float
  startDate: String
  endDate: String
  countryId: ID
  gymId: ID
  brandId: ID
  name: String
  description: String
  status: EventStatus
  createdById: ID
  filterType: String
}

type EventGym {
  id: ID!
  name: String!
  description: String
  email: String!
  images: String!
  phone: String!
  status: String!
  brandId: ID!
}

type EventLike {
  id: ID!
  event: PlainEvent!
  userId: String!
  liked: Boolean!
  createdAt: String!
  updatedAt: String!
}

type EventOrder {
  id: ID
  shortCode: String
  customerId: ID
  eventId: ID
  count: Int
  total: Float
  subtotal: Float
  amountDue: Float
  paymentStatus: EventPaymentStatus
  status: String
  createdAt: String
  updatedAt: String
}

input EventPagination {
  index: Int
  page: Int
  limit: Int!
}

input EventPaymentMethodInput {
  paymentScheme: EventPaymentStatusTypes!
  name: String!
  imageUrl: String
  subText: String
  sourceId: String
}

enum EventPaymentStatus {
  PENDING
  SUCCESS
  FAILURE
}

enum EventPaymentStatusTypes {
  KNET
  STC_PAY
  MADA
  CARD
  ADD_CARD
  SAVED_CARD
  APPLE_PAY
  GOOGLE_PAY
  LAUNCH
}

type EventPurchase {
  id: ID!
  event: PlainEvent!
  userId: String!
  status: EventPurchaseStatus!
  code: String
  qrCode: String
  count: Int
  createdAt: String!
  updatedAt: String!
}

enum EventPurchaseStatus {
  failed
  reserved
  purchased
  attended
  cancelled
}

type EventReview {
  id: ID!
  event: PlainEvent!
  hostRating: Float!
  participantRating: Float!
  generalRating: Float!
  comment: String!
  user: User!
  createdAt: String!
  updatedAt: String!
}

type EventsAdmin {
  id: ID!
  firstName: String
  lastName: String!
  email: String!
  contactNumber: String
  status: String!
  type: String
  gender: String!
  authId: String!
}

type EventsMobileList {
  id: ID!
  name: String!
  description: String!
  startDate: String!
  endDate: String!
  latitude: Float!
  longitude: Float!
  distance: Float
  address: String!
  capacity: Int!
  reservedSpotCount: Int!
  price: Float
  pictures: [String]!
  videos: [String]
  difficulty: EventDifficulty!
  equipment: String
  rules: String!
  cancelationPolicy: String!
  status: EventStatus!
  creatorPhoneNumber: String!
  createdById: ID!
  createdAt: String!
  updatedAt: String!
  brandId: ID!
  gymName: String!
  currencyCode: String!
  reviewCount: Int!
  averageRating: Float
  isLiked: Boolean!
  attendeePhotos: [String]
}

type EventsResponseStatus {
  success: Boolean!
  reason: String
  errorMessage: String
}

enum EventStatus {
  planned
  ended
  cancelled
  removed
}

input ExtendMembershipMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  customerId: ID!
  numberPeriods: Int!
  reason: String!
  salesPersonId: ID
  note: String
}

type ExternalBrand_Customer {
  id: ID!
  name: String!
}

type ExternalBrand_P {
  id: ID!
  name: String!
  email: String!
  status: GlobalStatusType!
  logo: String!
  phone: String!
  legalName: String
  countryId: ID!
}

# Brands
type ExternalBrand_Vendors {
  id: ID!
  name: String!
  email: String!
  status: GlobalStatusType!
  logo: String!
  phone: String!
  legalName: String
  country: VendorsShopCountry_Common!
}

input ExternalBrand_VendorsFiler {
  searchText: String
  status: GlobalStatusType
  countryId: ID
}

type ExternalBrand_VendorsPayload {
  list: [ExternalBrand_Vendors]
  paging: PaginatorOutput
}

type ExternalBrand_VP {
  id: ID!
  name: String!
  email: String!
  status: GlobalStatusType!
  logo: String!
  phone: String!
  legalName: String
  countryId: ID!
}

type ExternalGym_Customer {
  id: ID!
  name: String!
  email: String
  phone: String
  images: [String]
  brand: ExternalBrand_Customer!
}

type ExternalGym_Instructor {
  id: ID!
  name: String!
  prefix: String
  email: String!
  brandId: ID
  images: [String]
  legalName: String!
  phone: String!
  status: String!
}

type ExternalGym_P {
  id: ID!
  name: String!
  prefix: String
  images: [String!]
  shortAddress: String
  freeTrial: Boolean
  trialForDays: Int
  trialSalientFeatures: [String!]
  trialRangeStartTime: LocalTime
  trialRangeEndTime: LocalTime
  trailSlotDivider: Int
  rangeStr: String
}

# Gyms.
type ExternalGym_Vendors {
  id: ID!
  name: String!
  email: String!
  status: GlobalStatusType!
  logo: String!
  phone: String
  legalName: String
  brand: ExternalBrand_Vendors!
}

type ExternalGym_VP {
  id: ID!
}

type ExternalInstructor_VP {
  id: ID!
  name: String!
  firstName: String!
  lastName: String
  email: String!
  status: GlobalStatusType!
  photo: String
  contactNumber: String!
  authId: String
}

input FavoriteGymBuddiesFilter {
  favoriterId: ID!
}

type FavoriteGymBuddiesPayload {
  list: [FavoriteGymBuddy]
  paging: PaginatorOutput
}

# Favorite Gym Buddy
type FavoriteGymBuddy {
  id: ID!
  favoriterId: ID!
  favoriteBuddy: GymBuddy!
  createdAt: Datetime!
  updatedAt: Datetime!
}

input FavoriteGymBuddyFilter {
  customerId: ID!
  # User's current location
  location: GISLocationInput
  # filter Gym buddies for searched text
  searchText: String
}

type FavouriteCourt {
  id: ID!
  courtId: ID!
  customerId: ID!
  isFavourite: Boolean!
}

enum FavouriteCourtError {
  ALREADY_FAVOURITE
  INVALID_ID
}

type FavouriteCourtPayload {
  favouriteCourt: FavouriteCourt
  errorMessage: String
  error: FavouriteCourtError
  errors: [FavouriteCourtError!]
}

input FavouriteGymBuddiesByAuthParams {
  # User's current location
  location: GISLocationInput
}

type FavouriteGymClassesPayload {
  list: [GymClass!]
  paging: PaginatorOutput
}

input FavouriteGymClassInput {
  gymClassId: ID!
}

type FavouriteGymClassPayload {
  success: Boolean
  error: GymClassError
  errors: [GymClassError!]
  errorMessage: String
}

enum FavouriteGymError {
  INVALID_GYM_ID
  ALREADY_FAVOURITE
  INVALID_CUSTOMER
}

input FavouriteGymInput {
  gymId: ID!
}

type FavouriteGymPd {
  success: Boolean
  error: FavouriteGymError
  errors: [FavouriteGymError!]
  errorMessage: String
}

type FavouriteGymsPayload {
  list: [Gym!]
  paging: PaginatorOutput
}

input FavouriteInstructorParams {
  location: GISLocationInput
}

enum FBRegisteredDeviceError {
  INTERNAL_SERVER_ERROR
  INVALID_ID_FORMAT
  INVALID_DATA
}

input FetchLeadsFilter {
  searchText: String
  type: LeadType
  gymId: ID!
  status: LeadStatus
}

input FetchLeadsFilterV2 {
  searchText: String
  memberFlag: MemberFlag!
  gymId: ID!
  leadStatus: [LeadStatus]
  leadSubStatus: [LeadSubStatus]
  salesBy: [ID]
  leadAdded: LeadDateRange
  leadType: [LeadType]
  leadSource: [LeadSource]
  gender: CustomerGenderType
  age: LeadAgeInput
  lastAction: LeadDateRange
  lastChangeToLead: LeadDateRange
  dateRange: LeadDateRange
  leadKPIs: LeadKPIs
  paymentStatus: LeadPaymentStatus
}

input FetchMembersFilter {
  searchText: String
  type: LeadType
  gymId: ID!
  memberships: [String]
  dateRange: LeadDateRange
  leadStatus: [LeadStatus]
  leadSubStatus: [LeadSubStatus]
  assignedTrainer: ID
  membershipStatus: [MembershipStatus]
  salesBy: [ID]
  gender: CustomerGenderType
  age: LeadAgeInput
  leadAdded: LeadDateRange
  memberSince: LeadDateRange
  memberKPIs: MemberKPIs
  paymentStatus: LeadPaymentStatus
}

type File {
  id: ID!
  description: String
  userId: ID!
  userType: UserType!
  fileURL: String!
  fileType: FileType!
  fileCategoryId: ID
  fileCategory: FileCategory
  status: GlobalStatusType!
  createdAt: Datetime!
  updatedAt: Datetime!
}

type FileCategory {
  id: ID!
  description: String
  name: String!
  iconURL: String!
  status: GlobalStatusType!
  filesCount: Int
  files: [File]
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum FileCategoryError {
  INVALID_ID
  ALREADY_EXISTS
  INVALID_ICON_URL
  INTERNAL_SERVER_ERROR
}

input FileCategoryFilter {
  searchText: String
  status: GlobalStatusType
  userId: ID
  userType: UserType
}

type FileCategoryPayload {
  list: [FileCategory]
  paging: PaginatorOutput
}

enum FileError {
  INVALID_ID
  DUPLICATE_FILES
  ALREADY_DELETED
  INVALID_USER_ID
  INVALID_USER_TYPE
  INVALID_FILE_URL
  INTERNAL_SERVER_ERROR
}

input FileFilter {
  searchText: String
  userId: ID
  userType: UserType
  fileType: FileType
  fileCategoryId: ID
  status: GlobalStatusType
}

type FilePayload {
  list: [File]
  paging: PaginatorOutput
}

enum FileType {
  DOC
  EXCEL
  PNG
  JPEG
  PDF
}

input FileTypeInput {
  description: String
  fileURL: String!
  fileType: FileType!
  fileCategoryId: ID!
}

type FollowUp {
  id: ID
  type: String
  leadId: String
  title: String
  note: String
  createdAt: Date
  createdBy: ID
  followupCreatedBy: ID
  followupDate: String
  followupTime: String
  startDate: String
  endDate: String
  priority: String
  status: String
  lastUpdatedBy: ID
}

enum FollowUpError {
  INVALID_ID
  INVALID_STATUS
  REQUIRED_FIELD
  INVALID_LEAD_ID
  INVALID_FOLLOWUP_TYPE
  INTERNAL_SERVER_ERROR
  ALREADY_EXISTS
  IMPOSSIBLE_OPERATION
  INVALID_ID_FORMAT
  NOT_ALLOWED
}

enum FollowUpPriority {
  TOP
  NORMAL
  LOW
}

input FollowUpsFilter {
  leadId: ID
}

type FollowUpsPayload {
  list: [FollowUp]
  paging: PaginatorOutput
}

enum FollowUpStatusType {
  ACTIVE
  INACTIVE
  DELETED
}

enum FollowUpType {
  CALL
  TASK
  APPOINTMENT
  NOTE
  EMAIL
  NOTIFICATION
}

type found {
  found: Boolean
}

input FreeTrialAlreadyAttendedInput {
  gymId: String!
}

type FreeTrialAlreadyAttendedPayload {
  alreadyAttended: Boolean!
}

input FreeTrialAvailableSlotsAdminParams {
  startDate: Date!
  endDate: Date!
  timeZoneIdentifier: String!
}

type FreeTrialAvailableSlotsNode {
  date: Date!
  slots: [FreeTrialAvailableSlotsNodeSlots!]
  message: String
}

type FreeTrialAvailableSlotsNodeSlots {
  startTimeKey: LocalTime!
  endTimeKey: LocalTime!
  rangeStr: String!
  available: Boolean!
}

input FreeTrialAvailableSlotsParams {
  startDate: Date!
  endDate: Date!
  timeZoneIdentifier: String!
}

type FreeTrialAvailableSlotsPayload {
  errorMessage: String
  alreadyAvailed: Boolean!
  list: [FreeTrialAvailableSlotsNode!]
}

type FreeTrialBookingsAdminPayload {
  list: [OrderTrial!]
  paging: PaginatorOutputUpdated!
}

type FreeTrialBookingsAdminV2Payload {
  list: [OrderTrialAdminV2!]
  paging: PaginatorOutputUpdated!
}

type FreeTrialBookingsMobilePayload {
  list: [OrderTrial!]
  paging: PaginatorOutputUpdated!
}

type FreeTrialInfoPayload {
  trialEnabledForThisGym: Boolean!
  trialsInfo: [TrialInfo!]
}

type FreezeMembership {
  request: MembershipActionRequest
}

input FreezeMembershipFromAdminMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  freezeTypeId: ID!
  paymentMethod: MembershipPaymentMethod!
}

input FreezeMembershipMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  customerId: ID!
  reason: FreezeReasonEnum!
  freezeId: ID!
  paymentMethod: MembershipPaymentMethod
  documents: [ID]
  note: String
}

type FreezeMembershipMutationResponse {
  data: FreezeMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

enum FreezeReasonEnum {
  MEDICAL
  BREAK
  OTHER
}

type FreezeReasonType {
  key: FreezeReasonEnum!
  description: String!
  details: String
}

type futureContractEndingCsvReportQueryResponse {
  data: getFutureContractEndingCsvReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type futureContractEndingCsvReportQueryResponseV2 {
  data: getFutureContractEndingCsvReportV2
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type futureContractEndingCsvReportType {
  date: String
  total: Int
}

type futureContractEndingCsvReportTypeV2 {
  id: ID!
  membershipName: String!
  pricingPlan: String!
  status: String!
  startDate: String!
  endDate: String!
  userId: ID!
  gymId: ID!
  name: String!
  leadId: ID!
  PhoneNumber: String
  email: String
  customerCode: String
  employeeName: String
}

type futureContractEndingReport {
  monthSeries: [monthSeriesNode]
}

type futureContractEndingReportQueryResponse {
  data: futureContractEndingReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type GatesPayload {
  list: [GymAccessGate!]
  paging: PaginatorOutputUpdated
}

enum GateVendorType {
  ZK
  SAMSUNG
  NONE_OF_THEM
}

input GCPaymentMethodInput {
  paymentScheme: GCPaymentScheme!
  name: String!
  imageUrl: String
  subText: String
  sourceId: String
}

enum GCPaymentScheme {
  KNET
  STC_PAY
  MADA
  AMEX
  CARD
  ADD_CARD
  SAVED_CARD
  APPLE_PAY
  GOOGLE_PAY
  LAUNCH
  CASH
  CARD_OVER_COUNTER
}

type GCRatingTypes {
  type: String!
  score: Float!
}

input GCRatingTypesInput {
  type: String!
  score: Float!
}

type GCtotalPayload {
  totalComments: Int!
  avgRatingScore: Float
}

enum GenderEnum {
  male
  female
  any
}

type GenerateGymQrCodePayload {
  gymQrCode: GymQrCode
  error: GymQrCodeError
  errors: [GymQrCodeError!]
}

type GenerateWebsiteIntegrationSecretKeyPayload {
  secretKey: String
  error: GymError
  errors: [GymError!]
  errorMessage: String
}

type GetAllGuestsListPayload {
  list: [GuestUser]
  paging: PaginatorOutputUpdated
  error: GuestErrors
  errors: [GuestErrors!]
  errorMessage: String
}

type GetAllTransactionsForCustomerPayload {
  list: [SingleTransaction!]
  paging: PaginatorOutputUpdated
}

input GetAnEventInput {
  eventId: ID!
}

input GetAvailableRefundAmountQueryFilter {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  customerId: ID!
}

type GetAvailableRefundAmountQueryResponse {
  data: availableRefundAmount
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input getAvergeMembershipFeeQueryFilters {
  countryId: ID!
  gymIds: [ID]
}

input GetBulkEmailsListFilter {
  searchText: String
  gymId: ID!
}

type GetBulkEmailsListPayload {
  list: [BulkEmails]
  paging: PaginatorOutputUpdated
  error: ComposeBulkEmailsError
  errors: [ComposeBulkEmailsError!]
  errorMessage: String
}

input GetBulkNotificationsListFilter {
  searchText: String
  gymId: ID!
}

type GetBulkNotificationsListPayload {
  list: [BulkNotifications]
  paging: PaginatorOutputUpdated
}

input GetDailySalesReportFilter {
  startDate: String
  endDate: String
}

type GetDailySalesReportResponse {
  data: IGetDailySalesReportResponseData
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetDaysToRenewQueryFilter {
  customerId: ID
  gymId: ID
}

type GetDaysToRenewQueryResponse {
  data: daysToRenew
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetDueAmountPerCustomerQueryFilter {
  customerId: ID!
  gymId: ID
}

type GetDueAmountPerCustomerQueryResponse {
  data: dueAmountPerCustomer
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetDueAmountQueryFilter {
  singleMembershipId: ID
  groupMembershipId: ID
}

type GetDueAmountQueryResponse {
  data: dueAmount
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type getFutureContractEndingCsvReport {
  link: String!
  records: [futureContractEndingCsvReportType]
}

input getFutureContractEndingCsvReportQueryFilters {
  countryId: ID
  gymIds: [ID]
}

input getFutureContractEndingCsvReportQueryFiltersV2 {
  countryId: ID
  gymIds: [ID]
  dateRange: graphQLDateRange!
}

type getFutureContractEndingCsvReportV2 {
  records: [futureContractEndingCsvReportTypeV2]
}

input getFutureContractEndingReportQueryFilters {
  countryId: ID
  gymIds: [ID]
}

input GetGroupMembershipPlanQueryFilter {
  id: ID!
}

type GetGroupMembershipPlanQueryResponse {
  data: OneGroupMembershipPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetGroupMembershipPlansQueryFilter {
  status: MembershipPlanTypeStatus
  visible: Boolean
  adminId: ID
  gymId: ID
  type: PaymentTypeEnum
  recursionPeriod: MembershipPlanTypePeriod
  text: String
}

type GetGroupMembershipPlansQueryResponse {
  data: GroupMembershipPlans
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type GetGuestUserByIdPayload {
  guest: GuestUser
  error: GuestErrors
  errors: [GuestErrors]
  errorMessage: String
}

input GetGymCheckinCountPerCustomerQueryFilter {
  customerId: ID!
  gymId: ID
}

type GetGymCheckinCountPerCustomerQueryResponse {
  data: GymCheckinCountPerCustomer
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetGymQrSessionCountQueryFilter {
  singleMembershipId: ID
  groupMembershipId: ID
}

type GetGymQrSessionCountQueryResponse {
  data: GymQrSessionCount
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetGymQrSessionsQueryFilter {
  singleMembershipId: ID
  groupMembershipId: ID
}

type GetGymQrSessionsQueryResponse {
  data: GymQrSessions
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type GetGymVideosByCategoryPayload {
  list: [GetGymVideosByCategoryPayloadNode!]
  error: String
}

type GetGymVideosByCategoryPayloadNode {
  categoryName: String!
  image: String
  count: Int!
  dataSet: [VideoListView!]
}

type GetInstructorVideosByCategoryPayload {
  list: [GetInstructorVideosByCategoryPayloadNode!]
  error: String
}

type GetInstructorVideosByCategoryPayloadNode {
  categoryId: ID!
  categoryName: String!
  image: String
  count: Int!
  dataSet: [VideoListView!]
}

input getLiveMembersReportQueryFilters {
  countryId: ID
  gymIds: [ID]
}

input getMemberActivityCsvReportQueryFilters {
  countryId: ID
  gymIds: [ID]
  range: graphQLDateRange!
}

input getMemberActivityReportQueryFilters {
  countryId: ID
  gymIds: [ID]
}

input getMembersGymCheckInCsvReportQueryFilters {
  countryId: ID
  gymIds: [ID]
  range: graphQLDateRange!
}

input getMembersGymCheckInReportQueryFilters {
  countryId: ID
  gymIds: [ID]
}

input GetMembershipActionRequestByIdQueryFilter {
  id: ID!
}

type GetMembershipActionRequestByIdQueryResponse {
  data: membershipActionRequestByIdPayload
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipActionRequestsQueryFilter {
  adminId: ID
  userId: ID
  gymId: ID
  type: MembershipActionRequestTypeEnum
  status: MembershipActionRequestStatusEnum
}

type GetMembershipActionRequestsQueryResponse {
  data: membershipActionRequests
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input getMembershipAgeRangeQueryFilters {
  countryId: ID
  gymIds: [ID]
}

type GetMembershipCancellationReasonsQueryResponse {
  data: MembershipCancellationReasons
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input getMembershipCancellationReportQueryFilters {
  interval: TimeIntervalType!
  countryId: ID
  gymIds: [ID]
}

type GetMembershipCountQueryResponse {
  data: MembershipCountResponse
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipCountsQueryFilter {
  type: String
}

input GetMembershipDescriptionQueryFilter {
  name: MembershipDescriptionNameEnum!
  type: MembershipDescriptionResponseTypeEnum
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
}

type GetMembershipDescriptionQueryResponse {
  data: membershipDesciption
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipExtensionDetailsForAdminQueryFilter {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
}

type GetMembershipExtensionDetailsForAdminQueryResponse {
  data: MembershipExtensionDetailsForAdminResponse
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipExtensionsForAdminQueryFilter {
  status: MembershipStatus
  text: String
  isExtendedByAdmin: Boolean
}

type GetMembershipExtensionsForAdminQueryResponse {
  data: MembershipExtensionsForAdmin
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipFreezeDetailsForAdminQueryFilter {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
}

type GetMembershipFreezeDetailsForAdminQueryResponse {
  data: MembershipFreezeDetailsForAdminResponse
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type GetMembershipFreezeReasonsQueryResponse {
  data: MembershipFreezeReasons
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipFreezesForAdminQueryFilter {
  status: MembershipStatus
  text: String
  gymId: ID
  isFrozenByAdmin: Boolean
}

type GetMembershipFreezesForAdminQueryResponse {
  data: MembershipFreezesForAdmin
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipFreezeTypeQueryFilter {
  id: ID!
}

type GetMembershipFreezeTypeQueryResponse {
  data: OneMembershipFreezeType
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipFreezeTypesQueryFilter {
  status: MembershipGlobalStatusEnum
  text: String
  gymId: ID
  brandId: ID
}

type GetMembershipFreezeTypesQueryResponse {
  data: MembershipFreezeTypes
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input getMembershipNetGainReportQueryFilters {
  countryId: ID
  gymIds: [ID]
}

input GetMembershipPlanGroupQueryFilter {
  id: ID!
}

type GetMembershipPlanGroupQueryResponse {
  data: OneMembershipPlanGroup
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipPlanGroupsQueryFilter {
  text: String
  id: String
  status: MembershipPlanTypeStatus
}

input GetMembershipPlanGroupsQueryFilterV2 {
  text: String
  id: String
  status: MembershipPlanTypeStatus
  gymId: ID!
}

type GetMembershipPlanGroupsQueryResponse {
  data: membershipPlanGroups
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type GetMembershipPlanGroupsQueryResponseV2 {
  data: membershipPlanGroupsV2
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipPlansQueryFilter {
  status: MembershipPlanTypeStatus
  visible: Boolean
  adminId: ID
  gymId: ID
  type: PaymentTypeEnum
  recursionPeriod: MembershipPlanTypePeriod
  text: String
}

type GetMembershipPlansQueryResponse {
  data: MembershipPlans
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipQueryFilter {
  status: MembershipStatus
  gymId: ID
  membershipId: ID
}

type GetMembershipQueryResponse {
  data: OneMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipsQueryFilter {
  status: MembershipStatus
  userId: ID
  text: String
  gymId: ID
  appId: ID
}

type GetMembershipsQueryResponse {
  data: Memberships
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type GetMembershipsWithFilterQueryResponse {
  data: MembershipsWithFilter
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetMembershipsWithtypeFilterQueryFilter {
  type: String
}

type GetMembershipTerminateReasonsQueryResponse {
  data: MembershipTerminateReasons
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input getMembersStatusesCsvQueryFilters {
  countryId: ID!
  gymIds: [ID]
  dateRange: graphQLDateRange!
}

input getMembersStatusesQueryFilters {
  countryId: ID!
  gymIds: [ID]
}

input GetPaymentPlansQueryFilter {
  adminId: ID
}

type GetPaymentPlansQueryResponse {
  data: paymentPlans
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetPaymentQueryFilter {
  status: PaymentStatusEnum
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
}

type GetPaymentQueryResponse {
  data: payments
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetSessionPackPlanQueryFilter {
  id: ID!
}

type GetSessionPackPlanQueryResponse {
  data: OneSessionPackPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetSessionPackPlansQueryFilter {
  status: MembershipPlanTypeStatus
  visible: Boolean
  adminId: ID
  gymId: ID
  type: PaymentTypeEnum
  recursionPeriod: MembershipPlanTypePeriod
  text: String
}

type GetSessionPackPlansQueryResponse {
  data: sessionPackPlans
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetSingleMembershipPlanQueryFilter {
  id: ID!
}

type GetSingleMembershipPlanQueryResponse {
  data: OneSingleMembershipPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input GetSingleMembershipPlansQueryFilter {
  status: MembershipPlanTypeStatus
  visible: Boolean
  adminId: ID
  gymId: ID
  targetGender: GenderEnum
  targetMinAge: Int
  targetMaxAge: Int
  type: PaymentTypeEnum
  recursionPeriod: MembershipPlanTypePeriod
  text: String
}

type GetSingleMembershipPlansQueryResponse {
  data: SingleMembershipPlans
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input getTopMembersCsvQueryFilters {
  countryId: ID!
  gymIds: [ID]
  intervals: [IntervalEnum]
  dateRange: graphQLDateRange!
}

input getTopMembersQueryFilters {
  countryId: ID!
  type: QuantityOrRevenueEnum!
  gymIds: [ID]
  intervals: [IntervalEnum]
}

input GetUserEventPurchasesInput {
  status: EventPurchaseStatus
  pagination: EventPagination
}

input GetUserEventReviewsInput {
  eventId: ID
}

input GetUserLikedEventsInput {
  userId: ID
}

input GfpHealthQuestions {
  question: String!
  answer: String!
  type: ContentElementType!
}

type GfpHealthQuestionsType {
  question: String!
  answer: BooleanOrString
}

type GfpHealthType {
  answers: [GfpHealthQuestionsType!]
  notes: String
}

# A set of GIS co-ordinates
input GISLocationInput {
  # Longitude, in degrees
  longitude: Float!
  # Latitude, in degrees
  latitude: Float!
}

# A set of GIS co-ordinates
type GISLocationType {
  # Longitude, in degrees
  longitude: Float!
  # Latitude, in degrees
  latitude: Float!
}

enum GlobalGenderType {
  MALE
  FEMALE
  ANY
}

enum GlobalStatusType {
  ACTIVE
  INACTIVE
}

input GmsInstructorImportInput {
  batchNo: String!
  csvPrefix: String!
  gymId: String!
  fileUrls: [String!]!
}

type GmsInstructorImportPayload {
  success: Boolean
  totalRecords: Int
  totalInserted: Int
  errorMessage: String
}

enum gqlGymQrSessionType {
  qr
  manual
}

input graphQLDateRange {
  startDate: String!
  endDate: String!
}

type GroupMemberCustomers {
  id: ID
  firstName: String
  lastName: String
  fullName: String
  photo: String
}

type GroupMembership {
  id: ID!
  name: String!
  status: MembershipStatus!
  membershipCode: String
  startDate: String!
  endDate: String
  membershipId: String!
  qrCode: String!
  availableSpotCount: Int!
  price: Float!
  frozenById: String
  joiningFee: Float!
  currency: String
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentRecursionDuration: Int
  chargeOnFirst: Boolean
  hasEndDate: Boolean
  recursionPeriod: MembershipPlanTypePeriod
  recursionDuration: Int
  gracePeriodDays: Int
  allowFreeze: Boolean
  freezesList: [MembershipFreezeDetails]
  giftPeriodFree: Boolean
  previousMembershipId: ID
  membershipPlan: GroupMembershipPlan!
  owner: MembershipUser!
  admin: MembershipAdmin
  members: [MembershipUser]
  payments: [Payment]
  gyms: [MembershipGym]
  userServicePacks: [UserServicePackType]
  paymentPlan: PaymentPlan
  isChampion: Boolean
  championType: ChampionType
  champAppId: String
  subDomesticGymIds: [String]
  champId: String
  createdAt: String!
  updatedAt: String!
}

type GroupMembershipPlan {
  id: ID!
  name: String!
  description: String!
  color: String
  status: MembershipPlanTypeStatus!
  visible: Boolean!
  maxMemberCount: Int!
  admin: MembershipAdmin!
  paymentPlans: [PaymentPlan]
  gyms: [MembershipGym]
  servicePacks: [ServicePackObjectType]
  isChampion: Boolean
  championType: ChampionType
  champAppId: String
  subDomesticGymIds: [String]
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
  createdAt: String!
  updatedAt: String!
}

type GroupMembershipPlans {
  groupMembershipPlans: [GroupMembershipPlan]
}

type GroupNotification {
  id: ID!
  diffusionType: GroupNotificationDiffusionType
  title: String
  description: String
  createdAt: Date!
  createdById: ID!
  createdByName: String
}

enum GroupNotificationDiffusionType {
  LEADS
  MEMBERS
  ALL_MALE
  ALL_FEMALE
  EXPIRED_MEMBERS
  ALL
}

type GroupNotificationsPayload {
  list: [GroupNotification]
  paging: PaginatorOutput
}

enum GuestErrors {
  INVALID_GUEST_ID
}

input GuestLoginInput {
  xAppSource: String!
  deviceId: String!
  gymId: String!
}

# Guest User
type GuestUser {
  id: ID!
  gymId: ID!
  deviceId: String!
  xAppSource: String!
}

# Gyms
type Gym {
  id: ID!
  name: String!
  prefix: String
  description: String
  email: String!
  brand: Brand!
  images: [String!]!
  legalName: String!
  ratingScore: Float!
  phone: String!
  rules: [RulesPayload!]
  rulesDescription: String
  termsAndConditions: String
  socialMediaReferences: [VSocialMediaReference!]
  address: GymAddress!
  status: String!
  opening: GymOpening
  amenities: [String!]
  amenityList: [Amenity!]
  amenityDetailList: [GymAmenity!]
  workoutMachines: [String!]
  workoutMachinesDetails: [WorkoutMachine!]
  createdBy: Admin!
  lastUpdatedBy: Admin!
  createdAt: Datetime!
  updatedAt: Datetime!
  admins: [Admin!]
  memberCount: Int!
  recentMemberPhotos: [GymRecentMemberPhotos!]
  operatingHours: [GymOperatingHours]
  distance: Float
  feetDistance: Int
  perMinuteSessionAmount: PerMinuteSessionAmount
  qrCode: GymQrCode
  priceType: PriceType!
  reviewSummary: GymQrReviewSummary
  accessOrigins: [String!]
  apiKey: String
  isNotificationsDisabled: Boolean
  isOpen: Boolean
  endTime: LocalTime
  distanceInKm: Float
  avergeRating: Float
  freeTrial: Boolean
  trialForDays: Int
  trialSalientFeatures: [String!]
  trialRangeStartTime: LocalTime
  trialRangeEndTime: LocalTime
  trailSlotDivider: Int
  trailDisclaimer: String
  vatRegistrationNumber: String
  subscriptionType: SubscriptionTypes
  isPaymentGatewayEnabled: Boolean
  paymentProvider: GymPaymentGateway
  isAccessGateEnabled: Boolean
  accessGateVendor: GateVendorType
  gateApiKey: String
  isWebsiteIntegrationEnabled: Boolean
  websiteIntegrationSecretKey: String
  websiteUrls: [String!]
  missingClassLimit: Int
  classBookingBlockDays: Int
  allowMembershipOnFullPayment: Boolean
  allowPTOnFullPayment: Boolean
  signupEnabled: Boolean
}

type Gym_POS {
  id: ID!
  name: String!
  images: [String!]
}

# Gym Access Gate
type GymAccessGate {
  id: ID!
  gymId: ID!
  gateId: Int!
  areaId: Int!
  name: String!
}

enum GymAccessGateError {
  INVALID_ACCESS_GATE_DETAILS
  INVALID_GYM_ID
  EXCEPTION
  INVALID_GATE_ID
  INVALID_AREA_ID
}

# Gym Access Level
type GymAccessLevel {
  id: ID!
  gymId: ID!
  accessLevelId: String!
  name: String!
}

enum GymAccessLevelError {
  INVALID_ACCESS_LEVEL_DETAILS
  EXCEPTION
  INVALID_ACCESS_LEVEL_ID
  INVALID_GYM_ID
}

# Gym Address
type GymAddress {
  id: ID!
  gym: Gym!
  shortAddress: String
  street: String
  unitNumber: String
  floorNo: String
  building: String
  city: String!
  state: String
  zipCode: String
  country: VendorCountry_Common!
  # The longitude component of the geo coordinates for this address, in degrees
  geoLocation: GymAddressGeoLocation!
  createdAt: Datetime!
  updatedAt: Datetime!
}

type GymAddressGeoLocation {
  type: String
  coordinates: [Float]
}

# GymAdmin
type GymAdmin {
  id: ID!
  gym: Gym!
  admin: Admin!
  createdBy: Admin!
  lastUpdatedBy: Admin!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum GymAdminError {
  DUPLICATE_ADMIN
  INVALID_ID
  INVALID_GYM
}

input GymAdminsFilter {
  searchText: String
  gymId: ID
  adminId: ID
}

input GymAdminsOrRelatedFilter {
  gymId: String!
  roles: [String!]
  adminIds: [String!]
}

type GymAdminsOrRelatedPayload {
  list: [AdminRole]
  paging: PaginatorOutput
  message: String
  error: AdminError
}

type GymAdminsPayload {
  list: [GymAdmin]
  paging: PaginatorOutput
}

type GymAmenity {
  isInclude: Boolean!
  id: ID
  name: String!
  icon: String
  status: GlobalStatusType!
}

input GymAmenityInput {
  id: ID
  isInclude: Boolean!
}

# GymBanner
type GymBanner {
  id: ID!
  image: String!
  link: String
  gymId: ID!
  status: GlobalStatusType!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum GymBannerError {
  DUPLICATE_NAME
  INVALID_ID
  NOT_ALLOWED
}

input GymBannerFilter {
  searchText: String
  status: GlobalStatusType
  gymId: ID
}

type GymBannerPayload {
  list: [GymBanner]
  paging: PaginatorOutputUpdated
}

input GymBuddiesFilter {
  searchText: String
  status: GymBuddyOnlineStatus
  distance: RadiusFilter
}

type GymBuddiesMobilePayload {
  list: [GymBuddyBasicList]
  paging: PaginatorOutput
}

type GymBuddiesPayload {
  list: [GymBuddy]
  paging: PaginatorOutput
}

# GymBuddies
type GymBuddy {
  id: ID!
  name: String!
  description: String
  customerId: ID!
  photo: String
  backgroundImage: String
  status: GymBuddyOnlineStatus!
  location: GymBuddyGeoLocation
  locationName: String
  socialAccounts: [SocialAccount]
  interests: [String]
  age: Int
  height: Int
  heightUnit: ID
  heightUnitName: String
  weight: Float
  weightUnit: ID
  weightUnitName: String
  trainingPlace: TrainingPlace
  createdAt: Datetime!
  updatedAt: Datetime!
  customer: Customer!
  distance: Float
  favoriteGymBuddies: [FavoriteGymBuddy]
  followers: [FavoriteGymBuddy]
  followings: [FavoriteGymBuddy]
  suggestedPeople: [FavoriteGymBuddy]
  favoriteGymBuddyCount: Int
  countFollowers: Int
  countFollowings: Int
  isFavorite: Boolean!
  isFollowingMe: Boolean!
  isFollowedByMe: Boolean!
}

type GymBuddyBasicList {
  id: ID!
  customerId: ID!
  name: String!
  description: String
  photo: String
  backgroundImage: String
  status: GymBuddyOnlineStatus!
  location: GymBuddyGeoLocation
  locationName: String
  favoriteGymBuddyCount: Int!
  countFollowers: Int
  countFollowings: Int
  distance: Float
  isFavorite: Boolean!
  isFollowingMe: Boolean!
  isFollowedByMe: Boolean!
}

input GymBuddyFavouriteInput {
  customerId: ID
  favGymBuddyId: ID!
}

type GymBuddyGeoLocation {
  type: String
  coordinates: [Float]
}

input GymBuddyLocationInput {
  customerId: ID!
  location: GISLocationInput!
  type: LocationType!
}

enum GymBuddyOnlineStatus {
  ONLINE
  OFFLINE
}

input GymBuddyPhotoInput {
  id: ID!
  photo: String!
}

type GymCheckinCountPerCustomer {
  count: Int
}

type GymClass {
  id: ID!
  name: String!
  description: String
  gymClassCategoryIds: [ID!]
  instructorIds: [ID!]
  code: ID
  countryId: ID!
  images: [String!]
  status: GlobalStatusType
  startDate: Date!
  endDate: Date
  schedule: [GymClassWeeklySchedule!]
  ratingScore: Float!
  noOfComments: Int!
  duration: Float!
  spots: Int!
  spotsAlotted(forDate: Date): Int!
  gymStudioId: ID
  isPrivate: Boolean!
  difficultyLevel: DifficultyLevel!
  gender: GlobalGenderType!
  age: Age
  estimatedCaloriesBurnt: String
  createdById: ID!
  lastUpdatedById: ID!
  qrCodeUpdatedAt: Datetime!
  createdAt: Datetime!
  updatedAt: Datetime!
  brand: ExternalBrand_VP!
  gym: ExternalGym_VP!
  instructor: ExternalInstructor_VP
  opening(forDate: Date): GymClassOpening
  # will always be 5 or less than 5...5 means 5 or more than 5
  recentMemberPhotos: [GymClassRecentMemberPhotos!]
  gymClassMembershipPrices: [ClassMembershipPrices]
  classType: GymClassType!
  onlineLink: String
  dropInClient: Boolean!
  gymMemberClient: Boolean!
  sentNotification: Boolean!
  pricingType: GymClassPricingType!
  equipment: String
  equipmentLink: String
  dropInClientPrice: CurrencyValue!
  dropInClientPriceLabel: String!
  gymMemberClientPrice: CurrencyValue!
  gymMemberClientPriceLabel: String!
}

type GymClassCategory {
  id: ID!
  name: String!
  description: String
  image: String
  status: GlobalStatusType
  createdAt: Datetime!
  updatedAt: Datetime!
  subtitle: String
  gymClasses: [GymClass!]
}

enum GymClassCategoryError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_GYM_ID
}

input GymClassCategoryFilter {
  searchText: String
  status: GlobalStatusType
  gymId: String
  gymIds: [String]
  shortDateRange: Boolean
}

type GymClassCategoryPayload {
  list: [GymClassCategory]
  paging: PaginatorOutput
}

type GymClassComment {
  id: ID
  gymClassId: ID!
  customerId: ID!
  description: String
  rating: [GCRatingTypes!]
  ratingScore: Float!
  status: CommentStatus!
  createdAt: Datetime
  customer: VendorPlanCustomer
}

enum GymClassCommentErrors {
  INVALID_REVIEW
  INVALID_SCORE
  UNAUTHORIZED
  DUPLICATE_COMMENT
  COMMENT_NOT_FOUND
  TX_ERROR
  INVALID_ID
}

input GymClassCommentsFilter {
  searchText: String
  gymClassId: ID!
  customerId: ID
  status: String!
}

type GymClassCommentsPayload {
  list: [GymClassComment!]
  total: GCtotalPayload
  paging: PaginatorOutput
}

input GymClassDetailFilters {
  # User's current location
  location: GISLocationInput!
  timeZoneIdentifier: String!
  forDate: Date!
}

input GymClassDetailFiltersV2 {
  location: GISLocationInput
  timeZoneIdentifier: String
  forDate: Date!
}

enum GymClassError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_BRAND_ID
  INVALID_GYM_ID
  INVALID_INSTRUCTOR_ID
  INVALID_INSTRUCTOR_AUTH_ID
  OPEN_TIME_REQUIRED
  DURATION_REQUIRED
  INSTRUCTOR_REQUIRED
  INVALID_DATE_RANGE
  SECHEDULE_REQUIRED
  SCHEDULE_ALREADY_EXISTS
  INVALID_SCHEDULE
  INVALID_CATEGORY_ID
  INVALID_CLASS_ID
  ALREADY_FAVOURITE
  INVALID_CUSTOMER
  INVALID_IMAGE_URL
  INVALID_GYM_CLASS_ID
  GYM_CLASS_NOT_ACTIVE
  NOT_ALLOWED
}

type GymClassesByCategoryPayload {
  list: [GymClassesByCategoryPayloadNode!]
}

type GymClassesByCategoryPayloadNode {
  categoryId: ID!
  categoryName: String!
  image: String
  count: Int!
}

input GymClassesCountParams {
  type: CountType!
  gymId: ID
}

input GymClassesFilter {
  classType: GymClassType
  gymStudioId: ID
  gymClassCategoryId: ID
  gymId: ID
  gymIds: [ID!]
  instructorId: ID
  difficultyLevel: DifficultyLevel
  gender: GlobalGenderType
  age: Int
  status: GlobalStatusType
  brandId: ID
  searchText: String
  forDate: Date
  countryId: ID
  available: Boolean
  isReport: Boolean
  dateRange: DateRange
  shortDateRange: Boolean
}

input GymClassesFilterV2 {
  classType: GymClassType
  gymStudioId: ID
  gymClassCategoryId: ID
  gymId: ID
  gymIds: [ID!]
  instructorId: ID
  instructorIds: [ID!]
  difficultyLevel: DifficultyLevel
  gender: GlobalGenderType
  age: Int
  status: GlobalStatusType
  brandId: ID
  searchText: String
  toDate: Date
  fromDate: Date
  countryId: ID
  available: Boolean
  dateRange: DateRange
  shortDateRange: Boolean
}

type GymClassesListing {
  id: ID!
  name: String!
  weekDay: String!
  date: String!
  openTime: LocalTime!
  startTime: LocalTime
  endTime: LocalTime
  scheduleGroupId: ID!
  scheduleId: ID!
  duration: Float!
  age: Age
  instructors: [ExternalInstructor_VP]
  instructorFirstName: String
  instructorLastName: String
  categoryName: String
  description: String
  gymClassCategoryIds: [ID!]
  instructorIds: [ID!]
  instructorNames: String
  countryId: ID
  images: [String]
  gender: GlobalGenderType
  startDate: Date!
  endDate: Date
  estimatedCaloriesBurnt: String
  difficultyLevel: DifficultyLevel
  status: GlobalStatusType
  scheduleGroupStatus: GlobalStatusType
  dropInClientPrice: CurrencyValue
  gymMemberClientPrice: CurrencyValue
  currencyCode: String
  vat: CurrencyValue
  gymStudioId: ID
  soldOut: Boolean
  gymId: ID!
  gymName: String
  brandName: String
  gymClassMembershipPrices: [ClassMembershipPrices]
  spotsCapacity: Int
  spotsAllotted: Int
  isPrivate: Boolean!
  isMember: Boolean
  isAttended: Boolean
  isAttendable: Boolean
  isPurchased: Boolean
  isCancellable: Boolean
  isExpired: Boolean
  equipment: String
  equipmentLink: String
}

input GymClassesListingFilter {
  gymClassCategoryId: ID
  gymId: ID
  instructorIds: [ID!]
  toDate: Date!
  fromDate: Date!
}

type GymClassesListingPayload {
  list: [GymClassesListing]
}

type GymClassesPayload {
  list: [GymClass!]
  paging: PaginatorOutput
}

type GymClassesPayloadV2 {
  list: [GymClassList!]
}

input GymClassesScheduledFromAdminPlatformInput {
  customerId: ID!
  timeZoneIdentifier: String
  gymId: ID!
  instructorId: ID
  categoryId: ID
  forDate: Date!
}

input GymClassesScheduledFromAdminPlatformInputV2 {
  location: GISLocationInput
  timeZoneIdentifier: String
  categoryId: ID
  customerId: ID!
  gymId: ID!
  forDate: Date!
}

input GymClassesScheduledInput {
  # User's current location
  location: GISLocationInput!
  timeZoneIdentifier: String
  gymId: ID!
  instructorId: ID
  categoryId: ID
  forDate: Date!
}

input GymClassesScheduledInputV2 {
  location: GISLocationInput
  timeZoneIdentifier: String
  categoryId: ID
  instructorId: ID
  gymId: ID!
  forDate: Date!
}

type GymClassesScheduledPayload {
  list: [GymClassesListing!]
  paging: PaginatorOutputUpdated
}

type GymClassesScheduleGroupPayload {
  list: [GymClassScheduleGroupList]
  paging: PaginatorOutputUpdated
  error: GymClassError
  errorMessage: String
  errors: [GymClassError!]
}

type GymClassesV2Payload {
  list: [GymClassV2!]
  paging: PaginatorOutputUpdated
}

input GymClassGroupSecheduleFilter {
  searchText: String
  instructorId: String
  status: GlobalStatusType
}

enum GymClassIdError {
  INVALID_CLASS_ID
}

type GymClassIds {
  id: ID!
}

type GymClassInvoice {
  components: [InvoiceComponent!]
  currency: VendorPlanCurrency_Common
  error: GymClassError
  errors: [GymClassError]
  errorMessage: String
}

input GymClassInvoiceInput {
  gymClassId: ID!
}

type GymClassList {
  id: ID!
  categoryName: String
  name: String!
  description: String
  gymClassCategoryIds: [ID!]
  instructorIds: [ID!]
  countryId: ID!
  images: [String]
  startDate: Date!
  endDate: Date
  date: Date!
  ratingScore: Float
  noOfComments: Int
  estimatedCaloriesBurnt: String
  difficultyLevel: DifficultyLevel
  status: GlobalStatusType
  dropInClientPrice: CurrencyValue
  gymMemberClientPrice: CurrencyValue
  currencyCode: String
  vat: CurrencyValue
  gymStudioId: ID
  soldOut: Boolean
  gender: String
  gymId: ID!
  gymName: String
  brandName: String
  gymPhone: String
  isOpen: Boolean
  age: Age
  openTime: LocalTime!
  duration: Float!
  notes: String
  parentId: String
  instructors: [ExternalInstructor_VP!]!
  gymClassMembershipPrices: [ClassMembershipPrices]
  spotsCapacity: Int!
  spotsAllotted: Int!
  defaultInstructorNames: String
  instructorFirstName: String
  instructorLastName: String
  isPrivate: Boolean!
  isAttended: Boolean
  isAttendable: Boolean
  isPurchased: Boolean
  isCancellable: Boolean
  isAlreadyRatad: Boolean
  isExpired: Boolean
  isRecursive: Boolean
  equipment: String
  equipmentLink: String
}

type GymClassListMobile {
  id: ID!
  categoryName: String
  name: String!
  description: String
  gymClassCategoryIds: [ID!]
  instructorIds: [ID!]
  code: ID
  qrCodeUpdatedAt: Datetime!
  countryId: ID!
  countryName: String!
  customerId: ID
  customer: VendorPlanCustomer
  images: [String!]
  startDate: Date!
  endDate: Date
  date: Date!
  ratingScore: Float!
  noOfComments: Int!
  estimatedCaloriesBurnt: String
  difficultyLevel: DifficultyLevel!
  status: GlobalStatusType
  dropInClientPrice: CurrencyValue!
  gymMemberClientPrice: CurrencyValue!
  currencyCode: String!
  vat: CurrencyValue!
  schedule: [GymClassWeeklySchedule!]
  isMember: Boolean!
  spots: Int!
  spotsAlotted: Int!
  gymStudioId: ID
  soldOut: Boolean!
  gymClassId: ID
  gymId: ID!
  gymName: String
  brandName: String
  distance: Float
  distanceInKm: Float
  gymLongitude: Float
  gymLatitude: Float
  gymPhone: String
  isOpen: Boolean!
  startTime: LocalTime
  endTime: LocalTime
  duration: Float!
  notes: String
  membership: Boolean
  membershipName: String
  # default will be set as false, but if customer sends the token
  # we will check if each class if its favourite or not...
  isFavourite: Boolean!
  instructorNames: String
  defaultInstructorNames: String
  instructorFirstName: String
  instructorLastName: String
  recentMemberPhotos: [GymClassRecentMemberPhotos!]
  openTime: LocalTime!
  isPrivate: Boolean!
  isAttended: Boolean!
  isAttendable: Boolean!
  isPurchased: Boolean!
  isCancellable: Boolean!
  # isAlreadyRatad
  isAlreadyRatad: Boolean!
  isExpired: Boolean!
  # for detail page only, dont access in the listing
  isOrdered: Boolean!
  alreadyCommented: Boolean!
  canComment: Boolean!
  qrCode: String
}

type GymClassListMobileV2 {
  id: ID!
  categoryName: String
  name: String!
  description: String
  instructorIds: [ID!]
  code: ID
  countryId: ID!
  countryName: String!
  customerId: ID
  images: [String!]
  startDate: Date!
  endDate: Date
  date: Date!
  estimatedCaloriesBurnt: String
  difficultyLevel: DifficultyLevel!
  status: GlobalStatusType
  dropInClientPrice: CurrencyValue!
  gymMemberClientPrice: CurrencyValue!
  currencyCode: String!
  vat: CurrencyValue!
  isMember: Boolean!
  spots: Int!
  spotsAlotted: Int!
  gymStudioId: ID
  soldOut: Boolean!
  scheduleGroupId: ID
  scheduleId: ID
  gymId: ID!
  gymName: String
  brandName: String
  distance: Float
  distanceInKm: Float
  gymLongitude: Float
  gymLatitude: Float
  gymPhone: String
  isOpen: Boolean!
  startTime: LocalTime
  endTime: LocalTime
  duration: Float!
  notes: String
  membership: Boolean
  membershipName: String
  # default will be set as false, but if customer sends the token
  # we will check if each class if its favourite or not...
  instructorNames: String
  defaultInstructorNames: String
  openTime: LocalTime!
  isPrivate: Boolean!
  isAttended: Boolean!
  isAttendable: Boolean!
  isPurchased: Boolean!
  isCancellable: Boolean!
  # isAlreadyRatad
  isExpired: Boolean!
  qrCode: String
}

type GymClassListSocial {
  id: ID!
  name: String!
  description: String
  images: [String!]
  date: Date!
  ratingScore: Float!
  noOfComments: Int!
  estimatedCaloriesBurnt: String
  difficultyLevel: DifficultyLevel!
  status: GlobalStatusType
  dropInClientPrice: CurrencyValue!
  gymMemberClientPrice: CurrencyValue!
  currencyCode: String!
  schedule: [GymClassSchedule!]
  spotsCapacity: Int!
  spotsAllotted: Int!
  soldOut: Boolean!
  gymId: ID!
  gymName: String
  brandName: String
  distance: Float
  distanceInKm: Float
  gymLongitude: Float
  gymLatitude: Float
  gymPhone: String
  isOpen: Boolean!
  openTime: LocalTime
  duration: Float!
  notes: String
  membership: Boolean
  membershipName: String
  # default will be set as false, but if customer sends the token
  # we will check if each class if its favourite or not...
  isFavourite: Boolean!
  instructorNames: String
  defaultInstructorNames: String
  instructorFirstName: String
  instructorLastName: String
  recentMemberPhotos: [GymClassRecentMemberPhotos!]
  isPrivate: Boolean!
  isAttended: Boolean!
  isAttendable: Boolean!
  isPurchased: Boolean!
  isCancellable: Boolean!
  isRecursive: Boolean!
  # isAlreadyRatad
  isAlreadyRatad: Boolean!
  isExpired: Boolean!
  # for detail page only, dont access in the listing
  isOrdered: Boolean!
  alreadyCommented: Boolean!
  canComment: Boolean!
  qrCode: String
}

type GymClassOpening {
  isOpen: Boolean!
  startTime: String
  endTime: String
  openDuration: Int
  operatingTime: TimeRange
  operatingTimeStr: String
  instructor: ExternalInstructor_VP
}

type GymClassPref {
  distance: Float
  distanceInKm: Float
  price: Float
  availableDate: String
  categories: [ID!]
}

enum GymClassPricingType {
  SINGLE
  MULTIPLE
}

type GymClassRecentMemberPhotos {
  customerId: ID!
  photo: String!
}

type GymClassSchedule {
  day: Int!
  openTime: String!
  duration: Int!
}

type GymClassScheduleGroup {
  id: ID!
  gymClassId: ID!
  status: GlobalStatusType!
  startDate: Date!
  endDate: Date!
  duration: Float
  difficultyLevel: DifficultyLevel
  age: Age
  spots: Int
  isPrivate: Boolean
  gender: GlobalGenderType
  estimatedCaloriesBurnt: String
  dropInClient: Boolean
  gymMemberClient: Boolean
  dropInClientPrice: CurrencyValue
  gymMemberClientPrice: CurrencyValue
  externalId: String
  sentNotification: Boolean
  code: ID!
  qrCodeUpdatedAt: Datetime
  gymClassMembershipPrices: [ClassMembershipPrices]
  schedule: [GymClassWeeklyScheduleV2!]
  createdAt: Datetime
  updatedAt: Datetime
}

input GymClassScheduleGroupInput {
  id: ID
  gymClassId: ID
  externalGymClassId: String
  gymId: String
  status: GlobalStatusType!
  startDate: Date!
  endDate: Date!
  duration: Float!
  difficultyLevel: DifficultyLevel!
  age: AgeInput
  spots: Int
  gender: GlobalGenderType
  isPrivate: Boolean!
  estimatedCaloriesBurnt: String
  dropInClient: Boolean!
  gymMemberClient: Boolean!
  dropInClientPrice: CurrencyValue!
  gymMemberClientPrice: CurrencyValue
  pricingType: GymClassPricingType
  sentNotification: Boolean
  externalId: String
  classMembershipPrices: [ClassMembershipPricesInput]
  schedule: [GymClassScheduleInput!]
}

type GymClassScheduleGroupList {
  id: ID!
  gymClassId: ID!
  gymClassName: String!
  status: GlobalStatusType!
  startDate: Date!
  endDate: Date!
  duration: Float
  code: ID!
  qrCodeUpdatedAt: Datetime
  instructors: String!
  schedule: String!
  createdAt: Datetime
  updatedAt: Datetime
}

type GymClassScheduleGroupPayload {
  gymClassScheduleGroup: GymClassScheduleGroup
  error: GymClassError
  errorMessage: String
  errors: [GymClassError!]
}

input GymClassScheduleInput {
  id: ID
  day: Int!
  openTime: LocalTime!
  duration: Float!
  difficultyLevel: DifficultyLevel!
  gender: GlobalGenderType
  age: AgeInput
  spots: Int!
  closeAllDay: Boolean
  instructorIds: [ID!]!
  isPrivate: Boolean
  gymStudioId: ID
  externalId: String
}

input GymClassScheduleItemInput {
  scheduleGroupId: ID!
  scheduleId: ID!
  modifiedDate: Date!
  modifiedTime: LocalTime!
  oldDate: Date!
  oldTime: LocalTime!
  duration: Float!
  spots: Int!
  gymStudioId: ID!
  difficultyLevel: DifficultyLevel!
  instructorIds: [ID!]
}

type GymClassScheduleItemPayload {
  success: Boolean
  error: GymClassError
  errorMessage: String
  errors: [GymClassError!]
}

enum GymClassStatus {
  ACTIVE
  INACTIVE
  CANCELED
  FAILED
}

enum GymClassStatus_Orders {
  ACTIVE
  INACTIVE
  CANCELED
  FAILED
}

enum GymClassType {
  ONSITE
  ONLINE
  ANY
}

type GymClassV2 {
  id: ID!
  name: String!
  description: String
  countryId: ID
  gymClassCategoryIds: [ID!]!
  categories: String
  gymId: ID!
  brandId: ID
  images: [String!]
  status: GlobalStatusType
  age: Age
  classType: GymClassType
  onlineLink: String
  equipment: String
  equipmentLink: String
  externalId: String
}

type GymClassWeeklySchedule {
  id: ID!
  day: Int!
  openTime: LocalTime
  duration: Float!
  closeAllDay: Boolean
  instructorIds: [ID!]
  difficultyLevel: DifficultyLevel!
  gender: GlobalGenderType!
  age: Age
  spots: Int!
  instructor: ExternalInstructor_VP
  gymStudioId: ID!
  isPrivate: Boolean
  createdAt: Datetime!
  updatedAt: Datetime!
}

type GymClassWeeklyScheduleV2 {
  id: ID!
  day: Int!
  openTime: LocalTime
  duration: Float!
  closeAllDay: Boolean
  instructorIds: [ID!]
  difficultyLevel: DifficultyLevel!
  gender: GlobalGenderType!
  age: Age
  spots: Int!
  gymStudioId: ID!
  isPrivate: Boolean
  createdAt: Datetime!
  updatedAt: Datetime!
}

type GymDetailMobileView {
  id: ID!
  name: String!
  brandName: String!
  description: String
  email: String!
  images: [String!]!
  legalName: String!
  phone: String!
  status: String!
  amenities: [String!]
  distance: Float
  feetDistance: Int
  memberCount: Int!
  recentMemberPhotos: [GymRecentMemberPhotos!]
  isFavourite: Boolean
  isOpen: Boolean
  startTime: LocalTime
  endTime: LocalTime
  operatingTimeStr: String
  distanceInKm: Float
  ratingScore: Float!
  longitude: Float
  latitude: Float
  rules: [RulesPayload!]
  rulesDescription: String
  termsAndConditions: String
  socialMediaReferences: [VSocialMediaReference!]
  shortAddress: String
  fullAddress: String
  freeTrial: Boolean
  trialForDays: Int
  trialSalientFeatures: [String!]
  trialRangeStartTime: LocalTime
  trialRangeEndTime: LocalTime
  trailSlotDivider: Int
  trailDisclaimer: String
  vatRegistrationNumber: String
}

input GymDetailMobileViewParams {
  # User's current location
  location: GISLocationInput!
  timeZoneIdentifier: String!
}

type GymDevice {
  id: ID!
  gymId: ID!
  deviceId: String
  createdBy: Admin
  lastUpdatedBy: Admin
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum GymDeviceDirection {
  ENTRY
  EXIT
}

enum GymDeviceError {
  GYM_NOT_FOUND
  DEVICE_ALREADY_EXIST
  NOT_ALLOWED
  INVALID_INPUT
  DEVICE_NOT_FOUND
}

type GymDevicesPayload {
  list: [GymDevice!]
  paging: PaginatorOutputUpdated
}

enum GymError {
  DUPLICATE_NAME
  INVALID_ID
  ADMIN_ALREADY_EXISTS
  INVALID_PHONE
  NOT_ALLOWED
  TRIAL_DAYS_INVALID
  TRAIL_TIME_RANGE_REQUIRED
  SALIENT_FEATURES_REQUIRED
  TRIAL_DAYS_AVAILABLE_REQUIRED
  EXCEPTION
  SUBSCRIPTION_TYPE_SAME
  INVALID_PAYMENT_GATEWAY_DETAILS
}

type GymOpening {
  isOpen: Boolean!
  startTime: String
  endTime: String
  openDuration: Int
  operatingTime: TimeRange
  operatingTimeStr: String
}

# Gym Operating Hourly Prices
type GymOperatingHourlyPrices {
  id: ID!
  startTime: LocalTime!
  startTimeLabel: String!
  endTime: LocalTime!
  endTimeLabel: String!
  notAvailable: Boolean!
  message: String
  compareAtPrice: CurrencyValue
  compareAtPriceLabel: String
  price: CurrencyValue!
  priceLabel: String!
  createdBy: Admin!
  lastUpdatedBy: Admin!
  createdAt: Datetime!
  updatedAt: Datetime!
  highlightType: HighlightType
  currencySymbol: String!
  currencyIsoCode: String!
  isLowestPrice: Boolean!
  priceMinutely: CurrencyValue!
  priceMinutelyLabel: String!
  minAndHoursLabel: String!
  intervalLabel: String!
}

enum GymOperatingHourlyPricesError {
  DUPLICATE_DAY
  INVALID_ID
  INVALID_GYM
  INVALID_GYM_OPERATING_HOUR
  INVALID_DAY
  INVALID_TIME
  INVALID_INPUT
  MISSING_TIMES
  INTERSECTION_TIMES
}

# Gym Operating Hours
type GymOperatingHours {
  id: ID!
  day: Int!
  openTime: LocalTime
  openDuration: Int
  openAllDay: Boolean!
  closeAllDay: Boolean!
  dailyPrice: Int
  compareAtDailyPrice: Int
  createdBy: Admin!
  lastUpdatedBy: Admin!
  createdAt: Datetime!
  updatedAt: Datetime!
  hourlyPrices: [GymOperatingHourlyPrices]
}

enum GymOperatingHoursError {
  DUPLICATE_DAY
  INVALID_ID
  INVALID_GYM
  INVALID_DAY
  NOT_ALLOWED
  HOURLY_PRICE_RANGE_OUT
  HOURLY_PRICE_WRONG_TIME
  HOURLY_PRICE_NO_NOT_AVAILABLE_MSG
  HOURLY_PRICE_WRONG_COMPARE_AT_PRICE
  HOURLY_PRICE_INTERSECTION_TIMES
}

enum GymPaymentGateway {
  CHECKOUT
  TAP
  STRIPE
  NONE_OF_THEM
}

type GymPaymentGatewayDetail {
  id: ID!
  name: String!
  isPaymentGatewayEnabled: Boolean!
  paymentProvider: GymPaymentGateway!
  tapMerchantId: String!
  masterMerchantId: String!
  tapSecretKey: String!
  tapPublicKey: String!
  tapAndroidAppSecretKey: String!
  tapIosAppSecretKey: String!
  tapAppPublicKey: String!
}

type GymPref {
  distance: Float
  distanceInKm: Float
  isOpen: Boolean
}

input GymPriceFilter {
  minPrice: Float
  maxPrice: Float
}

# GymQrCodes
type GymQrCode {
  id: ID!
  gym: Gym!
  code: String!
  forDate: String!
  createdBy: Admin!
  lastUpdatedBy: Admin!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum GymQrCodeError {
  INVALID_ID
  INVALID_GYM
  ALREADY_ADDED_FOR_TODAY
  NOT_ALLOWED
}

type GymQrReview {
  id: ID
  customerId: ID!
  description: String
  rating: RatingType
  consentStatus: ConsentStatusEnum!
  workedBodyParts: [WorkedBodyPart!]
  qrSession: QrSession!
  gym: Gym!
  createdAt: Datetime!
  comment: Comment
}

enum GymQrReviewError {
  INVALID_SESSION
  UNAUTHORIZED_SESSION
  DUPLICATE_REVIEW
  TX_ERROR
}

input GymQrReviewsFilter {
  searchText: String
  status: ConsentStatusEnum
  gymId: ID
  qrSessionId: ID
  customerId: ID
}

type GymQrReviewsPayload {
  summary: GymQrReviewSummary
  list: [GymQrReview!]
  paging: PaginatorOutput
}

type GymQrReviewSummary {
  ratingLabel: AverageRatingType!
  totalReviewCount: String!
}

type GymQrSession {
  id: ID!
  title: String!
  type: gqlGymQrSessionType!
  createdAt: String!
  updatedAt: String!
}

type GymQrSessionCount {
  count: Int
}

type GymQrSessions {
  gymQrSessions: [GymQrSession]
}

type GymRecentMemberPhotos {
  customerId: ID!
  photo: String!
}

input GymsFilter {
  searchText: String
  status: GymStatus
  gymId: ID
  countryId: ID
  brandId: ID
  price: GymPriceFilter
  openGyms: Boolean
  requiredAmenities: [String]
  workoutMachines: [String]
  subscriptionType: SubscriptionTypes
}

input GymsInRadiusFilter {
  # User's current location
  location: GISLocationInput!
  brandIds: [ID!]
  timeZoneIdentifier: String
  countryId: ID!
  searchText: String
  gymPref: CustomerGymDrfaultPrefInput!
  filterType: String
}

input GymsListFilter {
  searchText: String
  status: GymStatus
  gymId: ID
  countryId: ID
  brandId: ID
  price: GymPriceFilter
  openGyms: Boolean
  requiredAmenities: [String]
  workoutMachines: [String]
  subscriptionType: SubscriptionTypes
  appId: String
}

type GymsPayload {
  list: [Gym!]
  paging: PaginatorOutputUpdated
}

enum GymStatus {
  ACTIVE
  TEMP_CLOSED
  COMING_SOON
  INACTIVE
}

# GymStudio
type GymStudio {
  id: ID!
  gymId: ID
  name: String!
  status: GlobalStatusType!
  spots: Int!
}

enum GymStudioError {
  DUPLICATE_NAME
  INVALID_ID
  NOT_ALLOWED
}

input GymStudioFilter {
  searchText: String
  status: GlobalStatusType
  gymId: ID
}

type GymStudioPayload {
  list: [GymStudio!]
  paging: PaginatorOutputUpdated
}

type GymVideosWithCategories {
  videoTypeId: ID!
  videoTypeName: String!
  videos: [VideoListView!]
}

type HasMembership {
  member: Boolean
}

input HasMembershipQueryArgs {
  gymId: ID!
  customerId: ID!
  forDate: String!
}

type HasMembershipQueryResponse {
  data: HasMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type HasMemberships {
  memberships: [HasMemberShipsType]
}

input HasMembershipsQueryArgs {
  gymId: ID!
  customerId: [ID!]
  forDate: String!
}

type HasMembershipsQueryResponse {
  data: HasMemberships
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type HasMemberShipsType {
  customerId: ID!
  member: Boolean!
  membershipName: String
}

enum HighlightType {
  SPECIAL_HOURS
  OFF_PEAK_RATE
}

input HomeFeedFilters {
  countryId: ID!
  # User's current location
  location: GISLocationInput!
}

type HomeFeedPayload {
  countryId: ID!
  location: GISLocationType!
  gyms: [Gym!]
  instructors: [tNode!]
  videos: [Video!]
}

type HomeScreen {
  id: ID
  homescreen: [HomeScreenDetail]!
  countryId: ID!
}

type HomeScreenDetail {
  tileType: String!
  title: String
  subTitle: String
  contentType: String!
  filterType: String
  items: [ItemDetail]
}

input HomeScreenDetailInput {
  tileType: String!
  title: String
  subTitle: String
  contentType: String!
  filterType: String
  items: [ItemDetailInput]
}

enum HomeScreenError {
  INVALID_ID
  HOMESCREEN_ALREADY_EXIST
  INVALID_COUNTRY_ID
  PT_NOT_FOUND
  GYM_CLASS_NOT_FOUND
  COURT_NOT_FOUND
  GYM_NOT_FOUND
  EVENT_NOT_FOUND
}

input HomeScreenInput {
  id: ID
  homescreen: [HomeScreenDetailInput!]!
  countryId: ID!
}

type IGetDailySalesReportResponse {
  srNo: Int
  date: String
  clientName: String
  mobileNumber: String
  email: String
  membershipName: String
  salesPerson: String
  leadSource: String
  grossSale: String
  registrationFee: String
  vat: Int
  netSale: String
  paymentMethodType: String
}

type IGetDailySalesReportResponseData {
  records: [IGetDailySalesReportResponse]
  paging: PaginatorOutputUpdated
}

input ImportAdminInput {
  batchNo: String!
  csvPrefix: String!
  gymId: ID!
  adminfileUrl: String!
  empfileUrl: String!
}

type ImportAdminsPayload {
  success: Boolean
  error: AdminError
  errors: [AdminError]
  errorMessage: String
}

type ImportGymClassError {
  line: Int
  className: Int
  errorMessage: String
  errorCode: String
}

input ImportGymClassesConfigInput {
  iHeaderRow: Int
}

input ImportGymClassesInput {
  fileURL: String
  configs: ImportGymClassesConfigInput
  gymId: ID
  brandId: ID
  overrideIfExists: Boolean
}

type ImportGymClassesPayload {
  status: Boolean
  errorMessage: String
  errors: [ImportGymClassError]
}

type ImportInstructorError {
  line: Int
  className: Int
  errorMessage: String
  errorCode: String
}

input ImportInstructorsConfigInput {
  iHeaderRow: Int
}

input ImportInstructorsInput {
  fileURL: String
  configs: ImportInstructorsConfigInput
  gymId: ID
  brandId: ID
  overrideIfExists: Boolean
}

type ImportInstructorsPayload {
  status: Boolean
  errorMessage: String
  errors: [ImportInstructorError]
}

input ImportLeadsInput {
  batchNo: String!
  csvPrefix: String!
  gymId: ID!
  fileUrl: String!
}

type ImportLeadsPayload {
  success: Boolean
  error: LeadError
  errors: [LeadError]
  errorMessage: String
}

type IndividualNotification {
  id: ID!
  title: String
  description: String
  createdAt: Date!
  createdById: ID!
  createdByName: String
  leadId: ID!
}

type IndividualNotificationsPayload {
  list: [IndividualNotification]
  paging: PaginatorOutput
}

type InfoQrSession {
  shortCode: String!
  activeHoursLabel: String!
  details: [QrSessionPeriodList!]
  totalMinutelyDuration: PassingTime!
  totalMinutelyDurationLabel: String!
  currencySymbol: String!
  currencyIsoCode: String!
  totalMinutelyPrice: CurrencyValue!
  totalMinutelyPriceLabel: String!
  totalCalories: String!
}

type InfoQrSessionPayload {
  gym: Gym
  qrSession: QrSession
  summary: InfoQrSession
  error: QrSessionError
  errors: [QrSessionError!]
  errorMessage: String
}

enum InitialLeadStatus {
  HOT
  COLD
}

input InjectCountriesDataInput {
  filteredCountries: [String]
}

type InjectCountriesDataPayload {
  status: Boolean
  error: String
  errorMessage: String
}

enum InstallmentFrequencyTypeEnum {
  daily
  weekly
  fortnightly
  monthly
  quarterly
  biannually
  annually
}

# Instructor/Users.
type Instructor {
  id: ID
  firstName: String!
  lastName: String
  description: String
  email: String!
  contactNumber: String
  brandId: ID!
  gymId: ID!
  gymName: String
  isFavourite: Boolean
  isOnline: Boolean
  isFreelancer: Boolean
  certifications: [String!]
  ratingScore: Float!
  dob: Date
  gym: ExternalGym_Instructor
  countryId: ID!
  currencyCode: String
  country: InstructorCountry_Common!
  perSessionAmount: CurrencyValue!
  perSessionAmountLabel: String!
  photo: String
  coverPhoto: String
  gender: GlobalGenderType
  authId: String
  services: [ID!]
  totalBookings: Int!
  noOfPeopleBooked: Int!
  noOfReviews: Int!
  serviceDetails: [Service!]
  lowestServiceCost: CurrencyValue
  unBookedSlots: UnBookedSlotsPayload
  status: GlobalStatusType!
  socialMediaReferences: [SocialMediaReference!]
  privateCoach: Boolean!
  # The longitude component of the geo coordinates for this instructor
  geoLocation: InstructorGeoLocation
  serviceRange: Float!
  sessions: [InstructorSession!]
  specialities: [InstructorSpeciality!]
  createdAt: Datetime!
  updatedAt: Datetime!
  distance: Float
}

input InstructorAllReviewsFilter {
  instructorId: ID!
  status: String!
}

type InstructorBookedSessionPayload {
  list: [OrderPrivateCoachSession!]
}

type InstructorComment {
  id: ID
  instructorId: ID!
  customerId: ID!
  description: String
  rating: [RatingTypes!]
  ratingScore: Float!
  status: CommentStatus!
  createdAt: Datetime
  customer: InstructorCustomer
}

enum InstructorCommentError {
  INVALID_REVIEW
  UNAUTHORIZED
  DUPLICATE_COMMENT
  COMMENT_NOT_FOUND
  TX_ERROR
  INVALID_ID
}

input InstructorCommentsFilter {
  instructorId: ID!
  customerId: ID
  status: String!
}

type InstructorCommentsPayload {
  list: [InstructorComment!]
  total: totalPayload
  paging: PaginatorOutput
}

type InstructorCountry_Common {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: InstructorCurrency_Common!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type InstructorCurrency_Common {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

type InstructorCustomer {
  id: ID!
  firstName: String
  lastName: String
  fullName: String
  photo: String
  contactNumber: String
  email: String
}

enum InstructorError {
  DUPLICATE_EMAIL
  INVALID_ID
  DUPLICATE_CONTACT_NUMBER
  FIREBASE
  FIELD_REQUIRED
  INVALID_FIELD_DATA
  INVALID_INSTRUCTOR
  SESSION_REQUIRED
  SPECIALTY_REQUIRED
  SERVICE_REQUIRED
  INVALID_SESSION
  INVALID_INSTRUCTOR_ID
  INSTRUCTOR_NOT_ACTIVE
  SESSION_NOT_AVAILABLE
  DIFFERENT_COUNTRY
  DUPLICATE_SESSION_TIME
  NOT_A_PRIVATE_COACH
  INVALID_CONTACT_NUMBER
  NEW_PASSWORDS_NOT_SAME
  INTERNAL_SERVER_ERROR
  NOT_ALLOWED
  DUPLICATE_NAME
}

type InstructorFavourite {
  id: ID
  instructorId: ID!
  customerId: ID!
  isFavourite: String
  createdAt: Datetime
}

type InstructorFavouriteByInstructorPayload {
  success: Boolean!
  error: InstructorError
  errors: [InstructorError!]
}

enum InstructorFavouriteErrors {
  TX_ERROR
  CUSTOMER_NOT_AUTHORISED
}

type InstructorFavouriteInstructorsPayload {
  list: [Instructor!]
}

type InstructorFavouritePayload {
  success: Boolean
  error: InstructorFavouriteErrors
  errors: [InstructorFavouriteErrors!]
}

# InstructorGallery
type InstructorGallery {
  id: ID!
  url: String!
  mediaType: MediaType!
  srcId: String
  thumbnail: String
  instructorId: ID!
  status: GlobalStatusType!
  categoryId: ID!
  categoryName: String!
  createdById: ID!
  lastUpdatedById: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

input InstructorGalleryByCategoryParams {
  instructorId: ID!
}

type InstructorGalleryCategories {
  id: ID!
  name: String!
  icon: String
  subtitle: String
}

input InstructorGalleryCategoriesFilter {
  instructorId: ID!
  limit: Int!
}

type InstructorGalleryCategoriesPayload {
  list: [InstructorGalleryCategories!]
}

enum InstructorGalleryError {
  INVALID_ID
  INVALID_INSTRUCTOR_ID
  NOT_ALLOWED
}

type InstructorGalleryNyCategoryPayload {
  list: [InstructorGallerysPayloadNode!]
  paging: PaginatorOutput
}

input InstructorGallerysFilter {
  searchText: String
  status: GlobalStatusType
  categoryId: ID
  instructorId: ID
}

type InstructorGallerysPayload {
  list: [InstructorGallery!]
  paging: PaginatorOutput
}

type InstructorGallerysPayloadNode {
  categoryName: String!
  image: String
  count: Int!
  mediaType: MediaType!
  dataSet: [InstructorGallery!]
}

type InstructorGeoLocation {
  type: String
  coordinates: [Float]
}

type InstructorLead {
  id: ID!
  firstName: String!
  lastName: String!
  fullName: String!
  customerCode: String
  photo: String
}

type InstructorLight {
  id: ID
  firstName: String!
  lastName: String
  description: String
  photo: String
  coverPhoto: String
  distance: Float
  distanceInKm: Float
  serviceRange: Float!
  perSessionAmount: CurrencyValue!
  gymName: String
  totalBookings: Int!
  isOnline: Boolean
  certifications: [String!]
  ratingScore: Float!
  lowestServiceCost: CurrencyValue
  # The longitude component of the geo coordinates for this instructor
  longitude: Float
  latitude: Float
  isFavourite: Boolean!
  currencyName: String!
  currencyCode: String!
  currencySymbol: String!
}

type InstructorLightPayload {
  list: [InstructorLight!]
  paging: PaginatorOutput
}

type InstructorListOfClients {
  list: [InstructorCustomer!]
  paging: PaginatorOutput
}

type InstructorOnlinePayload {
  success: Boolean!
  error: InstructorError
  errors: [InstructorError!]
}

input InstructorParams {
  customerId: ID!
  serviceId: ID!
  gymId: ID
}

input InstructorPaymentMethodInput {
  paymentScheme: PTPaymentScheme!
  name: String!
  imageUrl: String
  subText: String
  sourceId: String
}

# InstructorSession
type InstructorSession {
  id: ID!
  instructorId: ID!
  day: Int!
  dayName: String!
  openTime: LocalTime!
  openTimeLabel: String!
  openDuration: Int!
  closeTime: LocalTime!
  closeTimeLabel: String!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum InstructorSessionErrors {
  INVALID_ID
  INVALID_INSTRUCTOR
  INVALID_DAY
}

enum InstructorSessionEventType {
  STARTED
  STOPPED
  CANCELED
  ENDED
  MISSED
  ACTIVE
}

input InstructorSessionInput {
  day: Int!
  openTime: LocalTime!
  duration: Float!
}

type InstructorSessionPayload {
  list: [InstructorSession!]
}

input InstructorsFilter {
  searchText: String
  status: GlobalStatusType
  gender: GlobalGenderType
  brandId: ID
  gymId: ID
  privateCoach: Boolean
  speciality: ID
  sortBy: InstructorSortingInput
}

enum InstructorSortingBy {
  perSessionAmount
  createdAt
}

input InstructorSortingInput {
  field: InstructorSortingBy!
  order: SortingOrderType!
}

type InstructorSortingOutput {
  field: InstructorSortingBy!
  order: SortingOrderType!
}

type InstructorsPayload {
  list: [Instructor!]
  paging: PaginatorOutputUpdated
}

type InstructorSpeciality {
  id: ID!
  name: String!
  icon: String
  type: InstructorSpecialityType!
  status: GlobalStatusType!
}

enum instructorSpecialityError {
  DUPLICATE_NAME
  INVALID_ID
}

input InstructorSpecialityFilter {
  status: String
  type: InstructorSpecialityType
}

input InstructorSpecialityInput {
  id: ID
  name: String!
  icon: String
  type: InstructorSpecialityType!
  status: GlobalStatusType!
}

enum InstructorSpecialityType {
  SPECIALITY
  GALLERY_TYPE
}

enum InstructorTimeIntervalType {
  TODAY
  DAY
  WEEK
  MONTH
  YEAR
}

enum Interest {
  Tennis
  Running
  Weights
  Cardio
  Yoga
  Pilates
  Basketball
  Football
  Crossfit
  Rowing
}

enum IntervalEnum {
  single
  day
  week
  month
  year
}

input InviteABookingMobileInput {
  bookingId: ID!
}

type InviteABookingMobilePayload {
  orderCourtBookedSlot: OrderCourtBookedSlot
  error: OrderCourtBookedSlotError
  errors: [OrderCourtBookedSlotError!]
  errorMessage: String
}

type invoiceChangeMembership {
  total: Float
  currency: String
  action: String
}

input InvoiceChangeMembershipQueryInput {
  singleMembershipId: ID
  singleMembershipPlanId: ID
  groupMembershipId: ID
  groupMembershipPlanId: ID
  sessionPackId: ID
  sessionPackPlanId: ID
  paymentPlanId: ID
  customerId: ID!
}

type InvoiceChangeMembershipResponse {
  data: invoiceChangeMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type InvoiceComponent {
  type: InvoiceComponentType!
  label: String
  value: CurrencyValue
}

enum InvoiceComponentType {
  # Subtotal without discounts but after reduction the cost of items which are free
  SUBTOTAL
  # Any service fee
  SERVICE_FEE
  # VOUCHER (amount)
  VOUCHER
  # The total cost of the order after all the discounts and perks
  TOTAL
  # Same as total which is due on customer to pay minus the credits the customer have if payment method is credits
  AMOUNT_DUE
}

enum InvoicePaymentStatus {
  inactive
  success
  pending
  failure
  scheduled
  scheduled_installment
}

enum InvoiceType {
  REFUND
  CHARGE
}

type ItemDetail {
  id: String
  title: String
  subTitle: String
  image: String
  isClickable: Boolean
  actionId: String
  actionUrl: String
  actionType: String
  type: String
  lattitude: Float
  longitude: Float
  rating: Float
  price: Float
  currency: String
  isOpen: Boolean
  startTime: LocalTime
  endTime: LocalTime
  bottomStatusText: String
  maxCapacity: Int
  availableSpotsCount: Int
  totalSpotsCount: Int
  startDate: Datetime
  endDate: Datetime
  subscribers: [String]
  schedule: [Schedule]
  filterType: String
}

input ItemDetailInput {
  id: String
  title: String
  subTitle: String
  image: String
  isClickable: Boolean
  actionId: String
  actionUrl: String
  actionType: String
  type: String
  lattitude: Float
  longitude: Float
  rating: Float
  price: Float
  currency: String
  isOpen: Boolean
  startTime: LocalTime
  endTime: LocalTime
  bottomStatusText: String
  maxCapacity: Int
  availableSpotsCount: Int
  totalSpotsCount: Int
  startDate: Datetime
  endDate: Datetime
  subscribers: [String]
  schedule: [ScheduleInput]
  filterType: String
}

type Language {
  id: ID!
  name: String!
  code: String!
  status: StatusType!
  countries: [Country]!
}

input LanguageCountriessFilter {
  searchText: String
  countryId: ID
  languageId: ID
}

type LanguageCountriessPayload {
  list: [LanguageCountry]
  paging: PaginatorOutput
}

type LanguageCountry {
  id: ID!
  country: Country!
  language: Language!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum LanguageCountryError {
  DUPLICATE_PERMISSION
  INVALID_ID
}

enum LanguageError {
  DUPLICATE_NAME
  INVALID_ID
}

input LanguageFilter {
  status: String
  searchText: String
}

input LanguageInput {
  id: ID
  name: String!
  code: String!
  status: StatusType!
}

type LanguagesPayload {
  list: [Language]
  paging: PaginatorOutput
}

type LatestAction {
  description: String
  date: Date
}

# Leads
type Lead {
  id: ID!
  firstName: String!
  middleName: String
  lastName: String
  fullName: String
  description: String
  leadCreatedById: String
  leadCreatedByName: String
  dob: Date
  photo: String
  nationality: String
  source: LeadSource
  gender: CustomerGenderType
  address: String
  cityId: ID
  externalId: ID
  city: CustomerCountryCity
  membershipDetails: LeadMembershipDetails
  country: CustomerCountry
  email: String
  phoneNumber: String
  leadType: LeadType
  leadStatus: LeadStatus
  leadSubStatus: LeadSubStatus
  leadStatusUpdatedAt: Date
  latestAction: LatestAction
  workStatus: WorkStatus
  jobTitle: String
  marketingConsentSms: Boolean
  marketingConsentEmail: Boolean
  tasks: [LeadTask]
  appointments: [LeadAppointment]
  calls: [LeadCall]
  notes: [LeadNote]
  notifications: [LeadNotification]
  emails: [LeadEmail]
  contacts: [LeadContact]
  emergencyContact: LeadContact
  companyInfo: LeadCompany
  linkedAccounts: [Lead!]
  customer: Customer
  customerId: ID
  leadNo: Int
  gymId: ID
  appUser: Boolean
  parqHealth: ParqHealthType
  gfpHealth: LeadGfpHealthType
  tAndCSignatureLink: String
  gym: LeadGym
  membershipActionDate: Date
  isParent: Boolean!
  hasUniqueEmail: Boolean
  customerCode: String
  isClassBookingBlocked: Boolean
  dateOfClassBlock: Date
  dateOfLastClassUnblocked: Date
  leadReferalStatus: LeadReferalStatus
  firstSignup: Boolean
  referredById: String
  referredByName: String
  paymentStatus: LeadPaymentStatus
  createdAt: Date
}

enum LeadAccountError {
  INVALID_ID
  FIELD_REQUIRED
  INVALID_FIELD_DATA
  PHONE_SHOULD_BE_UNIQUE
  EMAIL_SHOULD_BE_UNIQUE
}

input LeadAgeInput {
  from: Int!
  to: Int!
}

# Lead Appointments
type LeadAppointment {
  id: ID!
  appointmentDate: Date!
  appointmentTime: String!
  appointmentCreatedById: ID!
  appointmentCreatedByName: String
  note: String
  outcome: AppointmentOutcome
  outcomeRescheduledDate: Date
  outcomeRescheduledTime: String
  outcomeRescheduledNote: String
  outcomeNotInterestedNote: String
  dbStatus: FollowUpStatusType
  createdById: ID!
  createdAt: Date!
  updatedAt: Date!
  lead: Lead!
  gymId: ID
  leadCallId: ID
}

type LeadAppointmentsCount {
  count: Int
}

input LeadAppointmentsFilter {
  searchText: String
  outcome: AppointmentOutcome
  dbStatus: FollowUpStatusType
  leadId: ID
  date: Date
}

type LeadAppointmentsPayload {
  list: [LeadAppointment]
  paging: PaginatorOutput
}

type LeadBrand {
  id: ID
  name: String
  email: String
  phone: String
  logo: String
  image: String
  countryId: ID
}

input leadByCustomerIdParams {
  customerId: ID!
  gymId: ID!
}

# Lead Calls
type LeadCall {
  id: ID!
  callDate: Date!
  callTime: String!
  callCreatedBy: ID!
  callCreatedByName: String
  outcome: CallOutcome
  note: String
  callConnectedStatus: CallConnectedStatus
  callUnreachedStatus: CallUnreachedStatus
  callFollowUpDate: Date
  callFollowUpTime: String
  callFollowUpBy: ID
  callFollowUpByName: String
  priority: FollowUpPriority
  callAppointmentDate: Date
  callAppointmentTime: String
  lead: Lead!
  createdAt: Date!
  updatedAt: ID!
  lastUpdatedById: ID!
  createdById: ID!
  dbStatus: FollowUpStatusType
  gymId: ID
  calledBy: ID
  calledByName: String
}

input LeadCallsFilter {
  searchText: String
  outcome: CallOutcome
  dbStatus: FollowUpStatusType
  leadId: ID
  addedToday: Boolean
  addedThisMonth: Boolean
}

type LeadCallsPayload {
  list: [LeadCall]
  paging: PaginatorOutput
}

input LeadCompaniesFilter {
  searchText: String
}

type LeadCompaniesPayload {
  list: [LeadCompany]
  paging: PaginatorOutput
}

# Lead Companies
type LeadCompany {
  id: ID!
  name: String!
  industry: CompanyIndustry!
  status: String
  address: String
  createdAt: Datetime
  updatedAt: Datetime
  leads: [Lead]
}

enum LeadCompanyError {
  INVALID_ID
  FIELD_REQUIRED
  INVALID_FIELD_DATA
  ALREADY_EXISTS
}

# Lead Contacts
type LeadContact {
  id: ID!
  phoneNumber: String!
  phoneCountryCode: String!
  lead: Lead!
}

input LeadContactsFilter {
  searchText: String
}

type LeadContactsPayload {
  list: [LeadContact]
  paging: PaginatorOutput
}

input LeadConversionDateRangeInput {
  startDate: Date
  endDate: Date
}

type LeadConversionReport {
  id: String!
  firstName: String!
  lastName: String
  fullName: String!
  leadsCreated: Int!
  leadConversions: Int!
  guestConversions: Int!
  leadCallsConnected: Int!
  leadAppointmentsBooked: Int!
  leadAppointmentsJoined: Int!
}

input LeadConversionReportInput {
  gymId: String!
  adminIds: [String!]
  roles: [String!]
  dateRange: LeadConversionDateRangeInput
}

type LeadConversionReportPayload {
  list: [LeadConversionReport]
  paging: PaginatorOutputUpdated
  message: String
  error: String
}

input LeadDateRange {
  startDate: Date
  endDate: Date
}

# Lead Emails
type LeadEmail {
  id: ID!
  subject: String!
  description: String!
  emailCreatedById: ID!
  emailCreatedByName: String
  createdById: ID!
  lastUpdatedById: ID!
  createdAt: Date!
  updatedAt: Date!
  lead: Lead!
  dbStatus: FollowUpStatusType
  gymId: ID
}

input LeadEmailsFilter {
  searchText: String
  dbStatus: FollowUpStatusType
  leadId: ID
}

type LeadEmailsPayload {
  list: [LeadEmail]
  paging: PaginatorOutput
}

enum LeadError {
  INVALID_ID
  FIELD_REQUIRED
  INVALID_FIELD_DATA
  INVALID_CUSTOMER
  ALREADY_A_MEMBER
  EMERGENCY_CONTACT_SHOULD_NOT_BE_MORE_THAN_ONE
  INVALID_TRANSACTION
  INVALID_ID_CITY
  INVALID_ID_COUNTRY
  CONTACT_SHOULD_BE_UNIQUE
  LINKED_ACCOUNT_PHONE_SHOULD_BE_UNIQUE
  LINKED_ACCOUNT_EMAIL_SHOULD_BE_UNIQUE
  CUSTOMER_CREATION_FAILED
  INTERNAL_SERVER_ERROR
  INVALID_FIELD_FORMAT
  INVALID_PHONE_NUMBER_FORMAT
  REFUSED_ACTION
  INVALID_COMPANY_ID
  INVALID_FORMAT
  INVALID_DOB
  NOT_ALLOWED
  NO_LEADS_FOUND
  NON_UNIQUE_BATCH_NO
  INVALID_FILE_EXTENSION
  FILE_NOT_FOUND
  EMPTY_FILE_CONTENT
  GYM_NOT_FOUND
  GYM_ID_REQUIRED
  PHONE_NUMBER_REQUIRED
  HAVE_CHILD
  ALREADY_PARENT
}

input LeadGfpHealthInput {
  leadId: ID!
  answers: [QAType!]!
  notes: String
}

type LeadGfpHealthPayload {
  lead: Lead
  error: LeadError
  errors: [LeadError!]
  errorMessage: String
}

type LeadGfpHealthType {
  answers: [TypeQAType!]!
  notes: String
}

type LeadGym {
  id: ID
  name: String
  email: String
  phone: String
  images: [String]
  brand: LeadBrand
}

enum LeadKPIs {
  TOTAL_LEADS
  TOTAL_APPOINTMENTS
  TOTAL_CALLS
  APPOINTMENTS_COMPLETED_THIS_MONTH
  NEWEST_LEADS_IN_LAST_7_DAYS
  TOTAL_LEADS_THIS_MONTH
  CALLS_COMPLETED
  APPOINTMENTS_BOOKED_THIS_MONTH
  COLD_LEADS
  HOT_LEADS
  CONVERSION_TO_MEMBERS_THIS_MONTH
  CONVERSION_TO_TRIALS
  BIRTHDAY_TODAY
  SOFT_DELETED_LEADS
}

type LeadMembership {
  id: ID
  type: String
  name: String
  price: Float
  currency: String
  membershipPlanId: ID
  salesBy: ID
  startDate: String
  endDate: String
}

type LeadMembershipDetails {
  id: ID
  status: String
  startDate: Date
  endDate: Date
  isRecurring: Boolean
  gymName: String
  membershipType: String
  membershipId: String
  membershipCode: String
}

input LeadMembershipQueryArgs {
  gymId: ID!
  customerId: ID!
}

type LeadMembershipQueryResponse {
  data: LeadMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

# Lead Notes
type LeadNote {
  id: ID!
  note: String!
  noteCreatedById: ID!
  noteCreatedByName: String
  createdById: ID!
  lastUpdatedById: ID!
  lastUpdatedByName: String
  createdAt: Date!
  updatedAt: Date!
  lead: Lead!
  dbStatus: FollowUpStatusType
  gymId: ID
}

input LeadNotesFilter {
  searchText: String
  dbStatus: FollowUpStatusType
  leadId: ID
}

type LeadNotesPayload {
  list: [LeadNote]
  paging: PaginatorOutput
}

# Lead Notifications
type LeadNotification {
  id: ID!
  title: String
  description: String!
  notificationCreatedById: ID!
  notificationCreatedByName: String
  createdById: ID!
  lastUpdatedById: ID!
  createdAt: Date!
  updatedAt: Date!
  lead: Lead!
  dbStatus: FollowUpStatusType
  viewed: Boolean!
  gymId: ID
}

input LeadNotificationsFilter {
  searchText: String
  dbStatus: FollowUpStatusType
  leadId: ID
  customerId: ID
  viewed: Boolean
}

type LeadNotificationsPayload {
  list: [LeadNotification]
  paging: PaginatorOutput
}

input LeadParqHealthInput {
  leadId: ID!
  answers: [ParqHealthQuestions!]!
  notes: String
  signatureLink: String!
}

type LeadParqHealthPayload {
  lead: Lead
  error: LeadError
  errors: [LeadError!]
  errorMessage: String
}

enum LeadPaymentStatus {
  PENDING_PAYMENT
  PAID
}

input LeadPhotoInput {
  id: ID!
  photo: String!
}

enum LeadReferalStatus {
  PENDING
  APPROVED
  REJECTED
  SIGNUP
  MEMBER
}

# Lead Sales Trainer Assignment
type LeadSalesTrainer {
  id: ID!
  salesId: ID
  trainerId: ID
  gymId: ID!
  leadId: ID!
}

enum LeadSalesTrainerError {
  INVALID_ID
  INVALID_ID_FORMAT
  INTERNAL_SERVER_ERROR
  INVALID_LEAD_ID
  EMPTY_SALES_TRAINER_FIELDS
  REQUIRED_FIELD
}

type leadSearchPerPhonePayload {
  status: LeadSearchResult
  lead: AllupProLead
  errors: [LeadError]
  error: LeadError
  errorMessage: String
}

enum LeadSearchResult {
  FOUND
  CREATED
  TO_BE_CREATED
  UNACCESSIBLE
  NOT_FOUND
}

input LeadsFilter {
  searchText: String
  type: LeadType
  gymId: ID
  status: LeadStatus
}

enum LeadSource {
  FACEBOOK
  LINKEDIN
  INSTAGRAM
  YOUTUBE
  GOOGLE_ADS
  WEBSITE
  LANDING_PAGE
  EXTERIOR_SIGNAGE
  EMAIL
  REFERRAL
  FLYER
  CORPORATE
  SMS
  SOCIAL_APP
  POS_REFERRAL
  FREE_PASS
  EVENT
  TV
  INSTAGRAM_ORGANIC
  FACEBOOK_ORGANIC
  OUTREACH
  APP
}

type LeadsPayload {
  list: [Lead]
  paging: PaginatorOutputUpdated
}

type LeadsPayloadV2 {
  list: [LeadV3]
  totalLeads: String
  totalAppointments: String
  totalCalls: String
  appointmentCompletedThisMonth: String
  newestLeads: String
  totalLeadsThisMonth: String
  callsCompleted: String
  appointmentsBookedThisMonth: String
  coldLeads: String
  hotLeads: String
  conversionToMembersThisMonth: String
  conversionToTrials: String
  birthdayToday: String
  softDeletedLeads: String
  paging: PaginatorOutputUpdated
  downloadUrl: String
}

enum LeadStatus {
  HOT
  COLD
  TRIAL
  FREE_TRIAL_EXPIRED
  EXPIRED
  NEW_MEMBER
  NEW_MEMBER_FUTURE
  RENEWED_MEMBER
  RENEWED_MEMBER_FUTURE
  MEMBER
  CANCELLED
  TERMINATED
  FUTURE_MEMBER
  REFERAL
  PENDING_SUBSCRIPTION_RETRY
  PENDING_SUBSCRIPTION_FAILED
}

input LeadSubCustomersFilters {
  parentCustomerId: ID!
}

enum LeadSubStatus {
  FROZEN
  CHANGED
  SUSPENDED
  EXTENDED
  EXPIRED_BY_TRANSFERRING
  EXPIRED_BY_RELOCATING
}

type LeadTask {
  id: ID!
  title: String!
  description: String!
  notes: String
  status: TaskStatus!
  dbStatus: FollowUpStatusType
  priority: FollowUpPriority
  startDate: Date!
  endDate: Date!
  createdAt: Date!
  updatedAt: ID!
  assigneeId: ID!
  assigneeName: String
  lastUpdatedById: ID!
  createdById: ID!
  taskCreatedById: ID
  taskCreatedByName: String
  lead: Lead!
}

input LeadTasksFilter {
  searchText: String
  status: TaskStatus
  dbStatus: FollowUpStatusType
  leadId: ID
  priority: FollowUpPriority
}

type LeadTasksPayload {
  list: [LeadTask]
  paging: PaginatorOutput
}

# Lead Timeline
type LeadTimeline {
  id: ID!
  leadId: ID!
  lead: Lead
  type: LeadTimelineType
  gymId: ID!
  callDetails: String
  taskDetails: String
  appointmentDetails: String
  noteDetails: String
  emailDetails: String
  notificationDetails: String
  leadDetails: String
  membershipDetails: String
  classBookingDetails: String
  serviceContractDetails: String
  posPurchaseDetails: String
  trialDetails: String
  createdBy: ID
  createdByName: String
  createdAt: Date
}

input LeadTimelinesFilter {
  gymId: String
  leadId: String
}

type LeadTimelinesPayload {
  list: [LeadTimeline]
  paging: PaginatorOutputUpdated
}

enum LeadTimelineType {
  CALL
  CALL_MODIFICATION
  TASK
  TASK_MODIFICATION
  APPOINTMENT
  APPOINTMENT_MODIFICATION
  NOTE
  NOTE_MODIFICATION
  EMAIL
  EMAIL_MODIFICATION
  NOTIFICATION
  NOTIFICATION_MODIFICATION
  LEAD_CREATION
  LEAD_MODIFICATION
  LEAD_CONVERT_TO_PARENT
  LEAD_CONVERT_TO_CHILD
  MEMBERSHIP_PURCHASE
  MEMBERSHIP_PURCHASE_SPLIT_PAYMENT
  TRIAL_PURCHASE
  SERVICE_CONTRACT_BOOKING
  PT_CONTRACT_PURCHASE
  PT_CONTRACT_EDIT
  CLASS_BOOKING
  CLASS_CANCELLATION
  CLASS_ATTENDANCE
  MEMBERSHIP_TERMINATED
  MEMBERSHIP_CANCELLED
  MEMBERSHIP_TRANSFERRED
  MEMBERSHIP_EXTENDED
  MEMBERSHIP_CHANGED
  MEMBERSHIP_FREEZE
  MEMBERSHIP_UNFREEZE
  ORDER_TRIAL_CANCELLED
  FREE_TRIAL_EXPIRED
  POS_PURCHASE
  SELLER_DETAILS_UPDATED
  MEMBERSHIP_UPDATED
  PHONE_NUMBER_UPDATED
}

enum LeadType {
  TELEPHONE_INQUIRY
  MARKETING
  SELF_GENERATED
  WALK_IN
}

type LeadV2 {
  id: ID!
  customerId: ID!
  firstName: String!
  middleName: String
  lastName: String
  fullName: String
  phoneNumber: String
  membership: String
  customerCode: String
  membershipEndDate: Date
  membershipStatus: String
  source: LeadSource
  gender: CustomerGenderType
  dob: Date
  photo: String
  age: Int
  leadStatus: LeadStatus
  leadSubStatus: LeadSubStatus
  leadType: LeadType
  assignedTo: ID
  assignedToName: String
  createdAt: Date
  leadDuration: Int
  latestAction: String
  latestActionDuration: Int
  leadCreatedById: String
  leadCreatedByName: String
  customer: Customer
  isClassBookingBlocked: Boolean
  dateOfClassBlock: Date
  dateOfLastClassUnblocked: Date
  paymentStatus: LeadPaymentStatus
}

type LeadV3 {
  id: ID!
  customerId: ID!
  firstName: String!
  middleName: String
  lastName: String
  fullName: String
  phoneNumber: String
  membership: String
  customerCode: String
  membershipEndDate: Date
  membershipStatus: String
  source: LeadSource
  gender: CustomerGenderType
  dob: Date
  photo: String
  age: Int
  leadStatus: LeadStatus
  leadSubStatus: LeadSubStatus
  leadType: LeadType
  assignedTo: ID
  assignedToName: String
  createdAt: Date
  leadDuration: Int
  latestAction: String
  latestActionDuration: Int
  leadCreatedById: String
  leadCreatedByName: String
  customer: Customer
  isClassBookingBlocked: Boolean
  dateOfClassBlock: Date
  dateOfLastClassUnblocked: Date
  paymentStatus: LeadPaymentStatus
}

input LikeAnEventInput {
  eventId: ID!
}

type LikeEvent {
  data: EventLike
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

# Lead LinkedAccounts
type LinkedAccount {
  id: ID!
  firstName: String!
  lastName: String!
  gender: CustomerGenderType
  dob: Date
  email: String
  phoneNumber: String
  photo: String
  hasUniqueEmail: Boolean!
  lead: Lead!
  customer: Customer
}

input LinkedAccountsFilter {
  searchText: String
}

type LinkedAccountsPayload {
  list: [LinkedAccount]
  paging: PaginatorOutput
}

type ListMessagesPerUserPayload {
  list: [UserNotificationMessage]
  paging: PaginatorOutput
  error: FollowUpError
  errors: [FollowUpError]
  errorMessage: String
}

type liveMembersReport {
  monthSeries: [monthSeriesNode]
}

type liveMembersReportQueryResponse {
  data: liveMembersReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

# An 24-hour time expressed as an hour/minute pair in local time, i.e. '18:00'
scalar LocalTime

enum LocationType {
  POINT
}

type MeasureUnit {
  id: ID!
  name: String!
  code: String!
  type: MeasureUnitType!
  status: StatusType!
}

enum MeasureUnitError {
  DUPLICATE_NAME
  INVALID_ID
}

input MeasureUnitFilter {
  status: String
  type: MeasureUnitType
  searchText: String
}

input MeasureUnitInput {
  id: ID
  name: String!
  code: String!
  type: MeasureUnitType!
  status: StatusType!
}

type MeasureUnitsPayload {
  list: [MeasureUnit]
  paging: PaginatorOutput
}

enum MeasureUnitType {
  LENGTH
  TIME
  TEMPERATURE
  LUMINOUS
  MASS
}

enum MediaType {
  IMAGE
  VIDEO
}

type Member {
  id: ID!
  customerId: ID!
  firstName: String!
  middleName: String
  lastName: String
  fullName: String
  phoneNumber: String!
  membership: String
  customerCode: String
  membershipEndDate: Date
  membershipStatus: String
  source: LeadSource
  gender: CustomerGenderType
  photo: String
  age: Int
  leadStatus: LeadStatus
  leadSubStatus: LeadSubStatus
  leadType: LeadType
  assignedTo: ID
  createdAt: Date
  memberSince: Date
  classesAttended: Int
  ptSessions: Int
  leadCreatedById: String
  leadCreatedByName: String
  customer: Customer
  isClassBookingBlocked: Boolean
  dateOfClassBlock: Date
  dateOfLastClassUnblocked: Date
  paymentStatus: LeadPaymentStatus
}

type memberActivity {
  userId: ID!
  name: String!
  customerName: String
  membershipId: String!
  startStatus: String
}

type memberActivityCsvReport {
  records: [memberActivity]
}

type memberActivityCsvReportQueryResponse {
  data: memberActivityCsvReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type memberActivityReport {
  total: Int!
  members: perfectMembersNode!
}

type memberActivityReportQueryResponse {
  data: memberActivityReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

enum MemberFlag {
  LEAD
  MEMBER
  ALL
}

enum MemberKPIs {
  ALL_MEMBERS_OF_ALL_TIMES
  ACTIVE_MEMBERS
  NEW_MEMBERS_FOR_THIS_MONTH
  RENEWED_MEMBERS_FOR_THIS_MONTH
  MEMBERS_EXPIRING_THIS_MONTH
  BIRTHDAY_TODAY
  SOLD_MEMBERS_TODAY
  APPOINTMENTS_BOOKED_THIS_MONTH
  FROZEN_MEMBERS
  RECURRING_MEMBERS
  PENDING_PAYMENT
}

type membersGymCheckIn {
  id: ID!
  userId: ID!
  gymName: String!
  name: String!
  customerName: String
  membershipCode: String
  visitDate: String!
  totalMembers: Int
}

type membersGymCheckInCsvReport {
  records: [membersGymCheckIn]
}

type membersGymCheckInCsvReportQueryResponse {
  data: membersGymCheckInCsvReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type membersGymCheckInReport {
  visits: visitsType!
  total: Int!
}

type membersGymCheckInReportQueryResponse {
  data: membersGymCheckInReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type Membership {
  id: ID!
  name: String!
  status: MembershipStatus!
  startDate: String!
  endDate: String
  membershipId: String!
  qrCode: String!
  price: Float!
  joiningFee: Float!
  currency: String
  availableSpotCount: Int
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentRecursionDuration: Int
  hasEndDate: Boolean
  recursionPeriod: MembershipPlanTypePeriod
  recursionDuration: Int
  gracePeriodDays: Int
  allowFreeze: Boolean
  freezesList: [MembershipFreezeDetails]
  owner: MembershipUser!
  members: [MembershipUser]
  admin: MembershipAdmin
  payments: [Payment]
  gyms: [MembershipGym]
  userServicePacks: [UserServicePackType]
  paymentPlan: PaymentPlan
  createdAt: String!
  updatedAt: String!
}

type MembershipActionRequest {
  id: ID!
  type: MembershipActionRequestTypeEnum!
  reason: String
  note: String
  status: MembershipActionRequestStatusEnum
  user: MembershipUser!
  responsibleAdmin: MembershipAdmin
  withinGracePeriod: Boolean
  documents: [ID]
  createdAt: String!
  updatedAt: String!
}

type membershipActionRequestByIdPayload {
  membershipActionRequest: MembershipActionRequest
  documents: [SimplifiedDocument]
}

type membershipActionRequests {
  membershipActionRequests: [MembershipActionRequest]
}

enum MembershipActionRequestStatusEnum {
  pending
  approved
  rejected
}

enum MembershipActionRequestTypeEnum {
  CANCELLATION
  RENEWAL
  EARLY_RENEWAL
  UPGRADE
  TRANSFER
  FREEZE
}

type MembershipAdmin {
  id: ID!
  firstName: String!
  lastName: String
  email: String!
  contactNumber: String
  status: String!
  type: String
  gender: String!
  authId: String!
}

type membershipAgeRange {
  ranges: membershipAgeRangeTypes!
}

type membershipAgeRangeQueryResponse {
  data: membershipAgeRange
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type membershipAgeRangeTypes {
  _above24Months: Int!
  _12To24Months: Int!
  _6To12Months: Int!
  _3To6Months: Int!
  _under3Months: Int!
  _unknown: Int!
}

type MembershipBrand {
  id: ID!
  name: String!
  status: String!
  country: MembershipCountry
}

type MembershipCancellationReasons {
  reasons: [CancellationReasonType]
  cancelSubscriptionDescription: String
  cancelSuccessDescription: String
}

input MembershipCancellationReasonsQueryFilter {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
}

type membershipCancellationReport {
  report: [membershipCancelReasonType]
  reasons: [reasonType]
}

type membershipCancellationReportQueryResponse {
  data: membershipCancellationReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type membershipCancelReasonType {
  occurings: Int!
  reason: String
  percentage: Float!
}

type membershipCountInput {
  count: Int
}

type MembershipCountResponse {
  count: membershipCountInput!
}

type MembershipCountry {
  id: ID!
  name: String!
  status: String!
  isoCode: String!
  flagPhoto: String!
  vat: Int!
  vatId: String!
  servicePhoneNumber: String!
  timeZoneIdentifier: String!
  currency: String!
}

type membershipDesciption {
  data: String!
  type: String!
}

enum MembershipDescriptionNameEnum {
  noDescriptionFound
  cancelSubscriptionScreen
  cancelSubscriptionSuccessScreen
}

enum MembershipDescriptionResponseTypeEnum {
  text
  html
}

type MembershipExtensionDetailsForAdmin {
  id: ID!
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  name: String!
  status: MembershipStatus!
  startDate: String!
  endDate: String
  membershipId: String!
  price: Float!
  currency: String
  vat: Float!
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentPlanType: PaymentTypeEnum
  isExtendedByAdmin: Boolean
  extensionReason: String
  extensionNoPeriods: Int
  extensionPeriodType: MembershipPlanTypePeriod
  extensionEndDate: String
  owner: MembershipUserSimplified!
  lead: MembershipLeadSimplified
  gym: MembershipGym!
  country: MembershipCountry!
  brand: MembershipBrand!
  createdAt: String!
  updatedAt: String!
}

type MembershipExtensionDetailsForAdminResponse {
  membershipExtension: MembershipExtensionDetailsForAdmin
}

type MembershipExtensionForAdmin {
  id: ID!
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  name: String!
  status: MembershipStatus!
  startDate: String!
  endDate: String
  membershipId: String!
  price: Float!
  currency: String
  vat: Float!
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentPlanType: PaymentTypeEnum
  isExtendedByAdmin: Boolean
  extensionReason: String
  extensionNoPeriods: Int
  extensionPeriodType: MembershipPlanTypePeriod
  extensionEndDate: String
  owner: MembershipUserSimplified!
  lead: MembershipLeadSimplified
  gym: MembershipGym!
  createdAt: String!
  updatedAt: String!
}

type MembershipExtensionsForAdmin {
  membershipExtensions: [MembershipExtensionForAdmin]
}

type MembershipFreezeDetails {
  id: ID!
  desciption: String
  isFreezePaid: Boolean
  freezePeriod: Int
  freezePeriodType: String
  freezePrice: Float
  createdBy: MembershipAdmin!
  createdAt: String!
}

type MembershipFreezeDetailsForAdmin {
  id: ID!
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  name: String!
  status: MembershipStatus!
  startDate: String!
  endDate: String
  membershipId: String!
  price: Float!
  currency: String
  vat: Float!
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentPlanType: PaymentTypeEnum
  isFrozenByAdmin: Boolean
  frozenById: String
  freezeEndDate: String
  freezeType: MembershipFreezeType
  owner: MembershipUserSimplified!
  lead: MembershipLeadSimplified
  gym: MembershipGym!
  country: MembershipCountry!
  brand: MembershipBrand!
  createdAt: String!
  updatedAt: String!
}

type MembershipFreezeDetailsForAdminResponse {
  membershipFreeze: MembershipFreezeDetailsForAdmin
}

input MembershipFreezeDetailsInput {
  id: ID
  description: String
  isFreezePaid: Boolean!
  freezePeriodType: PaymentRecursionTypeEnum
  freezePeriod: Int!
  freezePrice: Float
}

type MembershipFreezeForAdmin {
  id: ID!
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  name: String!
  status: MembershipStatus!
  startDate: String!
  endDate: String
  membershipId: String!
  price: Float!
  currency: String
  vat: Float!
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentPlanType: PaymentTypeEnum
  isFrozenByAdmin: Boolean
  frozenById: String
  freezeStartDate: String
  freezeEndDate: String
  freezeType: MembershipFreezeType
  owner: MembershipUserSimplified!
  lead: MembershipLeadSimplified
  gym: MembershipGym!
  createdAt: String!
  updatedAt: String!
}

type MembershipFreezeReasons {
  reasons: [FreezeReasonType]
}

type MembershipFreezesForAdmin {
  membershipFreezes: [MembershipFreezeForAdmin]
}

type MembershipFreezeType {
  id: ID!
  name: String!
  sessionPackPlans: [SessionPackPlan]
  singleMembershipPlans: [SingleMembershipPlan]
  groupMembershipPlans: [GroupMembershipPlan]
  status: MembershipGlobalStatusEnum!
  numberDays: Int!
  price: Float!
  currency: String
  gym: MembershipGym!
  brand: MembershipBrand!
  createdAt: String!
  updatedAt: String!
}

type MembershipFreezeTypes {
  membershipFreezeTypes: [MembershipFreezeType]
}

enum MembershipGlobalStatusEnum {
  active
  inactive
}

type MembershipGym {
  id: ID!
  name: String!
  prefix: String
  allowMembershipOnFullPayment: Boolean
  description: String
  email: String!
  images: String!
  phone: String!
  status: String!
  brandId: ID!
  qrCode: String!
  brand: MembershipBrand
  paymentProvider: String
}

input MembershipGymClassesFromAdminInput {
  customerId: ID!
  type: MembershipGymClassPeriodType!
}

input MembershipGymClassesInput {
  # User's current location
  location: GISLocationInput!
  timeZoneIdentifier: String!
  gymId: ID!
  type: MembershipGymClassPeriodType!
}

enum MembershipGymClassPeriodType {
  PREVIOUS
  TODAY
  UPCOMING
  CANCELED
}

type MembershipLeadSimplified {
  id: ID
  firstName: String
  lastName: String
  fullName: String
  email: String
  phoneNumber: String
  customerCode: String
  photo: String
}

type membershipNetGainReport {
  monthSeries: [monthSeriesNode]
}

type membershipNetGainReportQueryResponse {
  data: membershipNetGainReport
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input MembershipPagination {
  index: Int
  page: Int
  limit: Int!
}

input MembershipPaymentMethod {
  paymentScheme: String!
  name: String!
  imageUrl: String!
  subText: String!
  sourceId: String!
}

type MembershipPlanGroup {
  id: ID!
  name: String!
  gymId: String
  gym: MembershipGym
  description: String!
  sessionPackPlans: [SessionPackPlan]
  singleMembershipPlans: [SingleMembershipPlan]
  groupMembershipPlans: [GroupMembershipPlan]
  createdAt: String!
  updatedAt: String!
}

type membershipPlanGroups {
  membershipPlanGroups: [MembershipPlanGroup]
}

type membershipPlanGroupsV2 {
  membershipPlanGroups: [MembershipPlanGroup]
}

type MembershipPlans {
  singleMembershipPlans: [SingleMembershipPlan]
  groupMembershipPlans: [GroupMembershipPlan]
  sessionPackPlans: [SessionPackPlan]
}

enum MembershipPlanType {
  MEMBERSHIP
  SERVICE_CREDITS_PACCK
}

enum MembershipPlanTypePeriod {
  day
  week
  month
  year
}

enum MembershipPlanTypeStatus {
  active
  hidden
  removed
}

type MembershipResponseStatus {
  success: Boolean!
  reason: String
}

type Memberships {
  singleMemberships: [SingleMembership]
  groupMemberships: [GroupMembership]
  sessionPacks: [SessionPack]
}

enum MembershipStatus {
  pending_payment
  active
  ended
  cancelled
  frozen
  terminated
  inactive
  upcoming
  transferred
  relocated
}

type MembershipsWithFilter {
  memberships: [MembershipWithFilter]
}

type MembershipTerminateReasons {
  reasons: [TerminationReasonType]
}

enum MembershipType {
  SINGLE_MEMBERSHIP
  GROUP_MEMBERSHIP
  SESSION_PACK
}

type MembershipUser {
  id: ID!
  firstName: String!
  lastName: String
  email: String!
  contactNumber: String
  status: String!
  gender: String
  photo: String
  authId: String
  champId: String
  description: String
}

type MembershipUserSimplified {
  id: ID!
  name: String!
  email: String
  contactNumber: String
  gender: String
  photo: String
}

type MembershipWithFilter {
  id: ID!
  name: String!
  type: String!
  status: MembershipStatus!
  startDate: String!
  endDate: String
  membershipId: String!
  membershipCode: String
  membershipFee: Float
  paymentMethodId: ID!
  paymentPlanType: String
  paymentPlanName: String
  paymentRecursionType: String
  adminId: ID!
  gymId: ID!
  brandId: ID!
  countryId: ID!
  totalRecurrinngs: Int
  totalRevenue: Int
  paymentScheme: String
  countryName: String
  countryVat: Int
  brandName: String
  gymName: String
  salesBy: String
  salesByEmail: String
  userPhoto: String
  customerPhoneNumber: String
  userId: ID!
  leadName: String
  leadId: String
  lead: MembershipLeadSimplified
  customerName: String
  customerEmail: String
  createdAt: String!
  updatedAt: String!
}

type MembersPayload {
  list: [Member]
  allMembersOfAllTimes: String
  activeMembers: String
  membersExpiringThisMonth: String
  birthdayToday: String
  soldMembersToday: String
  appointmentsBookedThisMonth: String
  recurringMembers: String
  frozenMembers: String
  newMembersForThisMonth: String
  renewedMembersForThisMonth: String
  pendingPayment: String
  paging: PaginatorOutputUpdated
  downloadUrl: String
}

type membersStatuses {
  total: Float!
  statuses: membersStatusesQueryType!
}

type membersStatusesCsv {
  link: String!
}

type membersStatusesCsvQueryResponse {
  data: membersStatusesCsv
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type membersStatusesQueryResponse {
  data: membersStatuses
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type membersStatusesQueryType {
  active: memberStatusType!
  ended: memberStatusType!
  notStarted: memberStatusType!
  frozen: memberStatusType!
}

type memberStatusType {
  total: Float!
  percentage: Float!
}

type MemEnumValues {
  name: String!
}

type MemEnumValuesPayLoad {
  enumValues: [MemEnumValues]
}

type MessagePayload {
  result: Boolean
  error: FollowUpError
  errors: [FollowUpError]
  errorMessage: String
}

enum MinVersionErrors {
  INVALID_BRAND_GROUP
  INTERNAL_SERVER_ERROR
}

type MinVersionPayload {
  minVersionIOS: String
  minVersionAndroid: String
  errors: [MinVersionErrors]
  error: MinVersionErrors
  errorMessage: String
}

type MobileGymClassesPayload {
  list: [GymClassListMobile!]
  paging: PaginatorOutputUpdated
}

type MobileGymListView {
  id: ID!
  name: String!
  description: String
  email: String!
  images: [String!]!
  legalName: String!
  phone: String!
  status: String!
  amenities: [String!]
  memberCount: Int!
  recentMemberPhotos: [GymRecentMemberPhotos!]
  isFavourite: Boolean
  distance: Float
  feetDistance: Int
  isOpen: Boolean
  startTime: LocalTime
  endTime: LocalTime
  distanceInKm: Float
  ratingScore: Float!
  longitude: Float
  latitude: Float
  shortAddress: String
  freeTrial: Boolean
}

type MobileGymListViewPayload {
  list: [MobileGymListView!]
  paging: PaginatorOutput
}

type monthSeriesNode {
  date: String!
  total: Int!
}

type Mutation {
  saveProduct(input: SaveProductInput!): SaveProductPayload
  saveProductCategory(
    input: SaveProductCategoryInput!
  ): SaveProductCategoryPayload
  saveProductStock(input: SaveProductStockInput!): SaveProductStockPayload
  saveStoreImage(input: SaveStoreImageInput!): SaveStoreImagePayload
  # saveAdmin => depricated
  saveAdmin(input: SaveAdminInput!): SaveAdminPayload
  saveAdminV2(input: SaveAdminV2Input!): SaveAdminPayload
  toggleAdminStatus(input: ToggleAdminInput!): ToggleAdminPayload
  resetAdminPassword(input: ResetAdminPassInput!): ToggleAdminPayload
  saveAdminPhoto(input: SaveAdminPhotoInput!): SaveAdminPayload
  syncAdminsWithFirebase(emails: [String!]!, roles: [String!]!): Boolean
  invalidateAllRedisVendors: Boolean
  importAdmins(input: ImportAdminInput!): ImportAdminsPayload
  amenityUpsert(input: AmenityInput!): SaveAmenityPayload
  createAppId(input: CrateAppIdInput!): CreateAppIdPayload!
  updateAppIdBasicInfo(input: UpdateAppIdBasicInfoInput!): UpdateAppIdPayload!
  updateAppIdMinVersion(input: UpdateAppIdMinVersionInput!): UpdateAppIdPayload!
  updateAppIdBrands(input: UpdateAppIdBrandsInput!): UpdateAppIdBrandsPayload!
  updateAppId(input: UpdateAppIdInput!): UpdateAppIdPayload!
  saveBrand(input: SaveBrandInput!): SaveBrandPayload
  saveBrandStatusUpdate(input: SaveBrandStatusInput!): SaveBrandPayload
  triggerAllBrandsEvents: Boolean
  saveBrandAdmin(input: SaveBrandAdminInput!): SaveBrandAdminPayload
  saveBrandsAdminsTable(
    brandId: ID!
    input: [SaveBrandsAdminsTableInput]
  ): SaveBrandAdminTablePayload
  saveComment(reviewId: ID!, input: SaveCommentInput!): SaveCommentPayload
  editComment(commentId: ID!, input: SaveCommentInput!): SaveCommentPayload
  deleteComment(commentId: ID!): DeleteCommentPayload
  saveDiscount(input: SaveDiscountInput!): SaveDiscountPayload
  deleteDiscount(discountId: ID!): DeleteDiscountPayload
  favouriteGym(input: FavouriteGymInput!): FavouriteGymPd
  unFavouriteGym(input: FavouriteGymInput!): FavouriteGymPd
  saveGym(input: SaveGymInput!): SaveGymPayload
  saveGymStatusUpdate(input: SaveGymStatusInput!): SaveGymPayload
  updateGymClassBookingSettings(
    input: UpdateGymClassBookingSettingsInput!
  ): SaveGymPayload
  triggerAllGymsEvents: Boolean
  updateGymSubscription(
    gymId: ID!
    subscriptionType: SubscriptionTypes!
  ): SaveGymPayload
  updateGymPaymentGateway(
    input: UpdateGymPaymentGatewayInput!
  ): SaveGymPaymentGatewayPayload
  updateGymAccessGate(
    gymId: ID!
    accessGateVendor: GateVendorType!
    isAccessGateEnabled: Boolean!
    gateApiKey: String!
  ): SaveGymPayload
  updateGymNotifications(input: UpdateGymNotificationsInput!): SaveGymPayload
  updateGymWebsiteIntegration(
    input: UpdateGymWebsiteIntegrationInput!
  ): SaveGymPayload
  toggleGymSignupEnabled(input: toggleGymSignupEnabledInput!): SaveGymPayload
  generateWebsiteIntegrationSecretKey(
    gymId: ID!
  ): GenerateWebsiteIntegrationSecretKeyPayload
  allowMembershipOnFullPayment(
    input: UpdateAllowMembershipOnFullPayment!
  ): SaveGymPayload
  allowPTOnFullPayment(input: UpdateAllowPTOnFullPayment!): SaveGymPayload
  addGymAccessGate(input: AddGymAccessGateInput!): SaveGymAccessGatePayload
  deleteGymAccessGate(id: ID!): DeleteAccessGatePayload
  addGymAccessLevel(input: AddGymAccessLevelInput!): SaveGymAccessLevelPayload
  deleteGymAccessLevel(id: ID!): DeleteAccessLevelPayload
  saveGymAdmin(input: SaveGymAdminInput!): SaveGymAdminPayload
  saveGymsAdminsTable(
    gymId: ID!
    input: [SaveGymsAdminsTableInput]
  ): SaveGymAdminTablePayload
  saveGymBanner(input: SaveGymBannerInput!): SaveGymBannerPayload
  addGymDevice(input: AddGymDeviceInput!): SaveGymDevicePayload
  updateGymDevice(input: UpdateGymDeviceInput!): SaveGymDevicePayload
  saveGymOperatingHours(
    gymId: ID!
    brandId: ID!
    input: [SaveGymOperatingHoursInput!]!
  ): SaveGymOperatingHoursPayload
  generateGymQrCode(gymId: ID!): GenerateGymQrCodePayload
  saveGymQrReview(
    qrSessionId: ID!
    input: SaveGymQrReviewInput!
  ): SaveGymQrReviewPayload
  saveGymStudio(input: SaveGymStudioInput!): SaveGymStudioPayload
  saveOffer(input: SaveOfferInput!): SaveOfferPayload
  startQrSession(qrCode: String!): StartQrSessionPayload!
  endQrSession(qrCode: String!): InfoQrSessionPayload! @deprecated
  endCustomerQrSession(customerId: ID!, qrSessionId: ID!): InfoQrSessionPayload!
  sessionEnding(
    orderQrSession: VOrderQrSessionInput!
    paymentMethod: PaymentInput!
  ): Boolean!
  sessionFailed(
    orderQrSession: VOrderQrSessionInput!
    paymentMethod: PaymentInput!
  ): Boolean!
  addReport(input: ReportInput!): AddReportResponse
  addVideo(input: AddVideoInput!): SaveVideoPayload
  saveVideo(input: SaveVideoInput!): SaveVideoPayload
  saveVideoType(input: SaveVideoTypeInput!): SaveVideoTypePayload
  saveParentVideoType(input: SaveParentVideoTypeInput!): SaveVideoTypePayload
  workoutMachineUpsert(input: WorkoutMachineInput!): SaveWorkoutMachinePayload
  # Depricated
  attendGymClass(input: AttendGymClassInput!): AttendGymClassPayload
  # Depricated
  attendGymClassByQrCode(
    input: AttendGymClassByQrCodeInput!
  ): AttendGymClassPayload
  # Latest (to be used)
  attendBookedGymClassByQrCode(
    input: AttendBookedGymClassByQrCodeInput!
  ): AttendGymClassPayload
  attendBookedGymClassByQrCodeFromClient(
    input: AttendBookedGymClassByQrCodeInput!
  ): AttendGymClassPayload
  attendBookedGymClassByQrCodeV2(
    input: AttendBookedGymClassByQrCodeInput!
  ): AttendGymClassPayload
  attendBookedGymClassByQrCodeFromClientV2(
    input: AttendBookedGymClassByQrCodeInput!
  ): AttendGymClassPayload
  cancelAttendance(input: CancelAttendanceInput!): AttendGymClassPayload
  favouriteGymClass(input: FavouriteGymClassInput!): FavouriteGymClassPayload
  unFavouriteGymClass(input: FavouriteGymClassInput!): FavouriteGymClassPayload
  saveGymClass(input: SaveGymClassInput!): SaveGymClassPayload
  saveGymClassV2(input: SaveGymClassInputV2!): SaveGymClassPayloadV2
  saveGymClassStatus(input: SaveGymClassStatusInput!): SaveGymClassPayload
  regenerateGymClassQrCode(
    input: RegenerateGymClassQrCodeInput!
  ): SaveGymClassPayload
  importGymClasses(input: ImportGymClassesInput!): ImportGymClassesPayload
  triggerAllGymClassEvents: Boolean
  invalidateAllRedisVendorPlans: Boolean
  deleteAGymClass(input: DeleteAGymClassInput!): DeleteAGymClassPayload
  saveGymClassComment(
    input: SaveGymClassCommentInput!
  ): SaveGymClassCommentPayload
  deleteGymClassComment(id: ID!): DeleteGymClassCommentPayload
  rateGymClass(input: RateGymClassInput!): RateGymClassPayload
  saveGymClassScheduleGroup(
    input: GymClassScheduleGroupInput!
  ): GymClassScheduleGroupPayload
  regenerateGymClassQrCodeV2(id: ID!): GymClassScheduleGroupPayload
  modifyGymClassSchedule(
    input: GymClassScheduleItemInput!
  ): GymClassScheduleItemPayload
  cancelGymClassSchedule(
    input: cancelGymClassScheduleInput!
  ): GymClassScheduleItemPayload
  saveGymClassNewV2(input: SaveGymClassInputNew!): SaveGymClassNewPayloadV2
  deleteAGymClassV2(id: ID!): DeleteAGymClassPayloadV2
  saveGymClassCategory(
    input: SaveGymClassCategoryInput!
  ): SaveGymClassCategoryPayload
  buyAGymClass(input: BuyAGymClassInput!): BuyAGymClassPayload
  buyAGymClassFromAdminPlatform(
    input: BuyAGymClassFromAdminPlatformInput!
  ): BuyAGymClassPayload
  bookFromMembershipAGymClass(input: BookAGymClassInput!): BookAGymClassPayload
  bookFromMembershipAGymClassFromAdminPlatform(
    input: BookFromMembershipAGymClassFromAdminPlatformInput!
  ): BookAGymClassPayload
  cancelAGymClass(input: CancelAGymClassInput!): CancelAGymClassPayload
  cancelAGymClassFromAdmin(input: CancelAGymClassInput!): CancelAGymClassPayload
  buyAGymClassV2(input: BuyAGymClassInputV2!): BuyAGymClassPayloadV2
  buyAGymClassFromAdminPlatformV2(
    input: BuyAGymClassFromAdminPlatformInputV2!
  ): BuyAGymClassPayloadV2
  bookFromMembershipAGymClassV2(
    input: BookAGymClassInputV2!
  ): BookAGymClassPayloadV2
  bookFromMembershipAGymClassFromAdminPlatformV2(
    input: BookFromMembershipAGymClassFromAdminPlatformInputV2!
  ): BookAGymClassPayloadV2
  cancelAGymClassV2(input: CancelAGymClassInputV2!): CancelAGymClassPayload
  cancelAGymClassFromAdminV2(
    input: CancelAGymClassInputV2!
  ): CancelAGymClassPayload
  createPosBrand(input: CreatePosBrandInput!): SavePosBrandPayload
  updatePosBrand(input: UpdatePosBrandInput!): SavePosBrandPayload
  deletePosBrand(id: ID!): SavePosBrandPayload
  createPosCategory(input: CreatePosCategoryInput!): SavePosCategoryPayload
  updatePosCategory(input: UpdatePosCategoryInput!): SavePosCategoryPayload
  deletePosCategory(id: ID!): SavePosCategoryPayload
  updateAPosStoreOrderFromAdminPlatform(
    input: UpdateAPosStoreOrderFromAdminPlatformInput!
  ): UpdateAPosStoreOrderFromAdminPlatformPayload
  buyAPosStoreFromAdminPlatform(
    input: BuyAPosStoreFromAdminPlatformInput!
  ): BuyAPosStoreFromAdminPlatformPayload
  createPosProduct(input: CreatePosProductInput!): SavePosProductPayload
  updatePosProduct(input: UpdatePosProductInput!): SavePosProductPayload
  deletePosProduct(id: ID!): SavePosProductPayload
  updateProductInventory(
    input: UpdateProductInventoryInput!
  ): SavePosProductPayload
  testPass: Boolean
  cancelAGymTrialFromAdmin(id: ID!): BuyAGymTrialPayload
  cancelAGymTrialFromAdminV2(
    id: ID!
    gymId: ID!
    customerId: ID!
  ): BuyAGymTrialPayload
  expireAllTrials: Int
  # Customer mutations
  buyAGymTrial(input: BuyAGymTrialInput!): BuyAGymTrialPayload
  buyAGymTrialAdmin(input: BuyAGymTrialAdminInput!): BuyAGymTrialPayload
  cancelAGymTrial(id: ID!): BuyAGymTrialPayload
  # Allup pro mutations
  attendAGymTrial(input: AttendAGymTrialInput!): AttendAGymTrialPayload!
  # Save a customer card token from mobile
  customerCardTokenSave(
    customerCardTokenInput: CustomerCardTokenInput!
  ): CustomerCardTokenSavePayload!
  # Save a customer card token from admin
  customerCardTokenFromAdminSave(
    customerCardTokenInput: CustomerCardTokenFromAdminInput!
  ): CustomerCardTokenSavePayload!
  # Set a customer card token as default
  customerCardTokenSetDefault(id: ID!, isDefault: Boolean!): CustomerCardToken!
  customerCardTokenSetDefaultFromAdmin(
    id: ID!
    isDefault: Boolean!
    customerId: ID!
  ): CustomerCardToken!
  # delete a customer card token as default
  customerCardTokenDelete(sourceToken: String!): Boolean!
  customerCardTokenDeleteFromAdmin(
    sourceToken: String
    customerId: ID!
    id: ID
  ): Boolean!
  # Save a tap customer card token from admin
  tapSaveCustomerCardTokenFromAdmin(
    customerCardTokenInput: CustomerCardTokenFromAdminInput!
  ): CustomerCardTokenSavePayload!
  # Save a tap customer card token from mobile
  tapSaveCustomerCardToken(
    gymId: ID!
    token: String!
  ): CustomerCardTokenSavePayload!
  saveCustomerCoc(
    customerCocSaveInput: CustomerCocSaveInput!
  ): CustomerCocSavePayload!
  updateCustomerCoc(
    customerCocUpdateInput: CustomerCocUpdateInput!
  ): CustomerCocSavePayload!
  buyAQrSession(input: BuyAQrSessionInput!): BuyAQrSessionPayload
  buyAQrSessionDebt(input: BuyADebQrSessionInput!): BuyAQrSessionPayload
  ProductOrder(input: ProductOrderInput!): ProductOrderPayload
  registerFBDevice(input: RegisteredDeviceInput!): RegisteredDevicePayload
  createSingleMembershipPlan(
    input: CreateSingleMembershipPlanMutationInput
  ): CreateSingleMembershipPlanMutationResponse
  createGroupMembershipPlan(
    input: CreateGroupMembershipPlanMutationInput
  ): CreateGroupMembershipPlanMutationResponse
  createSessionPackPlan(
    input: CreateSessionPackPlanMutationInput
  ): CreateSessionPackPlanMutationResponse
  purchaseSessionPack(
    input: PurchaseSessionPackMutationInput
  ): PurchaseSessionPackMutationResponse
  purchaseSingleMembership(
    input: PurchaseSingleMembershipMutationInput
  ): PurchaseSingleMembershipMutationResponse
  payPendingAmountForSingleMembership(
    input: PayPendingAmountForSingleMembershipMutationInput
  ): PayPendingAmountForSingleMembershipMutationResponse
  assignSingleMembership(
    input: AssignSingleMembershipMutationInput
  ): AssignSingleMembershipMutationResponse
  purchaseGroupMembership(
    input: PurchaseGroupMembershipMutationInput
  ): PurchaseGroupMembershipMutationResponse
  createPaymentPlan(
    input: CreatePaymentPlanMutationInput
  ): CreatePaymentPlanMutationResponse
  createMembershipPlanGroup(
    input: CreateMembershipPlanGroupMutationInput
  ): CreateMembershipPlanGroupMutationResponse
  createMembershipFreezeType(
    input: CreateMembershipFreezeTypeMutationInput
  ): CreateMembershipFreezeTypeMutationResponse
  updateMembershipFreezeType(
    input: UpdateMembershipFreezeTypeMutationInput
  ): UpdateMembershipFreezeTypeMutationResponse
  deleteMembershipFreezeType(
    input: DeleteMembershipFreezeTypeMutationInput
  ): PlainResponse
  updateMembershipPlanGroup(
    input: UpdateMembershipPlanGroupMutationInput
  ): UpdateMembershipPlanGroupMutationResponse
  checkInUser(input: CheckInUserMutationInput): CheckInUserMutationResponse
  deleteMembership(input: DeleteMembershipMutationInput): PlainResponse
  terminateMembership(
    input: TerminateMembershipMutationInput
  ): TerminateMembershipMutationResponse
  cancelMembershipByAdmin(
    input: CancelMembershipByAdminMutationInput
  ): CancelMembershipByAdminMutationResponse
  extendMembership(input: ExtendMembershipMutationInput): PlainResponse
  cancelMembership(input: CancelMembershipMutationInput): PlainResponse
  freezeMembership(
    input: FreezeMembershipMutationInput
  ): FreezeMembershipMutationResponse
  approveMembershipActionRequest(
    input: ApproveMembershipRequestMutationInput
  ): PlainResponse
  rejectMembershipActionRequest(
    input: RejectMembershipRequestMutationInput
  ): PlainResponse
  updateGroupMembershipPlan(
    input: UpdateGroupMembershipPlanMutationInput
  ): UpdateGroupMembershipPlanMutationResponse
  updateSingleMembershipPlan(
    input: UpdateSingleMembershipPlanMutationInput
  ): UpdateSingleMembershipPlanMutationResponse
  updateSessionPackPlan(
    input: UpdateSessionPackPlanMutationInput
  ): UpdateSessionPackPlanMutationResponse
  updatePaymentPlan(
    input: UpdatePaymentPlanMutationInput
  ): UpdatePaymentPlanMutationResponse
  testRecurringPayment(
    input: TestRecurringPaymentMutationInput
  ): TestRecurringPaymentMutationResponse
  simulateRecurringPayment(
    input: SimulateRecurringPaymentMutationInput
  ): SimulateRecurringPaymentMutationResponse
  simulateUnfreezeMembership(
    input: SimulateUnfreezeMembershipMutationInput
  ): SimulateUnfreezeMembershipMutationResponse
  freezeMembershipFromAdmin(
    input: FreezeMembershipFromAdminMutationInput
  ): PlainResponse
  unfreezeMembershipFromAdmin(
    input: UnfreezeMembershipFromAdminMutationInput
  ): PlainResponse
  syncMemGroup: PlainResponse
  changeMembership(
    input: ChangeMembershipMutationInput
  ): ChangeMembershipMutationResponse
  changeMembershipSalesBy(
    input: ChangeSalesByMutationInput
  ): ChangeSalesByMutationResponse
  transferMembership(
    input: TransferMembershipMutationInput
  ): TransferMembershipResponse
  relocateMembership(
    input: RelocateMembershipMutationInput
  ): RelocateMembershipResponse
  updateSingleMembership(
    input: UpdateSingleMembershipMutationInput
  ): UpdateSingleMembershipMutationResponse
  attendSessionByQrCode(input: AttendSessionInput!): AttendSessionPayload
  attendPTSessionFromAdmin(bookingId: ID!): AttendSessionPayload
  removePTSessionAttendance(bookingId: ID!): AttendSessionPayload
  saveInstructor(input: SaveInstructorInput!): SaveInstructorPayload
  registerInstructor(input: RegisterInstructorInput!): RegisterInstructorPayload
  createTempInstructor(
    input: CreateTempInstructorInput!
  ): RegisterInstructorPayload
  saveInstructorStatusUpdate(
    input: SaveInstructorStatusInput!
  ): SaveInstructorPayload
  saveInstructorCoverPhotoUpdate(
    input: SaveInstructorCoverPhotoInput!
  ): SaveInstructorPayload
  saveInstructorMobile(input: SaveInstructorMobileInput!): SaveInstructorPayload
  saveInstructorPasswordMobile(
    input: SaveInstructorPasswordMobileInput!
  ): SaveInstructorPayload
  importInstructors(input: ImportInstructorsInput!): ImportInstructorsPayload
  syncInstructorsWithFirebase: Boolean
  triggerAllInstructorEvents: Boolean
  markInstructorOnline(id: ID!): InstructorOnlinePayload!
  markInstructorOffline(id: ID!): InstructorOnlinePayload!
  markInstructorFavouriteByInstructor(
    favouriteInstructorId: ID!
  ): InstructorFavouriteByInstructorPayload!
  unMarkInstructorFavouriteByInstructor(
    favouriteInstructorId: ID!
  ): InstructorFavouriteByInstructorPayload!
  saveInstructorComment(
    input: SaveInstructorCommentInput!
  ): SaveInstructorCommentPayload
  deleteInstructorComment(id: ID!): DeleteInstructorCommentPayload
  markInstructorFavourite(instructorId: ID!): InstructorFavouritePayload
  unMarkInstructorFavourite(instructorId: ID!): InstructorFavouritePayload
  saveInstructorGallery(
    input: SaveInstructorGalleryInput!
  ): SaveInstructorGalleryPayload
  instructorSpecialityUpsert(
    input: InstructorSpecialityInput!
  ): SaveInstructorSpecialityPayload
  buyAPrivateCoach(input: BuyAPrivateCoachInput!): BuyAPrivateCoachPayload
  buyAPrivateCoachFromAdminPlatform(
    input: BuyAPrivateCoachFromAdminPlatformInput!
  ): BuyAPrivateCoachPayload
  bookAPrivateCoach(input: BookAPrivateCoachInput!): BookAPrivateCoachPayload
  bookAPrivateCoachFromAdminPlatform(
    input: BookAPrivateCoachFromAdminPlatformInput!
  ): BookAPrivateCoachPayload
  updateABookingFromAdminPlatform(
    input: UpdateABookingFromAdminPlatformInput!
  ): UpdateABookingFromAdminPlatformPayload
  # DON'T USE X -> Depriecated
  rateInstructorSession(
    input: RateInstructorSessionInput!
  ): RateInstructorSessionPayload!
  addIntructorEvent(
    input: AddIntructorEventInput!
  ): AddIntructorEventInputPayload!
  cancelPTBookingFromAdmin(bookingId: ID!): AddIntructorEventInputPayload!
  saveService(input: SaveServiceInput!): SaveServicePayload
  saveServiceCategory(
    input: SaveServiceCategoryInput!
  ): SaveServiceCategoryPayload
  saveServiceSubCategory(
    input: SaveServiceSubCategoryInput!
  ): SaveServiceSubCategoryPayload
  saveSessionContract(
    input: SaveSessionContractInput!
  ): SaveSessionContractPayload
  gmsInstructorImport(
    input: GmsInstructorImportInput!
  ): GmsInstructorImportPayload
  fileMutationTest: Boolean
  addFile(input: SaveFileInput!): SaveFilePayload
  addFiles(input: SaveFilesInput!): SaveFilesPayload
  updateFile(input: UpdateFileInput!): UpdateFilePayload
  deleteFile(input: DeleteFileInput!): DeleteFilePayload
  addFileCategory(input: SaveFileCategoryInput!): SaveFileCategoryPayload
  updateFileCategory(input: UpdateFileCategoryInput!): UpdateFileCategoryPayload
  saveMultiFileCategories(
    input: [SaveFileCategoryInput]!
  ): SaveMultiFileCategoryPayload
  createEvent(input: CreateEventInput): CreateEvent
  updateEvent(input: UpdateEventInput): UpdateEvent
  reserveAnEvent(input: ReserveAnEventInput): ReserveAnEvent
  buyAnEvent(input: BuyAnEventInput!): BuyAnEventPayload
  cancelEventPurchase(
    input: CancelEventPurchaseInput!
  ): CancelEventPurchasePayload
  likeAnEvent(input: LikeAnEventInput): LikeEvent
  dislikeAnEvent(input: DislikeAnEventInput): DislikeEvent
  createEventReview(input: CreateEventReviewInput): CreateEventReview
  attendAnEvent(input: AttendAnEventInput): AttendEvent
  approveAccountDeletionRequest(
    input: UpdateAccountDeletionRequestInput!
  ): SaveAccountDeletionRequestPayload
  rejectAccountDeletionRequest(
    input: UpdateAccountDeletionRequestInput!
  ): SaveAccountDeletionRequestPayload
  composeBulkEmails(input: ComposeBulkEmailsInput!): ComposeBulkEmailsPayload!
  composeBulkNotifications(
    input: ComposeBulkNotificationsInput!
  ): ComposeBulkNotificationsPayload!
  signInWithEmailAndPassword(
    email: String!
    password: String!
  ): CustomerSignInPayload!
  saveCustomer(input: SaveCustomerInput!): SaveCustomerPayload
  updateCustomerInfo(input: UpdateCustomerInfoInput!): SaveCustomerPayload
  registerCustomer(input: RegisterCustomerInput!): RegisterCustomerPayload
  createCustomer(input: CreateCustomerInput!): SaveCustomerPayload
  updateCustomer(input: UpdateCustomerInput!): SaveCustomerPayload
  saveCustomerPhoto(input: CustomerPhotoInput!): RegisterCustomerPayload
  saveCustomerMedicalForm(
    input: CustomerMedicalForm!
  ): CustomerMedicalFormPayload
  saveCustomerPtPref(input: CustomerPtPrefInput!): CustomerPtPrefPayload
  saveCustomerGymClassPref(
    input: CustomerGymClassPrefInput!
  ): CustomerGymClassPrefPayload
  saveCustomerGymPref(input: CustomerGymPrefInput!): CustomerGymPrefPayload
  deleteCustomerAccount(
    input: DeleteCustomerAccountInput
  ): DeleteCustomerAccountPayload
  deleteCustomerById(customerId: ID!): DeleteCustomerPayload
  deleteCustomerByEmail(customerEmail: String!): DeleteCustomerPayload
  deleteAllCustomers: DeleteAllCustomersPayload
  syncCustomersWithFirebase(contactNumber: String): Boolean
  syncCustomersWithFirebaseV2(contactNumber: String): Boolean
  syncCustomerKafka: Boolean
  triggerAllCustomerEvents: Boolean
  saveParqHealth(input: CustomerParqHealthInput!): CustomerParqHealthPayload
  saveGfpHealth(input: CustomerGfpHealthInput!): CustomerGfpHealthPayload
  saveTAndCSignature(id: ID, signatureLink: String!): CustomerGfpHealthPayload
  # New signup otp flow
  signUpWithMobileNumber(
    input: SignUpWithMobileNumberInput!
  ): SaveCustomerPayload!
  saveCustomerAddress(
    input: SaveCustomerAddressInput!
  ): SaveCustomerAddressPayload
  deleteCustomerAddress(id: ID!): DeleteCustomerAddressPayload
  guestLogin(input: GuestLoginInput): CreateGuestPayload!
  createGymBuddy(input: SaveGymBuddyInput!): SaveGymBuddyPayload
  updateGymBuddy(input: UpdateGymBuddyInput!): SaveGymBuddyPayload
  saveGymBuddyPhoto(input: GymBuddyPhotoInput!): SaveGymBuddyPayload
  updateGymBuddyLocation(input: GymBuddyLocationInput!): SaveGymBuddyPayload
  favouriteGymBuddy(input: GymBuddyFavouriteInput!): SaveGymBuddyPayload
  unFavouriteGymBuddy(input: GymBuddyFavouriteInput!): SaveGymBuddyPayload
  removeFollowerGymBuddy(
    input: RemoveFollowerGymBuddyInput!
  ): SaveGymBuddyPayload
  updateSocialAccounts(input: SocialAccountsInput!): SaveGymBuddyPayload
  insertSocialAccounts(input: SocialAccountsInput!): SaveGymBuddyPayload
  deleteSocialAccounts(input: SocialAccountsInput!): SaveGymBuddyPayload
  addLead(input: SaveLeadInput!): SaveLeadPayload
  updateLead(input: UpdateLeadInput!): SaveLeadPayload
  convertLeadChildToParent(
    input: ConvertLeadChildToParentInput!
  ): ConvertLeadPayload
  convertLeadParentToChild(
    input: ConvertLeadParentToChildInput!
  ): ConvertLeadPayload
  uploadLeadPhoto(input: LeadPhotoInput!): SaveLeadPayload
  deleteLead(id: ID!): DeleteLeadPayload
  softDeleteLead: SoftDeleteLeadPayload
  undoSoftDeleteLead(id: ID!): UndoSoftDeleteLeadPayload
  fixLeadsData: String
  leadSearchPerPhoneOrCreate(
    phoneNumber: ID!
    gymId: ID!
    leadCreatedById: ID
  ): leadSearchPerPhonePayload
  syncAllLeads: Boolean
  syncLeadMemberships: SyncLeadMembershipsPayload
  saveParqHealthV2(input: LeadParqHealthInput!): LeadParqHealthPayload
  saveGfpHealthV2(input: LeadGfpHealthInput!): LeadGfpHealthPayload
  saveTAndCSignatureV2(id: ID!, signatureLink: String!): LeadGfpHealthPayload
  safelyRemoveDuplicateLeads(
    gymId: ID
    phoneNumber: String
    status: LeadStatus
    count: Int
  ): DuplicateLeadResponse
  updateLeadStatus(input: UpdateLeadStatusInput!): SaveLeadPayload
  updateLeadClassBookingStatus(
    input: UpdateLeadClassBookingStatusInput!
  ): SaveLeadPayload
  importLeads(input: ImportLeadsInput!): ImportLeadsPayload
  rollbackImportedLeads(input: RollbackImportedLeadsInput!): ImportLeadsPayload
  # New signup otp flow
  sendOTP(input: sendOTPInput): sendOTPPayload!
  verifyOTP(input: VerifyOTPInput): VerifyOTPPayload!
  referFriend(input: ReferFriendInput!): ReferFriendPayload!
  acceptOrRejectInvite(
    refereeId: ID!
    accept: Boolean!
  ): AcceptOrRejectInvitePayload!
  resendInviteEmail(refereeId: ID!): ResendInviteEmailPayload!
  createAppointment(
    input: SaveLeadAppointmentInput!
  ): SaveLeadAppointmentPayload
  updateAppointment(
    input: UpdateLeadAppointmentInput!
  ): SaveLeadAppointmentPayload
  createCall(input: SaveLeadCallInput!): SaveLeadCallPayload
  updateCall(input: UpdateLeadCallInput!): SaveLeadCallPayload
  addCompany(input: SaveLeadCompanyInput!): SaveLeadCompanyPayload
  updateCompany(input: UpdateLeadCompanyInput!): SaveLeadCompanyPayload
  addContact(input: SaveLeadContactInput!): SaveLeadContactPayload
  updateContact(input: UpdateLeadContactInput!): SaveLeadContactPayload
  createEmail(input: SaveLeadEmailInput!): SaveLeadEmailPayload
  updateEmail(input: UpdateLeadEmailInput!): SaveLeadEmailPayload
  deleteFollowUp(id: ID!, type: FollowUpType!): DeleteTaskPayload
  createNote(input: SaveLeadNoteInput!): SaveLeadNotePayload
  updateNote(input: UpdateLeadNoteInput!): SaveLeadNotePayload
  createNotification(
    input: SaveLeadNotificationInput!
  ): SaveLeadNotificationPayload
  updateNotification(
    input: UpdateLeadNotificationInput!
  ): SaveLeadNotificationPayload
  setMessageAsSeen(id: ID!): MessagePayload
  createIndividualNotification(
    input: SaveIndividualNotificationInput!
  ): SaveIndividualNotificationPayload
  updateIndividualNotification(
    input: UpdateIndividualNotificationInput!
  ): SaveIndividualNotificationPayload
  createGroupNotification(
    input: SaveGroupNotificationInput!
  ): SaveGroupNotificationPayload
  updateGroupNotification(
    input: UpdateGroupNotificationInput!
  ): SaveGroupNotificationPayload
  assignSalesOrTrainer(
    input: SaveLeadSalesTrainerInput!
  ): SaveLeadSalesTrainerPayload
  createTask(input: SaveLeadTaskInput!): SaveLeadTaskPayload
  updateTask(input: UpdateLeadTaskInput!): SaveLeadTaskPayload
  assignTask(input: AssignLeadTaskInput!): SaveLeadTaskPayload
  addLinkedAccount(input: SaveLinkedAccountInput!): SaveLinkedAccountPayload
  updateLinkedAccount(
    input: UpdateLinkedAccountInput!
  ): SaveLinkedAccountPayload
  createTemporaryLead(input: CreateTemporaryLeadInput!): TemporaryLeadPayload
  saveWhiteListedNumber(
    input: SaveWhiteListedNumber!
  ): SaveWhiteListedNumberPayload
  deleteWhiteListedNumber(
    input: DeleteWhiteListedNumber!
  ): ResultWhiteListedNumberPayload
  updateUserDetail(input: ZkUpdateUserInput!): ZkUpdateUserPayload
  updateUserAccessLevel(
    input: UpdateUserAccessLevelInput!
  ): UpdateUserAccessLevelPayload
  saveContentElement(input: SaveContentElementInput!): SaveContentElementPayload
  sortContentElement(ids: [ID!]!, contentGroupId: ID!): Boolean
  saveContentElementValue(
    input: SaveContentElementValueInput!
  ): SaveContentElementValuePayload
  saveContentGroup(input: SaveContentGroupInput!): SaveContentGroupPayload
  sortContentGroup(ids: [ID!]!, contentTypeId: ID!): Boolean
  saveContentType(input: SaveContentTypeInput!): SaveContentTypePayload
  saveCourt(input: SaveCourtInput!): SaveCourtPayload
  deleteCourt(courtId: ID!): SaveCourtPayload
  invalidateAllRedisCourts: Boolean
  saveCourtAmenity(input: SaveCourtAmenityInput!): SaveCourtAmenityPayload
  deleteCourtAmenity(courtAmenityId: ID!): SaveCourtAmenityPayload
  saveCourtCategory(input: SaveCourtCategoryInput!): SaveCourtCategoryPayload
  deleteCourtCategory(courtCategoryId: ID!): SaveCourtCategoryPayload
  saveCourtComment(input: SaveCourtCommentInput!): SaveCourtCommentPayload
  deleteCourtComment(id: ID!): DeleteCourtCommentPayload
  favouriteCourt(courtId: ID!): FavouriteCourtPayload
  unFavouriteCourt(courtId: ID!): FavouriteCourtPayload
  # Customer mutations
  buyACourt(input: BuyACourtInput!): BuyACourtPayload
  attendABookingByQrCode(
    input: AttendABookingByQrCodeInput!
  ): AttendABookingByQrCodePayload
  # Customer mutations
  cancelABookingMobile(
    input: CancelABookingMobileInput!
  ): CancelABookingMobilePayload
  acceptABookingMobile(
    input: InviteABookingMobileInput!
  ): InviteABookingMobilePayload
  declineABookingMobile(
    input: InviteABookingMobileInput!
  ): InviteABookingMobilePayload
  addressFieldUpsert(input: AddressFieldInput!): SaveAddressFieldPayload
  sortAddressFields(countryId: ID!, ids: [ID!]!): Boolean
  configurationUpsert(input: ConfigurationInput!): SaveConfigurationPayload
  invalidateAllRedisCommon: Boolean
  addCountry(input: CountryInput!): SaveCountryPayload
  updateCountry(input: UpdateCountryInput!): SaveCountryPayload
  countryUpsert(input: CountryInput!): SaveCountryPayload
  injectCountriesData(
    input: InjectCountriesDataInput
  ): InjectCountriesDataPayload
  addCountryCity(input: SaveCountryCityInput!): SaveCountryCityPayload
  updateCountryCity(input: UpdateCountryCityInput!): SaveCountryCityPayload
  addCities: Boolean
  injectCities(countryId: ID!): Boolean
  syncCities: Boolean
  addCountryState(input: SaveCountryStateInput!): SaveCountryStatePayload
  updateCountryState(input: UpdateCountryStateInput!): SaveCountryStatePayload
  addHomeScreen(input: HomeScreenInput!): SaveHomeScreenPayload
  languageUpsert(input: LanguageInput!): SaveLanguagePayload
  saveLanguageCountry(
    input: SaveLanguageCountryInput!
  ): SaveLanguageCountryPayload
  measureUnitUpsert(input: MeasureUnitInput!): SaveMeasureUnitPayload
  savePermission(input: SavePermissionInput!): SavePermissionPayload
  loadPermissionsFromServer(
    idIndex: Int
    nameIndex: Int
    descriptionIndex: Int
    rolesIndex: Int
    link: String
  ): Boolean
  saveRole(input: SaveRoleInput!): SaveRolePayload
  saveTermsConditions(
    input: SaveTermsConditionsInput!
  ): SaveTermsConditionsPayload
}

type MyGymClassesForCustomersPayload {
  list: [CustomerGymClassLight!]
  paging: PaginatorOutput
}

type NationalityList {
  name: String
}

input NearByGymClassesFilters {
  searchText: String
  # User's current location
  location: GISLocationInput!
  countryId: ID!
  categoryId: ID
  timeZoneIdentifier: String!
  showForOnlyGymId: ID
  gymClassPref: CustomerGymClassDefaultPrefInput!
  filterType: String
  showExpired: Boolean
}

input NearByGymClassesFiltersV2 {
  searchText: String
  # User's current location
  location: GISLocationInput!
  countryId: ID!
  categoryId: ID
  gymIds: [ID!]
  gender: GlobalGenderType
  difficultyLevel: [DifficultyLevel!]
  ageFrom: Int
  ageTo: Int
  availableSlots: Boolean
  timeZoneIdentifier: String!
  showForOnlyGymId: ID
  gymClassPref: CustomerGymClassDefaultPrefInput
  filterType: String
  showExpired: Boolean
}

type Notification {
  id: ID!
  status: String!
  viewed: Boolean!
  lastAttemptAt: Int!
  noOfAttempts: Int!
  customerId: String!
  medium: String!
}

enum NotificationError {
  INTERNAL_SERVER_ERROR
  INVALID_ID
}

# Offers
type Offer {
  id: ID!
  title: String!
  description: String!
  thumbnail: String!
  photo: String
  brandId: ID!
  gymId: ID
  status: GlobalStatusType!
  socialMediaReferences: [VSocialMediaReference!]
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum OfferError {
  DUPLICATE_NAME
  INVALID_ID
  NOT_ALLOWED
}

input OffersFilter {
  searchText: String
  status: GlobalStatusType
  brandId: ID
  gymId: ID
}

type OffersPayload {
  list: [Offer!]
  paging: PaginatorOutputUpdated
}

type OneGroupMembershipPlan {
  groupMembershipPlan: GroupMembershipPlan
  paging: PaginatorOutputUpdated
}

type OneMembership {
  membership: Membership!
}

type OneMembershipFreezeType {
  membershipFreezeType: MembershipFreezeType
}

type OneMembershipPlanGroup {
  membershipPlanGroup: MembershipPlanGroup
}

type OneSessionPackPlan {
  sessionPackPlan: SessionPackPlan
}

type OneSingleMembershipPlan {
  singleMembershipPlan: SingleMembershipPlan
}

type OrderCourt {
  id: ID!
  courtId: ID!
  countryId: ID!
  status: CourtOrderStatus!
  paymentStatus: PaymentStatus!
  subtotal: CurrencyValue!
  total: CurrencyValue!
  amountDue: CurrencyValue!
  maxPlayers: Int!
  maxSlots: Int!
  bookedSlots: Int!
  message: String
}

type OrderCourtBookedSlot {
  id: ID!
  court: Court!
  orderCourt: OrderCourt!
  bookingDate: Date!
  openTime: LocalTime!
  closeTime: LocalTime!
  qrCode: String
  status: CourtOrderBookingStatus!
  customerStatus: OrderCourtCustomerStatus!
  customer: Customer_Court
  isExpired: Boolean!
  isAttended: Boolean!
}

enum OrderCourtBookedSlotError {
  UNAUTHORIZED
  INVALID_ID
  EXCEPTION
  NOT_ACTIVE
  ALREADY_ACCEPTED
  ALREADY_DECLINED
  NOT_PAID
  INVALID_CODE
  ALREADY_ATTENDED
}

enum OrderCourtCustomerStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum OrderError {
  NOT_EXISTS
  EXCEPTION
  TRANSACTION_EXCEPTION
}

# gym classes bought by customers
type OrderGymClass {
  id: ID!
  shortCode: String!
  gymClassId: ID!
  customerId: ID!
  instructorId: ID
  countryId: ID!
  amount: CurrencyValue!
  status: GymClassStatus!
  paymentStatus: PaymentStatus!
  qrCode: String
  startDate: Date
  endDate: Date
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum OrderGymClassError {
  INVALID_GYM_CLASS_ID
  INVALID_GYM_STUDIO_ID
  GYM_CLASS_NOT_ACTIVE
  SLOT_NOT_AVAILABLE
  ALREADY_BOOKED
  INVALID_PAYMENT_METHOD
  PAYMENT_PROVIDER_ERROR
  NOT_AUTHORIZED
  NOT_EXISTS
  INVALID_MEMBERSHIP_PLAN_ID
  CLASS_NOT_ALLOWED
  NOT_A_MEMBER
  EXPIRED
  EXCEPTION
  TRANSACTIONAL_EXCEPTION
  PAYMENT_EXCEPTION
  NOT_ALLOWED
}

type OrderGymClassV2 {
  id: ID!
  shortCode: String!
  scheduleId: ID!
  scheduleGroupId: ID!
  customerId: ID!
  instructorId: ID
  countryId: ID
  amount: CurrencyValue!
  status: GymClassStatus!
  paymentStatus: PaymentStatus!
  qrCode: String
  startDate: Date
  endDate: Date
  createdAt: Datetime!
  updatedAt: Datetime!
}

type OrderHistoryRemoved {
  id: ID
}

input OrderPaymentMethodInput {
  name: String
  sourceId: ID
  paymentScheme: String
}

enum OrderPaymentScheme {
  KNET
  STC_PAY
  MADA
  AMEX
  CARD
  ADD_CARD
  SAVED_CARD
  APPLE_PAY
  GOOGLE_PAY
  LAUNCH
  CASH
  FREE_TRIAL
  CARD_OVER_COUNTER
}

# Private Coaches booked by customers
type OrderPrivateCoach {
  id: ID!
  shortCode: String!
  source: String
  customerId: ID!
  countryId: ID!
  brandId: ID
  gymId: ID
  serviceId: ID
  justBooking: Boolean!
  status: String!
  total: CurrencyValue!
  subtotal: CurrencyValue!
  amountDue: CurrencyValue
  message: String
  paymentStatus: PaymentStatus!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum OrderPrivateCoachError {
  INVALID_FIELD_DATA
  INVALID_INSTRUCTOR
  SESSION_REQUIRED
  INVALID_SESSION
  INVALID_INSTRUCTOR_ID
  INSTRUCTOR_NOT_ACTIVE
  SESSION_NOT_AVAILABLE
  DIFFERENT_COUNTRY
  DIFFERENT_GYM
  DUPLICATE_SESSION_TIME
  NOT_A_PRIVATE_COACH
  INVALID_PAYMENT_METHOD
  PAYMENT_PROVIDER_ERROR
  TRANSACTION_EXCEPTION
  EXCEPTION
  NOT_AUTHORIZED
  EXCEEDED_SLOT_LIMIT
  PAYMENT_EXCEPTION
  SERVICE_ID_REQUIRED
  SERVICE_ID_INVALID
  SESSION_CONTRACT_ID_INVALID
  NOT_ALLOWED
  INVALID_GROUP_NUMBER
  GROUP_MEMBERS_LIMIT_EXCEEDED
  CUSTOMER_NOT_FOUND
  DISCOUNT_EXPIRED
  MAX_LIMIT_REACHED
  DISCOUNT_FOR_MEMBERS_ONLY
}

type OrderPrivateCoachSession {
  id: ID!
  shortCode: String
  code: String
  customerId: ID
  lead: InstructorLead
  customer: InstructorCustomer
  groupMembers: [InstructorLead]
  message: String
  sessionContractId: ID
  instructorId: ID
  gymStudioId: ID
  sessionDate: Date
  dayName: String
  ratingScore: Float
  openTime: LocalTime
  openTimeLabel: String
  openDuration: Float
  closeTime: LocalTime
  closeTimeLabel: String
  amount: CurrencyValue
  currencyCode: String
  service: Service
  instructor: Instructor
  currentEvent: InstructorSessionEventType
  brandName: String
  gymId: String
  gymName: String
  serviceName: String
  instructorImage: String
  instructorName: String
  instructorLongitude: Float
  instructorLatitude: Float
  attend: String
  paymentStatus: String
  status: PrivateCoachSessionStatus
  attendStatus: PTSessionAttendStatus
  isAttended: Boolean
  isAttendable: Boolean
  isPurchased: Boolean
  isCancellable: Boolean
  isAlreadyRatad: Boolean
  isExpired: Boolean
}

enum OrderPrivateCoachSessionError {
  INVALID_SESSION_ID
  INVALID_RATING_SCORE
}

type OrderPrivateCoachSessionHistory {
  id: ID!
  eventType: InstructorSessionEventType!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum OrderPrivateCoachSessionHistoryError {
  INVALID_SESSION_ID
}

# QrSession bought by customers
type OrderQrSession {
  id: ID!
  shortCode: ID!
  customerId: ID!
  qrSessionId: ID!
  amount: String
  status: GymClassStatus_Orders
  paymentStatus: PaymentStatus
  countryId: ID!
  createdAt: Datetime
  updatedAt: Datetime
}

enum OrderQrSessionError {
  INVALID_QR_SESSION_ID
  QR_SESSION_NOT_ACTIVE
  QR_SESSION_NOT_ENDED
  INVALID_PAYMENT_METHOD
  PAYMENT_PROVIDER_ERROR
  WRONG_CUSTOMER_ID
  CUSTOMER_NOT_FOUND
  QR_CODE_NOT_FOUND
  INVALID_PAYMENT_TOKEN
  PAYMENT_TOKEN_EXPIRED
  INVALID_QR_CODE
  UNKNOWN_QR_CODE
  GYM_NOT_FOUND
  ACTIVE_SESSION_NOT_FOUND
  WRONG_GYM
  INVALID_CUSTOMER_ID
}

type OrdersCountry {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: OrdersCurrency!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type OrdersCurrency {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

type OrderTrial {
  id: ID!
  shortCode: String!
  customerId: ID!
  subtotal: CurrencyValue!
  total: CurrencyValue!
  amountDue: CurrencyValue!
  status: OrderTrialStatus!
  paymentStatus: PaymentStatus!
  countryId: ID!
  brandId: ID!
  gymId: ID!
  message: String
  qrCode: String
  startDate: Date
  expiryDate: Date!
  xAppSource: String
  xAppVersion: String
  xAppOs: String
  createdAt: Datetime!
  updatedAt: Datetime!
  createdById: ID
  lastUpdatedById: ID
  isExpired: Boolean!
  # dynamic
  sessions: [OrderTrialSession!]
  gym: ExternalGym_P!
  brand: ExternalBrand_P!
  country: PassCountry_Common!
  attendances: [OrderTrialAttendance!]
  customer: Customer_Pass
}

type OrderTrialAdminV2 {
  id: ID!
  shortCode: String!
  customerId: ID!
  subtotal: CurrencyValue!
  total: CurrencyValue!
  amountDue: CurrencyValue!
  status: OrderTrialStatus!
  paymentStatus: PaymentStatus!
  countryId: ID!
  brandId: ID!
  gymId: ID!
  message: String
  qrCode: String
  startDate: Date
  expiryDate: Date!
  xAppSource: String
  xAppVersion: String
  xAppOs: String
  createdAt: Datetime!
  updatedAt: Datetime!
  createdById: ID
  lastUpdatedById: ID
  createdBy: String
  lastUpdatedBy: String
  isExpired: Boolean!
  # dynamic
  sessions: [OrderTrialSession!]
  gym: ExternalGym_P!
  brand: ExternalBrand_P!
  country: PassCountry_Common!
  attendances: [OrderTrialAttendance!]
  customer: Customer_Pass
}

type OrderTrialAttendance {
  id: ID!
  orderTrialId: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum OrderTrialError {
  INVALID_ID
  INVALID_CUSTOMER
  SELECT_ALL_SLOTS
  INVALID_SLOT_TIME
  PAYMENT_EXCEPTION
  EXCEPTION
  SLOT_NOT_AVAILABLE
  UNAUTHORIZED
  INVALID_GYM
  ALREADY_USED
  FREE_TRIAL_NOT_AVAILABLE
  ALREADY_CANCELLED
  SELECT_ATLEAST_ONE_SLOT
  NOT_CONSECTIVE_SLOTS
  TRIAL_USED
  NOT_ACTIVE
  ALREADY_ATTENDED
  EXPIRED
}

type OrderTrialSession {
  id: ID!
  orderTrialId: ID!
  sessionDate: Date!
  startTime: LocalTime!
  endTime: LocalTime!
  status: OrderTrialSesssionStatus!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum OrderTrialSesssionStatus {
  ACCEPTED
  REJECTED
  ACTIVE
  INACTIVE
  CANCELED
}

enum OrderTrialStatus {
  ACTIVE
  INACTIVE
  CANCELED
}

enum OrderType {
  PASS
  GYM_CLASS
  STORE
  PRIVATE_COACH
  MEMBERSHIP
  MEMBERSHIP_FREEZE
  EVENT
  QR_SESSION
  LAUNCH_BOOKING_GYM_CLASS
  PAYMENT
  POS
  CHANGE_MEMBERSHIP
  TRANSFER_MEMBERSHIP
  CANCEL_MEMBERSHIP
  TERMINATE_MEMBERSHIP
  FREE_TRIAL
}

type PagedAllEventReviews {
  data: AllEventReviewsResponse
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

input PagedEventInput {
  longitude: Float
  latitude: Float
  distance: Float
  minPrice: Float
  maxPrice: Float
  startDate: String
  endDate: String
  countryId: ID
  gymId: ID
  brandId: ID
  name: String
  description: String
  status: EventStatus
  createdById: ID
  filterType: String
  index: Int!
  limit: Int!
}

type PagedEvents {
  data: [Event]
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

type PagedEventsMobileList {
  data: [EventsMobileList]
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

input PagedEventsMobileListInput {
  longitude: Float
  latitude: Float
  distance: Float
  minPrice: Float
  maxPrice: Float
  startDate: String
  endDate: String
  countryId: ID
  gymId: ID
  brandId: ID
  name: String
  description: String
  status: EventStatus
  createdById: ID
  filterType: String
  index: Int!
  limit: Int!
}

type PagedUserEventReviews {
  data: UserEventReviewsResponse
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

type PagedUserEvents {
  data: [Event]
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

input PagedUserEventsInput {
  userId: ID!
  status: EventPurchaseStatus
  index: Int!
  limit: Int!
}

type PagedUserLikedEvents {
  data: UserLikedEventsResponse
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

# Paginator
input PaginatorInput {
  page: Int!
  limit: Int!
}

type PaginatorOutput {
  page: Int!
  limit: Int!
  totalPages: Int!
}

type PaginatorOutputUpdated {
  page: Int!
  limit: Int!
  totalPages: Int!
  totalResultCount: Int
}

input ParqHealthQuestions {
  question: String!
  answer: Boolean!
}

type ParqHealthQuestionsType {
  question: String!
  answer: Boolean!
}

type ParqHealthType {
  answers: [ParqHealthQuestionsType!]
  notes: String
  signatureLink: String
}

type PassCountry_Common {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: PassCurrency_Common!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type PassCurrency_Common {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

type PassingTime {
  minutes: String!
  seconds: String!
}

enum PassStatus {
  ACTIVE
  INACTIVE
  CANCELED
}

type Payment {
  id: ID!
  status: PaymentStatusEnum!
  amount: Float!
  currency: String!
  date: String!
  errorMessage: String
  orderId: String
  membershipAction: [MembershipActionRequest]
  createdAt: String!
  updatedAt: String!
}

enum PaymentFrequencyPeriod {
  DAY
  WEEK
  MONTH
  YEAR
}

enum PaymentFrequencyType {
  SINGLE
  RECURRING
}

input PaymentInput {
  id: ID
  orderType: String
  orderReferenceId: ID
  paymentScheme: String
  provider: String
  paymentMethod: OrderPaymentMethodInput
}

type PaymentLogLine {
  paymentID: ID!
  paymentScheduledDate: String!
  paymentAmount: Float!
  membershipId: ID!
  customerId: ID!
  status: String!
  notes: String
}

type PaymentMethod {
  paymentScheme: OrderPaymentScheme!
  name: String
  imageUrl: String
  subText: String
  sourceId: String
}

input PaymentMethodInput {
  paymentScheme: OrderPaymentScheme!
  name: String!
  imageUrl: String
  subText: String
  sourceId: String
}

type PaymentPlan {
  id: ID!
  name: String!
  type: PaymentTypeEnum!
  price: Float!
  joiningFee: Float!
  currency: String!
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentRecursionDuration: Int
  hasEndDate: Boolean!
  recursionDuration: Int
  recursionPeriod: String
  chargeOnFirst: Boolean
  giftPeriodFree: Boolean
  gracePeriodDays: Int
  allowFreeze: Boolean
  freezesList: [MembershipFreezeDetails]
  admin: MembershipAdmin!
  country: MembershipCountry!
  servicePacks: [ServicePackObjectType]
  installmentAmount: Float
  surcharge: Float
  installmentRounds: Int
  installmentFrequencyType: InstallmentFrequencyTypeEnum
  createdAt: String!
  updatedAt: String!
}

type paymentPlans {
  paymentPlans: [PaymentPlan]
}

enum PaymentProvider {
  TAP
  CHECKOUT
}

enum PaymentRecursionTypeEnum {
  day
  week
  month
  year
}

type payments {
  payments: [Payment]
}

enum PaymentScheme {
  KNET
  STC_PAY
  MADA
  AMEX
  CARD
  ADD_CARD
  SAVED_CARD
  APPLE_PAY
  GOOGLE_PAY
  LAUNCH
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILURE
}

enum PaymentStatusEnum {
  success
  failure
  scheduled
}

type PaymentTokenQrSessionPayload {
  gym: Gym
  qrSession: QrSession
  summary: InfoQrSession
  paymentToken: String
  totalPrice: String
  error: QrSessionError
  errors: [QrSessionError!]
  errorMessage: String
}

enum PaymentTypeEnum {
  single
  recurring
  installment
}

input PayPendingAmountForSingleMembershipMutationInput {
  membershipId: ID!
  paymentMethod: MembershipPaymentMethod!
  cocCardId: ID
  amount: Float
}

type PayPendingAmountForSingleMembershipMutationResponse {
  data: PurchaseSingleMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type perfectMembersNode {
  _1star: valXper!
  _2star: valXper!
  _3star: valXper!
  _4star: valXper!
}

type PerMinuteSessionAmount {
  startTime: LocalTime!
  endTime: LocalTime!
  notAvailable: Boolean!
  message: String
  highlightType: HighlightType
  price: CurrencyValue!
  priceLabel: String!
  compareAtPrice: CurrencyValue
  compareAtPriceLabel: String
  priceMinutely: CurrencyValue!
  priceMinutelyLabel: String!
  compareAtPriceMinutely: CurrencyValue
  compareAtPriceMinutelyLabel: String
  hasDiscount: Boolean!
  currencySymbol: String!
  currencyIsoCode: String!
}

# Permission
type Permission {
  id: ID!
  name: String!
  description: String
  status: StatusType!
  roles: [Role]
  createdById: ID
  lastUpdatedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum PermissionError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_ROLE
  NOT_EDITABLE
}

input PermissionsFilter {
  searchText: String
  status: StatusType
}

type PermissionsPayload {
  list: [Permission]
  paging: PaginatorOutputUpdated
}

type PlainEvent {
  id: ID!
  name: String!
  description: String!
  startDate: String!
  endDate: String!
  latitude: Float!
  longitude: Float!
  distance: Float
  address: String!
  capacity: Int!
  reservedSpotCount: Int!
  price: Float
  pictures: [String]!
  videos: [String]
  difficulty: EventDifficulty!
  equipment: String
  rules: String!
  cancelationPolicy: String!
  status: EventStatus!
  creatorPhoneNumber: String!
  reviewCount: Int!
  averageRating: Float!
  isLiked: Boolean!
  createdById: ID!
  createdAt: String!
  updatedAt: String!
  registeredUsers: [User]
  registeredPTs: [Trainer]
  admin: EventsAdmin!
  gym: EventGym!
  trainers: [Trainer]
  country: EventCountry!
}

type PlainResponse {
  status: MembershipResponseStatus!
}

type PosBrand {
  id: ID!
  name: String!
  description: String
  image: String
  status: PosStatus!
  gymId: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum PosBrandError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_GYM_ID
  NOT_ALLOWED
  ALREADY_DELETED
}

input PosBrandFilter {
  searchText: String
  status: PosStatus
  gymId: ID
}

type PosBrandPayload {
  list: [PosBrand!]
  paging: PaginatorOutputUpdated
}

type PosCategory {
  id: ID!
  name: String!
  description: String
  image: String
  status: PosStatus!
  gymId: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum PosCategoryError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_GYM_ID
  NOT_ALLOWED
  ALREADY_DELETED
}

input PosCategoryFilter {
  searchText: String
  status: PosStatus
  gymId: ID
}

type PosCategoryPayload {
  list: [PosCategory!]
  paging: PaginatorOutputUpdated
}

type PosCountry_Common {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: PosCurrency_Common!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type PosCurrency_Common {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

input PosDateRangeFilter {
  startDate: Date!
  endDate: Date!
}

# Pos orders
type PosOrder {
  id: ID!
  shortCode: String!
  customerId: ID!
  countryId: ID!
  discountedPrice: CurrencyValue
  total: CurrencyValue!
  subtotal: CurrencyValue!
  amountDue: CurrencyValue
  totalVat: CurrencyValue
  vatPercentage: Float
  paymentStatus: PaymentStatus!
  paymentMethod: String
  status: String!
  brandId: ID
  gymId: ID
  gym: Gym_POS
  admin: Admin_POS
  customer: Customer_Pos
  walkinCustomer: Boolean!
  message: String
  createdById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
  items: [PosOrderItem!]
  country: PosCountry_Common
}

enum PosOrderError {
  INVALID_FIELD_DATA
  EXCEPTION
  NOT_AUTHORIZED
  PAYMENT_EXCEPTION
  NOT_ALLOWED
  PRODUCT_REQUIRED
  PRODUCT_INACTIVE
  PRODUCT_CART_NOT_UNIQUE
  PRODUCT_NOT_FOUND
  NOT_IN_STOCK
  NOT_IN_INVENTORY
}

input PosOrderInvoiceInput {
  products: [PosOrderProductItemInput!]!
  gymId: ID!
  brandId: ID!
  customerId: ID!
  walkinCustomer: Boolean!
}

type PosOrderInvoicePayload {
  products: [PosProduct!]
  totals: [PosTotals!]
  country: PosCountry_Common
  error: PosOrderError
  errors: [PosOrderError!]
  errorMessage: String
}

# Pos order items
type PosOrderItem {
  id: ID!
  posOrderId: ID!
  posProductId: ID!
  customerId: ID
  amount: CurrencyValue!
  quantity: Int!
  status: String!
  vatAdjusted: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!
  posProduct: PosProduct!
}

input PosOrderListFromAdminParams {
  customerId: ID
  gymId: ID
  paymentStatus: PaymentStatus
  createdById: ID
  walkingCustomer: Boolean
  dateRange: PosDateRangeFilter
}

type PosOrderListFromAdminPayload {
  list: [PosOrder!]
  paging: PaginatorOutputUpdated!
}

input PosOrderPaymentMethodInput {
  paymentScheme: PosPaymentScheme!
  name: String!
  imageUrl: String
  subText: String
  sourceId: String
}

input PosOrderProductItemInput {
  posProductId: ID!
  quantity: Int!
}

enum PosPaymentScheme {
  KNET
  STC_PAY
  MADA
  AMEX
  CARD
  ADD_CARD
  SAVED_CARD
  APPLE_PAY
  GOOGLE_PAY
  CASH
  CARD_OVER_COUNTER
}

type PosProduct {
  id: ID!
  name: String!
  description: String
  images: [String!]
  gymId: ID!
  posBrandId: ID!
  posCategoryId: ID!
  quantity: Int!
  price: CurrencyValue!
  sku: String!
  status: PosStatus!
  vatAdjusted: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!
  posCategory: PosCategory!
  posBrand: PosBrand!
  country: PosCountry_Common!
}

enum PosProductError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_GYM_ID
  NOT_ALLOWED
  ALREADY_DELETED
  INVALID_BRAND
  INVALID_CATEGORY
  DUPLICATE_SKU
  INTERNAL_ERROR
  INVALID_QUANTITY
  NOT_ACTIVE
}

input PosProductFilter {
  searchText: String
  status: PosStatus
  gymId: ID
  posBrandId: ID
  posCategoryId: ID
  sortBy: PosSortByInput
}

type PosProductPayload {
  list: [PosProduct!]
  paging: PaginatorOutputUpdated
}

enum PosProductSortByEnum {
  name
  createdAt
}

input PosSortByInput {
  orderBy: PosProductSortByEnum!
  ascOrDesc: ascOrDesc!
}

enum PosStatus {
  ACTIVE
  INACTIVE
  DELETED
}

enum PosStatusInput {
  ACTIVE
  INACTIVE
}

type PosTotals {
  type: PosTotalType!
  price: CurrencyValue!
}

enum PosTotalType {
  SUBTOTAL
  TOTAL
  AMOUNT_DUE
  VAT
  VAT_PERCENTAGE
}

input PrefixAvailabilityInput {
  prefix: String
  excludeGymId: ID
}

type PrefixAvailabilityPayload {
  available: Boolean
}

enum PriceType {
  HOURLY
  CLASS
  NONE_OF_THEM
}

type PrivateCoachesPayload {
  list: [Instructor!]
  paging: PaginatorOutput
  sortBy: InstructorSortingOutput
}

type PrivateCoachInvoice {
  components: [InvoiceComponent!]
  currency: InstructorCurrency_Common
  error: InstructorError
  errors: [InstructorError!]
  errorMessage: String
}

input PrivateCoachInvoiceInput {
  instructorId: ID!
  forDate: Date!
  sessions: [PrivateCoachInvoiceSessionInput!]!
}

input PrivateCoachInvoiceSessionInput {
  openTime: LocalTime!
}

enum PrivateCoachSessionStatus {
  ACTIVE
  INACTIVE
  CANCELED
  INIT
}

# Products.
type Product {
  id: ID!
  name: String!
  description: String!
  categoryId: ID!
  brandId: ID!
  status: GlobalStatusType!
  bestSeller: GlobalStatusType
  listPrice: CurrencyValue!
  listPriceLabel: String!
  salePrice: CurrencyValue
  salePriceLabel: String
  sku: String!
  barcode: String!
  warranty: Boolean!
  warrantyPeriod: Int
  warrantyDescription: String
  returnPolicy: Boolean!
  returnPolicyPeriod: Int
  returnPolicyDescription: String
  express: Boolean!
  countryId: ID!
  images: [String!]
  brand: ExternalBrand_Vendors
  country: VendorsShopCountry_Common!
  category: ProductCategory
  inventory: [ProductStock!]
  createdBy: ID!
  lastUpdatedBy: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

input ProductCategoriesFilter {
  searchText: String
  status: GlobalStatusType
}

type ProductCategoriesPayload {
  list: [ProductCategory]
  paging: PaginatorOutput
}

# Product Categories.
type ProductCategory {
  id: ID!
  name: String!
  image: String
  createdBy: ID!
  lastUpdatedBy: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
  status: GlobalStatusType!
  products(brandId: ID): [Product!]
}

enum ProductCategoryError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_BRAND
}

enum ProductError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_MEMBERSHIP_ID
  MEMBERSHIP_NOT_ACTIVE
  INVALID_PRODUCT_ID
  INVALID_COUNTRY_ID
  COUNTRY_CONFLICT
  INVALID_QUANTITY
  OUT_OF_STOCK
}

type ProductInvoice {
  components: [ProductInvoiceComponent!]
  currency: VendorsShopCurrency_Common
  error: ProductError
  errors: [ProductError]
  errorMessage: String
}

type ProductInvoiceComponent {
  type: InvoiceComponentType!
  label: String
  value: CurrencyValue
}

type ProductOrder {
  id: ID!
  shortCode: String!
  customerId: ID!
  countryId: ID!
  status: String!
  total: CurrencyValue!
  subtotal: CurrencyValue!
  amountDue: CurrencyValue
  paymentStatus: PaymentStatus!
  paymentMethod: PaymentMethod!
  createdAt: Datetime!
  updatedAt: Datetime!
}

input ProductOrderCart {
  productId: ID!
  quantity: Int!
}

enum ProductOrderError {
  INVALID_PRODUCT_ID
  PRODUCT_NOT_ACTIVE
  INVALID_COUNTRY_ID
  COUNTRY_CONFLICT
  INVALID_QUANTITY
  OUT_OF_STOCK
  INVALID_PAYMENT_METHOD
  PAYMENT_PROVIDER_ERROR
}

input ProductOrderInput {
  cart: [ProductOrderCart!]!
  countryId: ID!
  paymentMethod: PaymentMethodInput!
  deliveryAddress: CustomerDeliveryAddressInput!
}

type ProductOrderPayload {
  storeOrder: ProductOrder
  paymentUrl: String
  error: ProductOrderError
  errors: [ProductOrderError!]
  errorMessage: String
}

input ProductsFilter {
  searchText: String
  status: GlobalStatusType
  bestSeller: GlobalStatusType
  categoryId: ID
  brandId: ID
  countryId: ID
}

type ProductsPayload {
  list: [Product]
  paging: PaginatorOutput
}

# Product Stocks.
type ProductStock {
  id: ID!
  productId: ID!
  gymId: ID!
  quantity: Int!
  createdBy: ID!
  lastUpdatedBy: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum ProductStockError {
  INVALID_ID
}

input ProductStocksFilter {
  searchText: String
  gymId: ID
  productId: ID
}

type ProductStocksPayload {
  list: [ProductStock]
  paging: PaginatorOutput
}

type ProvisionClassBookingPayload {
  success: Boolean!
  error: String
  errorMessage: String
}

type PTAttendance {
  id: String!
  membershipName: String
  membershipCode: String
  totalCost: CurrencyValue!
  discountedAmount: CurrencyValue
  status: PTSessionAttendStatus
  sessionDate: String
  openTime: String
  service: Service
  instructor: Instructor
  lead: PTSessionReportLead
  gymStudio: PTAttendanceGymStudio
}

type PTAttendanceGymStudio {
  id: String
  name: String
  status: String
}

input PTAttendanceReportFilters {
  gymId: String!
  instructorId: String
  dateRange: DateRangePT
}

type PTAttendanceReportPayload {
  list: [PTAttendance]
  paging: PaginatorOutputUpdated
}

input PTBookingDetailsFilter {
  sessionContractId: ID!
  period: SessionContractBookingType!
}

type PTBookingDetailsPayload {
  list: [OrderPrivateCoachSession]
  paging: PaginatorOutputUpdated
  errorMessage: String
}

input PTParams {
  searchText: String
  location: GISLocationInput
  showForOnlyGymId: ID
  countryId: ID
  ptPref: CustomerPtDefaultPrefInput!
  filterType: String
}

enum PTPaymentScheme {
  KNET
  STC_PAY
  MADA
  AMEX
  CARD
  ADD_CARD
  SAVED_CARD
  APPLE_PAY
  GOOGLE_PAY
  LAUNCH
  CASH
  CARD_OVER_COUNTER
}

type PtPref {
  distance: Float
  distanceInKm: Float
  price: Float
  availableDate: String
  specialities: [ID!]
}

type PTSession {
  id: String!
  name: String!
  noOfSessionsPurchased: Int!
  noOfSessionsPercentage: Float!
}

enum PTSessionAttendStatus {
  BOOKED
  ATTENDED
  MISSED
}

type PTSessionReportCountry {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: PTSessionReportCurrency!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type PTSessionReportCurrency {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

input PTSessionReportFilters {
  countryId: ID
  gymIds: [ID!]
  interval: InstructorTimeIntervalType
  dateRange: DateRangePT
  dummy: String
}

type PTSessionReportGym {
  id: ID!
  name: String!
  country: PTSessionReportCountry
}

type PTSessionReportLead {
  id: ID!
  firstName: String!
  lastName: String!
  customerCode: String
  phoneNumber: String
}

type PTSessionReportPayload {
  total: Int!
  pts: [PTSession!]
  ptAttendance: [PTAttendance]
}

input PTSessionReportV2Filters {
  interval: InstructorTimeIntervalType
  instructorId: String
  gymId: String!
  dateRange: DateRangePT
  serviceCategoryIds: [String]
}

type PTSessionReportV2Payload {
  list: [PTSessionV2]
  paging: PaginatorOutputUpdated
}

type PTSessionV2 {
  id: String!
  invoiceNo: String
  startDate: Date!
  endDate: Date!
  purchaseDate: Date
  totalCost: CurrencyValue!
  discountedAmount: CurrencyValue
  isPaid: Boolean!
  bookedSessions: Int!
  remainingSessions: Int!
  conductedSessions: Int!
  serviceCategories: [PTSessionV2ServiceCategory]
  instructor: Instructor
  lead: PTSessionReportLead
  service: Service
  salesBy: SalesBy
  gym: PTSessionReportGym
}

type PTSessionV2ServiceCategory {
  id: String
  name: String
}

type PurchasegroupMembership {
  groupMembership: GroupMembership
  paymentUrl: String
}

input PurchaseGroupMembershipMutationInput {
  groupMembershipPlanId: ID!
  paymentPlanId: ID!
  paymentMethod: MembershipPaymentMethod!
  cocCardId: ID
  paid: Boolean!
  startDate: String
  userId: ID
  adminId: ID
}

type PurchaseGroupMembershipMutationResponse {
  data: PurchasegroupMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type PurchaseSessionPack {
  sessionPack: SessionPack
}

input PurchaseSessionPackMutationInput {
  sessionPackPlanId: ID!
  paymentPlanId: ID!
  paymentMethod: MembershipPaymentMethod!
  cocCardId: ID
  paid: Boolean!
  startDate: String
  userId: ID
  adminId: ID
}

type PurchaseSessionPackMutationResponse {
  data: PurchaseSessionPack
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type PurchaseSingleMembership {
  singleMembership: SingleMembership
  paymentUrl: String
}

input PurchaseSingleMembershipMutationInput {
  singleMembershipPlanId: ID!
  paymentPlanId: ID!
  paymentMethod: MembershipPaymentMethod!
  cocCardId: ID
  paid: Boolean!
  startDate: String
  endDate: String
  userId: ID
  adminId: ID
  membershipCode: String
  amount: Float
  externalId: String
  discountId: String
}

type PurchaseSingleMembershipMutationResponse {
  data: PurchaseSingleMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input QAType {
  name: String!
  question: String!
  type: String!
  options: [QATypeOption!]
  multiSelectVal: [String!]
  stringVal: String
  boolVal: Boolean
}

input QATypeOption {
  label: String!
  value: String!
}

# QrSessions
type QrSession {
  id: ID!
  customerId: ID!
  gym: Gym!
  country: VendorCountry_Common!
  qrCode: GymQrCode!
  shortCode: String!
  startDate: Datetime!
  endDate: Datetime
  actionStatus: QrSessionActionStatus!
  dailyPrice: Int!
  compareAtDailyPrice: Int
  totalMinutelyDuration: String
  totalMinutelyPrice: String
  createdBy: Admin!
  lastUpdatedBy: Admin!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum QrSessionActionStatus {
  STARTED
  ENDED
}

enum QrSessionError {
  INVALID_QR_CODE
  UNKNOWN_QR_CODE
  ALREADY_SESSION_STARTED
  INCOMPLETE_SESSION
  GYM_ADDRESS_NOT_FOUND
  GYM_COUNTRY_NOT_FOUND
  INVALID_CUSTOMER_ID
  ACTIVE_SESSION_NOT_FOUND
  WRONG_GYM
  INVALID_OPERATING_HOUR
  HOURLY_PRICE_NOT_FOUND
  GYM_NOT_FOUND
  WRONG_GYM_PRICE_TYPE
  TRANSACTION_ERROR
  INVALID_QR_SESSION_ID
  DEBT_SESSION_NOT_FOUND
}

type QrSessionPeriodList {
  currencySymbol: String!
  currencyIsoCode: String!
  isLowestPrice: Boolean!
  minutelyDuration: String!
  minutelyDurationLabel: String!
  hourlyPrice: String!
  hourlyPriceValue: CurrencyValue!
  hourlyPriceLabel: String!
  minutelyPrice: String!
  minutelyPriceValue: CurrencyValue!
  minutelyPriceLabel: String!
  totalDurationPrice: String!
  totalDurationPriceValue: CurrencyValue!
  totalDurationPriceValueLabel: String!
  summaryLabel: String!
}

enum QuantityOrRevenueEnum {
  quantity
  revenue
}

type Query {
  stores(
    paging: PaginatorInput!
    params: ExternalBrand_VendorsFiler
  ): ExternalBrand_VendorsPayload!
  product(id: ID!): Product!
  products(paging: PaginatorInput!, params: ProductsFilter): ProductsPayload!
  storeOrderInvoice(input: StoreOrderInvoiceInput!): ProductInvoice!
  storeHome(input: StoreHomeInput): StoreHomePayload!
  dashboardVendorShop: DashboardVendorShopPayload
  productCategory(id: ID!): ProductCategory!
  productCategories(
    paging: PaginatorInput!
    params: ProductCategoriesFilter
  ): ProductCategoriesPayload!
  productStock(id: ID!): ProductStock!
  productStocks(
    paging: PaginatorInput!
    params: ProductStocksFilter
  ): ProductStocksPayload!
  storeImage(id: ID!): StoreImage!
  storeImages(
    paging: PaginatorInput!
    params: StoreImagesFilter
  ): StoreImagesPayload!
  admin(id: ID!): Admin
  adminByEmail(email: String!): Admin
  admins(paging: PaginatorInput!, params: AdminsFilter): AdminsPayload!
  adminsList(paging: PaginatorInput!, params: AdminsFilter): AdminsPayload!
  adminsByGymIdAndRoles(
    gymId: String!
    roles: [String]
  ): AdminsByGymIdAndRolesPayload
  dashboardVendor: DashboardVendorPayload
  testKafkaEvents: Boolean
  syncInstructorsAdminIds: Boolean
  gymAdminsOrRelated(
    paging: PaginatorInput
    params: GymAdminsOrRelatedFilter
  ): GymAdminsOrRelatedPayload!
  amenities(filter: AmenityFilter): [Amenity!]
  gymAmenities(gymId: ID!): [Amenity!]
  currentVisitors(input: AnaltyicsInput!): VisitorCountResponse
  newVisitors(input: AnaltyicsInput!): VisitorCountResponse
  gymUsageDuration(input: AnaltyicsInput!): VisitorDurationResponse
  getAppIds(paging: PaginatorInput): AppIdsPayload!
  getMinVersion(appId: ID!): MinVersionPayload!
  getAppId(appId: ID!): AppIdPayload
  brand(id: ID!): Brand!
  brands(paging: PaginatorInput, params: BrandsFilter): BrandsPayload!
  brandsList(paging: PaginatorInput, params: BrandsFilter): BrandsPayload!
  authorizedBrands(paging: PaginatorInput, params: BrandsFilter): BrandsPayload!
  brandAdmin(id: ID!): BrandAdmin
  brandAdmins(
    paging: PaginatorInput!
    params: BrandAdminsFilter
  ): BrandAdminsPayload!
  comment(reviewId: ID!): Comment
  commentsByCustomerAuth(
    paging: PaginatorInput!
    params: CommentsFilter
  ): CommentsPayload!
  commentsByAdminAuth(
    paging: PaginatorInput!
    params: CommentsFilter
  ): CommentsPayload!
  discount(id: ID!): Discount!
  discounts(paging: PaginatorInput!, params: DiscountsFilter): DiscountsPayload!
  favouriteGyms(paging: PaginatorInput): FavouriteGymsPayload!
  difficultyLevel(name: String): EnumValuesPayLoad!
  CourtStatusEnum(name: String): EnumValuesPayLoad!
  FacilityStatusEnum(name: String): EnumValuesPayLoad!
  adminTypes(name: String): EnumValuesPayLoad!
  getSubscriptionTypes: EnumValuesPayLoad!
  gym(id: ID!): Gym!
  gymByBrandId(id: ID!): [Gym!]!
  gymDetailMobile(
    id: ID!
    params: GymDetailMobileViewParams!
  ): GymDetailMobileView!
  gyms(paging: PaginatorInput!, params: GymsFilter): GymsPayload!
  gymsList(paging: PaginatorInput!, params: GymsListFilter): GymsPayload!
  authorizedGyms(paging: PaginatorInput!, params: GymsFilter): GymsPayload!
  gymSubscription(paging: PaginatorInput!, params: GymsFilter): GymsPayload!
  gymsInRadius(
    paging: PaginatorInput!
    params: GymsInRadiusFilter!
  ): MobileGymListViewPayload!
  gymIdsInRadius(params: GymsInRadiusFilter!): [ID!]!
  gymPrefixAvailability(
    params: PrefixAvailabilityInput!
  ): PrefixAvailabilityPayload!
  gymPaymentGatewayDetail(id: ID!): GymPaymentGatewayDetail!
  getGymAccessGates(paging: PaginatorInput, gymId: ID!): GatesPayload
  getGymAccessGateById(id: ID!): GymAccessGate
  getGymAccessLevels(paging: PaginatorInput, gymId: ID!): AccessLevelsPayload
  getGymAccessLevelById(id: ID!): GymAccessLevel
  gymAddress(gymId: ID!): GymAddress
  gymAdmin(id: ID!): GymAdmin
  gymAdmins(paging: PaginatorInput!, params: GymAdminsFilter): GymAdminsPayload!
  gymBanner(id: ID!): GymBanner!
  gymBanners(
    paging: PaginatorInput!
    params: GymBannerFilter
  ): GymBannerPayload!
  gymDevice(id: ID!): GymDevice!
  gymDevices(paging: PaginatorInput!): GymDevicesPayload!
  validateAccessByMember(
    input: ValidateAccessByMemberInput!
  ): ValidateAccessPayload
  gymOperatingHourlyPrices(gymOperatingHourId: ID!): [GymOperatingHourlyPrices]
  gymOperatingHours(gymId: ID!): [GymOperatingHours!]
  gymQrCode(gymId: ID!): GymQrCode
  gymQrReview(qrSessionId: ID!): GymQrReview
  gymQrReviews(
    paging: PaginatorInput!
    params: GymQrReviewsFilter
  ): GymQrReviewsPayload!
  gymQrReviewsByAdminAuth(
    paging: PaginatorInput!
    params: GymQrReviewsFilter
  ): GymQrReviewsPayload!
  gymStudio(id: ID!): GymStudio!
  gymStudios(
    paging: PaginatorInput!
    params: GymStudioFilter
  ): GymStudioPayload!
  homeFeed(params: HomeFeedFilters!): HomeFeedPayload!
  offer(id: ID!): Offer!
  offers(paging: PaginatorInput!, params: OffersFilter): OffersPayload!
  getGymOffers(gymId: ID!): [Offer!]
  userQrSessionCount: UserQrSessionCountPayload!
  userQrSessions: UserQrSessionsPayload!
  checkQrSession(qrCode: String!): CheckQrSessionPayload!
  infoQrSession: InfoQrSessionPayload!
  checkQrSessionForPaymentToken: CheckQrSessionPayload!
  paymentTokenQrSession: PaymentTokenQrSessionPayload!
  checkDebt: InfoQrSessionPayload!
  paymentTokenDebt: PaymentTokenQrSessionPayload!
  qrSessionEndingJob: String
  video(id: ID!): Video!
  videos(paging: PaginatorInput!, params: VideosFilter): VideosPayload!
  authorizedVideos(
    paging: PaginatorInput!
    params: VideosFilter
  ): VideosPayload!
  getGymVideos(gymId: ID!): [VideoListView!]
  getGymVideosByCategory(gymId: ID!): GetGymVideosByCategoryPayload!
  getInstructorVideosByCategory(
    instructorId: ID!
  ): GetInstructorVideosByCategoryPayload!
  videoType(id: ID!): VideoType!
  videoTypes(
    paging: PaginatorInput!
    params: VideoTypesFilter
  ): VideoTypesPayload!
  videoSubTypes(
    paging: PaginatorInput!
    params: VideoTypesFilter
  ): VideoTypesPayload!
  videoParentTypes(
    paging: PaginatorInput!
    params: VideoTypesFilter
  ): VideoTypesPayload!
  workoutMachines(filter: WorkoutMachineFilter): [WorkoutMachine]
  favouriteGymClasses(
    paging: PaginatorInput
    params: GymClassesFilter
  ): FavouriteGymClassesPayload!
  servicesLimitTypes(name: String): EnumValuesPayLoad!
  membershipPlanTypes(name: String): EnumValuesPayLoad!
  classTypes(name: String): EnumValuesPayLoad!
  gymClass(id: ID!): GymClass!
  gymClasses(
    paging: PaginatorInput
    params: GymClassesFilter
  ): MobileGymClassesPayload!
  gymClassesV2(params: GymClassesFilterV2): GymClassesPayloadV2!
  gymClassInvoice(input: GymClassInvoiceInput!): GymClassInvoice!
  nearByGymClasses(
    paging: PaginatorInput
    params: NearByGymClassesFilters!
  ): MobileGymClassesPayload!
  nearByGymClassesV2(
    paging: PaginatorInput
    params: NearByGymClassesFiltersV2!
  ): MobileGymClassesPayload!
  socialGymClasses(
    paging: PaginatorInput
    params: SocialGymClassesFilters!
  ): SocialGymClassesPayload!
  gymClassDetail(id: ID!, params: GymClassDetailFilters!): GymClassListMobile
  membershipGymClasses(
    paging: PaginatorInput!
    params: MembershipGymClassesInput!
  ): MobileGymClassesPayload!
  membershipGymClassesFromAdmin(
    paging: PaginatorInput!
    params: MembershipGymClassesFromAdminInput!
  ): MobileGymClassesPayload!
  gymClassesByCategory(gymId: ID!): GymClassesByCategoryPayload!
  gymClassIsAlreadyBooked(
    gymClassId: ID!
    bookedFor: Date!
    bookedTime: LocalTime!
  ): SaveCustomerGymClassPayload!
  myGymClassesForCustomers(
    paging: PaginatorInput
  ): MyGymClassesForCustomersPayload!
  gymClassesScheduled(
    paging: PaginatorInput!
    params: GymClassesScheduledInput!
  ): MobileGymClassesPayload!
  gymClassesScheduledFromAdminPlatform(
    paging: PaginatorInput!
    params: GymClassesScheduledFromAdminPlatformInput!
  ): MobileGymClassesPayload!
  # Booked classes in a date range
  allBookedPTClassSessions(
    paging: PaginatorInput
    params: AllBookedPTClassSessionsParams!
  ): MobileGymClassesPayload!
  countAttendedClasses(params: CountAttendedClassesParams!): Int
  gymClassesCount(params: GymClassesCountParams!): Int!
  gymClassComment(id: ID!): GymClassComment
  customerCanCommentOnGymClass(
    gymClassId: ID!
  ): CustomerCanCommentOnGymClassPayload
  gymClassComments(
    paging: PaginatorInput!
    params: GymClassCommentsFilter
  ): GymClassCommentsPayload!
  gymClassGroupSechedule(id: ID!): GymClassScheduleGroup
  gymClassGroupSechedules(
    paging: PaginatorInput
    params: GymClassGroupSecheduleFilter
  ): GymClassesScheduleGroupPayload!
  gymClassV2(id: ID!): GymClassV2!
  gymClassesNewV2(
    paging: PaginatorInput
    params: GymClassesFilterV2
  ): GymClassesV2Payload!
  gymClassesListing(params: GymClassesListingFilter): GymClassesListingPayload!
  gymClassDetailV2(
    id: ID!
    params: GymClassDetailFiltersV2!
  ): GymClassListMobileV2
  gymClassesScheduledV2(
    paging: PaginatorInput!
    params: GymClassesScheduledInputV2!
  ): GymClassesScheduledPayload!
  gymClassesScheduledFromAdminPlatformV2(
    paging: PaginatorInput!
    params: GymClassesScheduledFromAdminPlatformInputV2!
  ): GymClassesScheduledPayload!
  gymClassesByCategoryV2(gymId: ID!): GymClassesByCategoryPayload!
  gymClassesCountV2(params: GymClassesCountParams!): Int!
  gymClassIsAlreadyBookedV2(
    scheduleId: ID!
    bookedFor: Date!
    bookedTime: LocalTime!
  ): SaveCustomerGymClassPayload!
  # Booked classes in a date range
  allBookedPTClassSessionsV2(
    paging: PaginatorInput
    params: AllBookedPTClassSessionsParamsV2!
  ): BookedGymClassesPayload!
  membershipGymClassesV2(
    paging: PaginatorInput!
    params: MembershipGymClassesInput!
  ): BookedGymClassesPayload!
  membershipGymClassesFromAdminV2(
    paging: PaginatorInput!
    params: MembershipGymClassesFromAdminInput!
  ): BookedGymClassesPayload!
  gymClassSechedule(gymClassId: ID!): [GymClassWeeklySchedule!]
  gymClassSecheduleV2(scheduleGroupId: ID!): [GymClassWeeklyScheduleV2!]
  gymClassCategory(
    id: ID!
    gymId: String
    gymIds: [String]
    shortDateRange: Boolean
  ): GymClassCategory!
  gymClassCategories(
    paging: PaginatorInput
    params: GymClassCategoryFilter
  ): GymClassCategoryPayload!
  gymClassBookingInvoice(params: BookingInvoiceParams!): BookingInvoicePayload!
  getBookedClassQRCode(
    params: BookedClassQRCodeParams!
  ): BookedClassQRCodePayload!
  isEligibleToBookGymClass(
    params: EligibleToBookGymClassParams!
  ): EligibleToBookGymClassPayload!
  gymClassBookingInvoiceV2(
    params: BookingInvoiceParamsV2!
  ): BookingInvoicePayload!
  getBookedClassQRCodeV2(
    params: BookedClassQRCodeParamsV2!
  ): BookedClassQRCodePayload!
  provisionClassBookingBlock: ProvisionClassBookingPayload!
  provisionClassBookingUnblock: ProvisionClassBookingPayload!
  classCommissionReport(
    paging: PaginatorInput!
    input: ClassReportInput
  ): ClassReportResponse
  classSubscriptionAndAttendanceReport(
    paging: PaginatorInput
    params: classSubscriptionAndAttendanceReportInput
  ): ClassSubscriptionAndAttendanceReportResponse
  classAttendanceReport(
    paging: PaginatorInput!
    input: ClassAttendanceReportInput
  ): ClassAttendanceReportResponse
  posStatus(name: String): EnumValuesPayLoad!
  posBrand(id: ID!): PosBrand!
  posBrands(paging: PaginatorInput!, params: PosBrandFilter): PosBrandPayload!
  posCategory(id: ID!): PosCategory!
  posCategories(
    paging: PaginatorInput!
    params: PosCategoryFilter
  ): PosCategoryPayload!
  posOrderListFromAdmin(
    paging: PaginatorInput!
    params: PosOrderListFromAdminParams
  ): PosOrderListFromAdminPayload!
  posOrderDetailFromAdmin(id: ID!): PosOrder
  posOrderInvoice(input: PosOrderInvoiceInput!): PosOrderInvoicePayload!
  posProduct(id: ID!): PosProduct
  posProducts(
    paging: PaginatorInput!
    params: PosProductFilter
  ): PosProductPayload!
  freeTrialAvailableSlots(
    gymId: ID!
    params: FreeTrialAvailableSlotsParams!
  ): FreeTrialAvailableSlotsPayload!
  elgibleForFreeTrial(gymId: ID!): ElgibleForFreeTrialPayload!
  elgibleForFreeTrialAdmin(
    gymId: ID!
    customerId: ID!
  ): ElgibleForFreeTrialPayload!
  freeTrialAvailableSlotsAdmin(
    gymId: ID!
    customerId: ID!
    params: FreeTrialAvailableSlotsAdminParams!
  ): FreeTrialAvailableSlotsPayload!
  freeTrialInfo(gymId: ID!): FreeTrialInfoPayload!
  freeTrialBookingsAdmin(
    paging: PaginatorInput!
  ): FreeTrialBookingsAdminPayload!
  freeTrialBookingsAdminV2(
    gymId: ID!
    customerId: ID!
    paging: PaginatorInput!
  ): FreeTrialBookingsAdminV2Payload!
  # Customer queries
  freeTrialBookingsMobile(
    paging: PaginatorInput!
  ): FreeTrialBookingsMobilePayload!
  # Customers queries
  freeTrialAlreadyAttended(
    input: FreeTrialAlreadyAttendedInput!
  ): FreeTrialAlreadyAttendedPayload!
  customerCardToken(id: ID!): CustomerCardToken
  getCustomerCardTokens(gymId: ID!): [CustomerCardToken]!
  getCustomerCardTokensFromAdmin(
    customerId: ID!
    gymId: ID!
    source: CustomerCardTokenSource
  ): [CustomerCardToken]!
  getCustomerCocs(params: CustomerCocInput!): [CustomerCoc]
  RevenueStreamHistoryInterval(name: String): EnumValuesPayLoad!
  passTypes(name: String): EnumValuesPayLoad!
  PaymentStatus(name: String): EnumValuesPayLoad!
  OrderStatus(name: String): EnumValuesPayLoad!
  paymentFrequencyTypes(name: String): EnumValuesPayLoad!
  orderTypes(name: String): EnumValuesPayLoad!
  getAllTransactionsForCustomer(
    paging: PaginatorInput!
    params: TransactionsFilters!
  ): GetAllTransactionsForCustomerPayload!
  getAllTransactionsForCustomerByAuth(
    paging: PaginatorInput!
    params: TransactionsFilters
  ): GetAllTransactionsForCustomerPayload!
  getPaymentMethods(countryCode: String!): [PaymentMethod]
  getPaymentMethodsFromAdmin(
    countryCode: String!
    customerId: ID!
    gymId: ID!
  ): [PaymentMethod!]
  getCheckoutComConfig: CheckoutComConfig!
  billingEfficiencyReport(
    params: BillingEfficiencyReportFilters!
  ): BillingEfficiencyReportType!
  billingEfficiencyReportCSV(
    params: BillingEfficiencyReportCSVFilters!
  ): BillingEfficiencyReportCSVType!
  revenueStreamReport(
    params: RevenueStreamReportFilters!
  ): RevenueStreamReportType!
  revenueStreamHistoryReport(
    params: RevenueStreamHistoryReportFilters!
  ): RevenueStreamHistoryReportType!
  notiTest: Boolean!
  membershipPlans(
    filter: GetMembershipPlansQueryFilter
  ): GetMembershipPlansQueryResponse
  singleMembershipPlan(
    filter: GetSingleMembershipPlanQueryFilter
  ): GetSingleMembershipPlanQueryResponse
  groupMembershipPlan(
    filter: GetGroupMembershipPlanQueryFilter
    paging: MembershipPagination
  ): GetGroupMembershipPlanQueryResponse
  sessionPackPlan(
    filter: GetSessionPackPlanQueryFilter
  ): GetSessionPackPlanQueryResponse
  membershipPlanGroups(
    filter: GetMembershipPlanGroupsQueryFilter
    pagination: MembershipPagination
  ): GetMembershipPlanGroupsQueryResponse
  membershipPlanGroupsV2(
    filter: GetMembershipPlanGroupsQueryFilterV2
    pagination: MembershipPagination
  ): GetMembershipPlanGroupsQueryResponseV2
  membershipPlanGroup(
    filter: GetMembershipPlanGroupQueryFilter
  ): GetMembershipPlanGroupQueryResponse
  singleMembershipPlans(
    filter: GetSingleMembershipPlansQueryFilter
    pagination: MembershipPagination
  ): GetSingleMembershipPlansQueryResponse
  groupMembershipPlans(
    filter: GetGroupMembershipPlansQueryFilter
    pagination: MembershipPagination
  ): GetGroupMembershipPlansQueryResponse
  sessionPackPlans(
    filter: GetSessionPackPlansQueryFilter
    pagination: MembershipPagination
  ): GetSessionPackPlansQueryResponse
  membership(filter: GetMembershipQueryFilter): GetMembershipQueryResponse
  memberships(filter: GetMembershipsQueryFilter): GetMembershipsQueryResponse
  paymentPlans(
    filter: GetPaymentPlansQueryFilter
    pagination: MembershipPagination
  ): GetPaymentPlansQueryResponse
  payments(
    filter: GetPaymentQueryFilter
    pagination: MembershipPagination
  ): GetPaymentQueryResponse
  gymQrSessions(
    filter: GetGymQrSessionsQueryFilter
    pagination: MembershipPagination
  ): GetGymQrSessionsQueryResponse
  gymQrSessionCount(
    filter: GetGymQrSessionCountQueryFilter
  ): GetGymQrSessionCountQueryResponse
  gymCheckinCountPerCustomer(
    filter: GetGymCheckinCountPerCustomerQueryFilter
  ): GetGymCheckinCountPerCustomerQueryResponse
  checkCardWithReccuringMemberships(
    input: CheckCardWithReccuringMembershipsInput
  ): CheckCardWithReccuringMembershipsResponse
  membershipDueAmount(
    filter: GetDueAmountQueryFilter
  ): GetDueAmountQueryResponse
  membershipDueAmountPerCustomer(
    filter: GetDueAmountPerCustomerQueryFilter
  ): GetDueAmountPerCustomerQueryResponse
  membershipDaysToRenew(
    filter: GetDaysToRenewQueryFilter
  ): GetDaysToRenewQueryResponse
  hasMembership(input: HasMembershipQueryArgs): HasMembershipQueryResponse
  hasMemberships(input: HasMembershipsQueryArgs): HasMembershipsQueryResponse
  leadMembership(input: LeadMembershipQueryArgs): LeadMembershipQueryResponse
  wasEverAMember(input: WasEverAMemberQueryArgs): WasEverAMemberQueryResponse
  getMembershipTerminateReasons: GetMembershipTerminateReasonsQueryResponse
  getMembershipCancellationReasons(
    filter: MembershipCancellationReasonsQueryFilter
  ): GetMembershipCancellationReasonsQueryResponse
  getMembershipFreezeReasons: GetMembershipFreezeReasonsQueryResponse
  getAvailableRefundAmount(
    filter: GetAvailableRefundAmountQueryFilter
  ): GetAvailableRefundAmountQueryResponse
  membershipActionRequests(
    filter: GetMembershipActionRequestsQueryFilter
    pagination: MembershipPagination!
  ): GetMembershipActionRequestsQueryResponse
  membershipActionRequestById(
    id: GetMembershipActionRequestByIdQueryFilter
  ): GetMembershipActionRequestByIdQueryResponse
  checkMembershipAction(input: CheckMembershipActionQueryFilter): PlainResponse
  getMembershipDescription(
    filter: GetMembershipDescriptionQueryFilter
  ): GetMembershipDescriptionQueryResponse
  getMembershipExtensionsForAdmin(
    filter: GetMembershipExtensionsForAdminQueryFilter
    paging: MembershipPagination
  ): GetMembershipExtensionsForAdminQueryResponse
  getMembershipExtensionDetailsForAdmin(
    filter: GetMembershipExtensionDetailsForAdminQueryFilter
  ): GetMembershipExtensionDetailsForAdminQueryResponse
  getMembershipFreezesForAdmin(
    filter: GetMembershipFreezesForAdminQueryFilter
    paging: MembershipPagination
  ): GetMembershipFreezesForAdminQueryResponse
  getMembershipFreezeDetailsForAdmin(
    filter: GetMembershipFreezeDetailsForAdminQueryFilter
  ): GetMembershipFreezeDetailsForAdminQueryResponse
  getMembershipFreezeTypes(
    filter: GetMembershipFreezeTypesQueryFilter
    paging: MembershipPagination
  ): GetMembershipFreezeTypesQueryResponse
  getMembershipFreezeType(
    filter: GetMembershipFreezeTypeQueryFilter
  ): GetMembershipFreezeTypeQueryResponse
  getMembershipCount(
    filter: GetMembershipCountsQueryFilter
  ): GetMembershipCountQueryResponse
  getMembershipWithFilter(
    filter: GetMembershipsWithtypeFilterQueryFilter
    paging: MembershipPagination
  ): GetMembershipsWithFilterQueryResponse
  invoiceChangeMembership(
    input: InvoiceChangeMembershipQueryInput
  ): InvoiceChangeMembershipResponse
  estimateCancelRefund(
    input: EstimateCancelRefundQueryArgs
  ): EstimateCancelRefundQueryResponse
  topMembers(filter: getTopMembersQueryFilters): topMembersQueryResponse
  topMembersCsv(
    filter: getTopMembersCsvQueryFilters
  ): topMembersCsvQueryResponse
  avergeMembershipFees(
    filter: getAvergeMembershipFeeQueryFilters
  ): avergeMembershipFeeQueryResponse
  membersStatuses(
    filter: getMembersStatusesQueryFilters
  ): membersStatusesQueryResponse
  membersStatusesCsv(
    filter: getMembersStatusesCsvQueryFilters
  ): membersStatusesCsvQueryResponse
  membershipAgeRange(
    filter: getMembershipAgeRangeQueryFilters
  ): membershipAgeRangeQueryResponse
  membershipCancellationReport(
    filter: getMembershipCancellationReportQueryFilters
  ): membershipCancellationReportQueryResponse
  membersGymCheckInReport(
    filter: getMembersGymCheckInReportQueryFilters
  ): membersGymCheckInReportQueryResponse
  membersGymCheckInCsvReport(
    filter: getMembersGymCheckInCsvReportQueryFilters
  ): membersGymCheckInCsvReportQueryResponse
  liveMembersReport(
    filter: getLiveMembersReportQueryFilters
  ): liveMembersReportQueryResponse
  futureContractEndingReport(
    filter: getFutureContractEndingReportQueryFilters
  ): futureContractEndingReportQueryResponse
  futureContractEndingCsvReport(
    filter: getFutureContractEndingCsvReportQueryFilters
  ): futureContractEndingCsvReportQueryResponse
  futureContractEndingCsvReportV2(
    filter: getFutureContractEndingCsvReportQueryFiltersV2
  ): futureContractEndingCsvReportQueryResponseV2
  membershipNetGainReport(
    filter: getMembershipNetGainReportQueryFilters
  ): membershipNetGainReportQueryResponse
  memberActivityReport(
    filter: getMemberActivityReportQueryFilters
  ): memberActivityReportQueryResponse
  memberActivityCsvReport(
    filter: getMemberActivityCsvReportQueryFilters
  ): memberActivityCsvReportQueryResponse
  getDailySalesReport(
    filter: GetDailySalesReportFilter
    pagination: MembershipPagination
  ): GetDailySalesReportResponse
  GenderEnum(name: String!): MemEnumValuesPayLoad
  MembershipPlanTypePeriod(name: String!): MemEnumValuesPayLoad
  PaymentTypeEnum(name: String!): MemEnumValuesPayLoad
  PaymentRecursionTypeEnum(name: String!): MemEnumValuesPayLoad
  qtyRevType(name: String!): MemEnumValuesPayLoad
  IntervalType(name: String!): MemEnumValuesPayLoad
  PTIntervalType(name: String): EnumValuesPayLoad!
  serviceTypes(name: String): EnumValuesPayLoad!
  instructor(id: ID!): Instructor
  instructorById(id: ID!): Instructor
  instructorByEmail(email: String!): Instructor
  instructors(
    paging: PaginatorInput
    params: InstructorsFilter
  ): InstructorsPayload!
  authorizedInstructors(
    paging: PaginatorInput
    params: InstructorsFilter
  ): InstructorsPayload!
  privateCoaches(
    countryId: ID!
    paging: PaginatorInput
    params: InstructorsFilter
  ): PrivateCoachesPayload!
  privateCoachInvoice(input: PrivateCoachInvoiceInput!): PrivateCoachInvoice!
  instructorAvailableSessions(
    instructorId: ID!
    forDate: Date!
    timeZoneIdentifier: String
  ): InstructorSessionPayload!
  instructorFavouriteInstructors(
    instructorId: ID!
  ): InstructorFavouriteInstructorsPayload
  instructorListOfClients(
    paging: PaginatorInput
    instructorId: ID!
  ): InstructorListOfClients!
  nearByPersonalTrainers(
    paging: PaginatorInput
    params: PTParams!
  ): InstructorLightPayload
  getInstructorsBySessionContract(
    params: InstructorParams
  ): InstructorLightPayload!
  instructorComment(id: ID!): InstructorComment
  customerCanCommentOnInstructor(
    instructorId: ID!
  ): CustomerCanCommentOnInstructorPayload
  instructorCommentsByCustomerAuth(
    paging: PaginatorInput!
    params: InstructorCommentsFilter
  ): InstructorCommentsPayload!
  instructorAllReviews(
    paging: PaginatorInput!
    params: InstructorAllReviewsFilter!
  ): InstructorCommentsPayload!
  favouriteInstructorByAuth(
    paging: PaginatorInput
    params: FavouriteInstructorParams
  ): InstructorFavouriteInstructorsPayload
  customerFavouriteInstructors(
    paging: PaginatorInput
  ): CustomerFavouriteInstructorsPayload
  instructorGallery(id: ID!): InstructorGallery!
  instructorGalleries(
    paging: PaginatorInput!
    params: InstructorGallerysFilter
  ): InstructorGallerysPayload!
  instructorGalleryByCategory(
    params: InstructorGalleryByCategoryParams!
  ): InstructorGalleryNyCategoryPayload!
  instructorSessions(instructorId: ID!): [InstructorSession!]
  instructorSpecialities(
    filter: InstructorSpecialityFilter
  ): [InstructorSpeciality]
  instructorGalleryCategories(
    params: InstructorGalleryCategoriesFilter
  ): InstructorGalleryCategoriesPayload!
  instructorBookedSessions(
    instructorId: ID!
    forDate: Date!
    timeZoneIdentifier: String
  ): InstructorBookedSessionPayload!
  instructorBookedSessionsByAuth(
    instructorId: ID!
    serviceId: ID!
  ): InstructorBookedSessionPayload!
  customerAllBookedSessionsByAuth(
    paging: PaginatorInput
  ): InstructorBookedSessionPayload!
  customerSessionsWithInstructor(
    paging: PaginatorInput
    params: CustomerSessionsWithInstructorParams!
  ): InstructorBookedSessionPayload!
  singleBookedPTSession(bookingId: ID!): OrderPrivateCoachSession
  allBookedPTSessions(
    paging: PaginatorInput
    params: AllBookedPTSessionsParams!
  ): InstructorBookedSessionPayload!
  sessionContractBookings(
    paging: PaginatorInput!
    params: SessionContractBookingsParams!
  ): InstructorBookedSessionPayload!
  countAttendedPTSessions(params: CountAttendedPTSessionsParams!): Int
  bookedPTSessionsCount(params: BookedPTSessionsCountParams!): Int!
  ptBookingDetails(
    paging: PaginatorInput
    params: PTBookingDetailsFilter
  ): PTBookingDetailsPayload!
  PTSessionReport(params: PTSessionReportFilters!): PTSessionReportPayload!
  PTSessionReportV2(
    paging: PaginatorInput
    params: PTSessionReportV2Filters!
  ): PTSessionReportV2Payload!
  PTAttendanceReport(
    paging: PaginatorInput
    params: PTAttendanceReportFilters!
  ): PTAttendanceReportPayload!
  service(id: ID!): Service!
  services(paging: PaginatorInput, params: ServiceFilter): ServicePayload!
  serviceCategory(id: ID!): ServiceCategory!
  serviceCategories(
    paging: PaginatorInput
    params: ServiceCategoryFilter
  ): ServiceCategoryPayload!
  serviceSubCategory(id: ID!): ServiceSubCategory!
  serviceSubCategories(
    paging: PaginatorInput
    params: ServiceSubCategoryFilter
  ): ServiceSubCategoryPayload!
  sessionContract(id: ID!): SessionContract!
  sessionContractCapacityStatus(id: ID!): SessionContractCapacityStatusPayload!
  sessionContracts(
    paging: PaginatorInput
    params: SessionContractFilter
  ): SessionContractPayload!
  sessionContractByAuth(
    paging: PaginatorInput
    params: SessionContractFilter
  ): SessionContractPayload!
  sessionContractCount(type: CountType!): SessionContractsCountsPayload!
  allSessionContracts(
    params: AllSessionContractFilter
  ): AllSessionContractPayload
  fileQueryTest: Boolean
  fmTimeInterval(name: String): EnumValuesPayLoad!
  file(id: ID!): File
  files(paging: PaginatorInput!, params: FileFilter): FilePayload!
  filesByIds(ids: [ID]!): [File]!
  fileCategory(id: ID!): FileCategory
  fileCategories(
    paging: PaginatorInput
    params: FileCategoryFilter
  ): FileCategoryPayload!
  fileCategoriesByIds(ids: [ID]!): [FileCategory]!
  event(input: GetAnEventInput): SingleEvent
  events(input: PagedEventInput): PagedEvents
  userEvents(input: PagedUserEventsInput): PagedUserEvents
  userEventPurchases(
    input: GetUserEventPurchasesInput
    pagination: EventPagination
  ): UserEventPurchases
  userEventReviews(
    input: GetUserEventReviewsInput
    pagination: EventPagination
  ): PagedUserEventReviews
  eventCount(input: EventFilterInput): EventCount
  likedEvents(
    input: GetUserLikedEventsInput
    pagination: EventPagination
  ): PagedUserLikedEvents
  getAllEventReviews(
    input: GetUserEventReviewsInput
    pagination: EventPagination!
  ): PagedAllEventReviews
  eventsMobileList(input: PagedEventsMobileListInput): PagedEventsMobileList
  accountDeletionRequest(id: ID!): AccountDeletionRequest
  accountDeletionRequests(
    paging: PaginatorInput!
    params: AccountDeletionRequestsFilter
  ): AccountDeletionRequestsPayload!
  getBulkEmailsList(
    paging: PaginatorInput!
    params: GetBulkEmailsListFilter
  ): GetBulkEmailsListPayload!
  getBulkNotificationsList(
    paging: PaginatorInput!
    params: GetBulkNotificationsListFilter
  ): GetBulkNotificationsListPayload!
  customer(id: ID!): Customer
  customerByEmail(email: String!): Customer
  customers(paging: PaginatorInput!, params: CustomersFilter): CustomersPayload!
  # Lookup a customer by the currently logged in user id
  customerByAuth: Customer
  userByAuth: UserDetailPayload!
  userSlotsByAuth(params: UserSlotsByAuthFilters): UserSlotsByAuthPayload!
  userSlotsByAuthWithMembership(
    params: UserSlotsByAuthFilters
  ): UserSlotsByAuthPayload!
  customerTermsConditions(customerId: ID!): CustomerTermsConditions
  sendEmailVerification(
    email: String!
    xAppSource: String!
  ): SendVerificationEmailResponse
  customerAddress(id: ID!): CustomerAddress
  customerDefaultAddress: CustomerAddress
  customerAddresses(
    paging: PaginatorInput!
    params: CustomerAddressFilter
  ): CustomerAddressPayload!
  favoriteGymBuddiesByFavoriterId(
    paging: PaginatorInput!
    params: FavoriteGymBuddiesFilter
  ): FavoriteGymBuddiesPayload!
  genderTypes(name: String): EnumValuesPayLoad!
  genderTypesV2(name: String): EnumValuesPayLoad!
  statusTypes(name: String): EnumValuesPayLoad!
  contentTypesEnum(name: String): EnumValuesPayLoad!
  elementTypes(name: String): EnumValuesPayLoad!
  CompanyIndustry(name: String): EnumValuesPayLoad!
  getGuestUserById(id: ID!): GetGuestUserByIdPayload
  getAllGuestsList(paging: PaginatorInput!): GetAllGuestsListPayload
  gymBuddyWithCustomerId(customerId: ID!, location: GISLocationInput): GymBuddy
  gymBuddy(id: ID!): GymBuddy
  gymBuddies(
    paging: PaginatorInput!
    params: GymBuddiesFilter
  ): GymBuddiesPayload!
  gymBuddiesMobile(
    paging: PaginatorInput!
    params: GymBuddiesFilter
  ): GymBuddiesMobilePayload!
  favouriteGymBuddiesByAuth(
    paging: PaginatorInput!
    params: FavouriteGymBuddiesByAuthParams
  ): GymBuddiesPayload!
  favouriteGymBuddiesByCustomerId(
    paging: PaginatorInput!
    params: FavoriteGymBuddyFilter!
  ): GymBuddiesPayload!
  suggestedPeopleByCustomerId(
    paging: PaginatorInput!
    params: FavoriteGymBuddyFilter!
  ): GymBuddiesPayload!
  gymBuddiesFollowingCustomer(
    paging: PaginatorInput!
    params: FavoriteGymBuddyFilter!
  ): GymBuddiesPayload!
  gymBuddiesFollowedByCustomer(
    paging: PaginatorInput!
    params: FavoriteGymBuddyFilter!
  ): GymBuddiesPayload!
  lead(id: ID!): Lead
  leads(paging: PaginatorInput, params: LeadsFilter): LeadsPayload!
  fetchLeads(paging: PaginatorInput, params: FetchLeadsFilter): LeadsPayload!
  fetchLeadsV2(
    paging: PaginatorInput
    params: FetchLeadsFilterV2
  ): LeadsPayloadV2!
  fetchMembers(
    paging: PaginatorInput
    params: FetchMembersFilter
  ): MembersPayload!
  leadCustomers(paging: PaginatorInput!, params: LeadsFilter): CustomersPayload!
  leadCustomersWithSubAccounts(
    paging: PaginatorInput
    params: LeadsFilter
  ): CustomersPayload!
  leadSubCustomers(
    paging: PaginatorInput
    params: LeadSubCustomersFilters!
  ): CustomersPayload!
  leadSearchPerPhone(
    phoneNumber: String!
    leadCreatedById: ID
  ): leadSearchPerPhonePayload
  allupProLead(id: ID!): AllupProLead
  allupProLeads(
    paging: PaginatorInput
    params: AllupProLeadsFilter
  ): AllupProLeadsPayload!
  allupProLeadStats(gymId: ID): AllupProLeadStats!
  birthdayLeadsPro(paging: PaginatorInput, gymId: ID): AllupProLeadsPayload!
  activeLeadsPro(paging: PaginatorInput, gymId: ID): AllupProLeadsPayload!
  recurringActiveLeadsPro(
    paging: PaginatorInput
    gymId: ID
  ): AllupProLeadsPayload!
  addedLastWeekLeadsPro(
    paging: PaginatorInput
    gymId: ID
  ): AllupProLeadsPayload!
  addedLastMonthLeadsPro(
    paging: PaginatorInput
    gymId: ID
  ): AllupProLeadsPayload!
  expiresWithinAWeekLeadsPro(
    paging: PaginatorInput
    gymId: ID
  ): AllupProLeadsPayload!
  leadCount(type: CountType!): DashboardCountsPayload!
  leadByCustomerId(params: leadByCustomerIdParams): Lead
  referees(paging: PaginatorInput!, params: RefereesFilter): RefereesPayload
  leadAppointment(id: ID!): LeadAppointment
  leadAppointments(
    paging: PaginatorInput!
    params: LeadAppointmentsFilter
  ): LeadAppointmentsPayload!
  countLeadAppointments(type: CountType!): LeadAppointmentsCount!
  leadCall(id: ID!): LeadCall
  leadCalls(paging: PaginatorInput!, params: LeadCallsFilter): LeadCallsPayload!
  leadCallCount(type: CountType!): DashboardCountsPayload!
  leadCompany(id: ID!): LeadCompany
  leadCompanies(
    paging: PaginatorInput!
    params: LeadCompaniesFilter
  ): LeadCompaniesPayload!
  leadContact(id: ID!): LeadContact
  leadContacts(
    paging: PaginatorInput!
    params: LeadContactsFilter
  ): LeadContactsPayload!
  leadEmail(id: ID!): LeadEmail
  leadEmails(
    paging: PaginatorInput!
    params: LeadEmailsFilter
  ): LeadEmailsPayload!
  leadFollowUps(
    paging: PaginatorInput!
    params: FollowUpsFilter
  ): FollowUpsPayload!
  leadNote(id: ID!): LeadNote
  leadNotes(paging: PaginatorInput!, params: LeadNotesFilter): LeadNotesPayload!
  leadNotification(id: ID!): LeadNotification
  leadNotifications(
    paging: PaginatorInput!
    params: LeadNotificationsFilter
  ): LeadNotificationsPayload!
  listMessagesPerUser(
    paging: PaginatorInput!
    customerId: ID
    gymId: ID
  ): ListMessagesPerUserPayload!
  countUnseenMessages(customerId: ID, gymId: ID): Int
  groupNotifications(paging: PaginatorInput!): GroupNotificationsPayload
  groupNotification(id: ID!): GroupNotification
  individualNotifications(
    paging: PaginatorInput!
  ): IndividualNotificationsPayload
  individualNotification(id: ID!): IndividualNotification
  leadTask(id: ID!): LeadTask
  leadTasks(paging: PaginatorInput!, params: LeadTasksFilter): LeadTasksPayload!
  leadTimelines(
    paging: PaginatorInput!
    params: LeadTimelinesFilter
  ): LeadTimelinesPayload!
  linkedAccount(id: ID!): LinkedAccount
  linkedAccounts(
    paging: PaginatorInput!
    params: LinkedAccountsFilter
  ): LinkedAccountsPayload!
  userDeviceReport(params: UserDeviceReportFilters!): UserDeviceReportPaylad!
  leadConversionReport(
    paging: PaginatorInput
    params: LeadConversionReportInput
  ): LeadConversionReportPayload!
  allWhiteListedPhoneNumbers(
    paging: PaginatorInput
    params: AllWhiteListedPhoneNumbersInput
  ): AllWhiteListedNumberPayload
  getAllTransactions(
    paging: PaginatorInput
    params: TransactionFilter
  ): TransactionsPayload!
  getUserTransactions(
    paging: PaginatorInput
    pin: String!
  ): TransactionsPayload!
  getUserDetails(pin: String!): ZkUserDetailPayload
  contentElement(id: ID!): ContentElement
  contentElements(
    paging: PaginatorInput!
    params: ContentElementsFilter
  ): ContentElementsPayload
  getMedicalForm: [ContentGroup!]!
  contentElementValue(id: ID!): ContentElementValue
  contentElementValues(
    paging: PaginatorInput!
    params: ContentElementValuesFilter
  ): ContentElementValuesPayload
  contentGroup(id: ID!): ContentGroup
  contentGroups(
    paging: PaginatorInput!
    params: ContentGroupsFilter
  ): ContentGroupsPayload
  contentType(id: ID!): ContentType
  contentTypes(
    paging: PaginatorInput!
    params: ContentTypesFilter
  ): ContentTypesPayload
  court(id: ID!): Court
  courtCustom(id: ID!): Court
  courts(paging: PaginatorInput!, params: CourtsFilter): CourtsPayload!
  # Customer Queries
  courtDetailMobile(id: ID!, params: CourtDetailMobileParams!): Court!
  courtListMobile(
    paging: PaginatorInput!
    params: CourtListMobileParams!
  ): CourtListMobilePayload!
  courtAmenity(id: ID!): CourtAmenity!
  courtAmenities(
    paging: PaginatorInput!
    params: CourtAmenityFilter
  ): CourtAmenityPayload!
  courtCategory(id: ID!): CourtCategory!
  courtCategories(
    paging: PaginatorInput!
    params: CourtCategoryFilter
  ): CourtCategoryPayload!
  courtComment(id: ID!): CourtComment
  courtComments(
    paging: PaginatorInput!
    params: CourtCommentsFilter!
  ): CourtCommentsPayload!
  courtAvailablity(
    courtId: ID!
    params: CourtAvailablityFilter!
  ): [AvailableSlots!]
  courtStatuses(name: String): EnumValuesPayLoad!
  configStatuses(name: String): EnumValuesPayLoad!
  courtBookings(
    paging: PaginatorInput!
    params: CourtBookingParams
  ): CourtBookingsMobilePayload!
  # Customer Queries
  courtBookingsMobile(paging: PaginatorInput!): CourtBookingsMobilePayload!
  courtInvitationsMobile(paging: PaginatorInput!): CourtBookingsMobilePayload!
  courtInvitationsCountMobile: CourtInvitationsCountMobilePayload!
  addressFields(
    paging: PaginatorInput
    filter: AddressFieldFilter
  ): AddressFieldPayload!
  addressField(id: ID!): AddressField!
  configurations(
    paging: PaginatorInput
    filter: ConfigurationFilter
  ): ConfigurationPayload!
  dynamicProperties: [DynamicPropertyPair!]
  configuration(id: ID!): Configuration!
  configurationByKey(key: String!): Configuration
  countries(paging: PaginatorInput, filter: CountryFilter): CountriesPayload!
  nationalities: [NationalityList!]
  country(id: ID!): Country
  countriesById(ids: [ID!]!): [Country]
  city(id: ID!): CountryCity
  citiesByStateId(id: ID!): [CountryCity]
  citiesByCountryId(id: ID!): [CountryCity]
  state(id: ID!): CountryState
  statesByCountryId(id: ID!): [CountryState]
  roleTypesEnum(name: String): EnumValuesPayLoad!
  homeScreen(id: ID!): HomeScreen
  homeScreenByCountryId(countryId: ID!): HomeScreen
  languages(paging: PaginatorInput!, filter: LanguageFilter): LanguagesPayload!
  language(id: ID!): Language!
  languageCountry(id: ID!): LanguageCountry
  languageCountries(
    paging: PaginatorInput!
    filter: LanguageCountriessFilter
  ): LanguageCountriessPayload!
  measureUnits(
    paging: PaginatorInput!
    filter: MeasureUnitFilter
  ): MeasureUnitsPayload!
  measureUnit(id: ID!): MeasureUnit!
  permission(id: ID!): Permission
  permissions(
    paging: PaginatorInput!
    params: PermissionsFilter
  ): PermissionsPayload!
  role(id: ID!): Role
  roles(paging: PaginatorInput!, params: RolesFilter): RolesPayload!
  rolePermission(id: ID!): RolePermission
  rolePermissions(
    paging: PaginatorInput!
    params: RolePermissionsFilter
  ): RolePermissionsPayload!
  activeTermsConditions: TermsConditions
  getTermsConditions(id: ID!): TermsConditions
  allTermsConditions(
    paging: PaginatorInput!
    params: TermsConditionssFilter
  ): TermsConditionssPayload!
}

input RadiusFilter {
  # User's current location
  location: GISLocationInput!
  # Search Radius
  radius: Float!
}

input RateGymClassInput {
  gymClassId: ID!
  bookedFor: Date!
  bookedTime: LocalTime!
  score: Float!
}

type RateGymClassPayload {
  success: Boolean
  error: GymClassCommentErrors
  errors: [GymClassCommentErrors!]
  errorMessage: String
}

input RateInstructorSessionInput {
  customerPrivateCoachSessionId: ID!
  ratingScore: Float!
}

type RateInstructorSessionPayload {
  success: Boolean
  errorMessage: String
  error: OrderPrivateCoachSessionError
  errors: [OrderPrivateCoachSessionError!]
}

input RatingInput {
  accessToGym: Int!
  qualityOfService: Int!
  hygiene: Int!
}

type RatingType {
  accessToGym: Int
  qualityOfService: Int
  hygiene: Int
}

type RatingTypes {
  type: String!
  score: Float!
}

input RatingTypesInput {
  type: String!
  score: Float!
}

type reasonType {
  key: String!
  description: String!
}

input RefereesFilter {
  searchText: String
  leadReferalStatus: LeadReferalStatus
  refererId: ID
  gymId: ID
  gender: CustomerGenderType
  startDate: Date
  endDate: Date
}

type RefereesPayload {
  list: [Lead]
  paging: PaginatorOutputUpdated
  errorMessage: String
  error: ReferFriendError
  errors: [ReferFriendError]
}

enum ReferFriendError {
  INVALID_LEAD
  ALREADY_A_MEMBER
  ALREADY_REFERED
  UNAUTHORIZED
  NOT_ALLOWED
  INTERNAL_SERVER_ERROR
}

input ReferFriendInput {
  firstName: String
  lastName: String
  email: String
  phoneNumber: String!
  gender: CustomerGenderType
}

type ReferFriendPayload {
  success: Boolean
  errorMessage: String
  error: ReferFriendError
  errors: [ReferFriendError]
}

enum RefundType {
  NO_REFUND
  FULL_REFUND
  CUSTOM
}

input RegenerateGymClassQrCodeInput {
  id: ID
}

input RegisterCustomerInput {
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  contactNumber: String!
  gender: CustomerGenderType
  countryId: ID!
  isEmailVerified: Boolean
  isPhoneVerified: Boolean!
  accessedByMobile: Boolean
  photo: String
  authId: String
  isParent: Boolean
  isLinkedAccount: Boolean
  leadId: ID
  linkedAccountId: ID
  parentCustomerId: ID
  linkedCustomers: [ID]
}

type RegisterCustomerPayload {
  customer: Customer
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

input RegisteredDeviceInput {
  userId: String!
  registeredDeviceCode: String!
  userApplication: ApplicationEnum!
  userOS: UserOSEnum!
  isAnonymous: Boolean
}

type RegisteredDevicePayload {
  status: Boolean
  error: FBRegisteredDeviceError
  errorMessage: String
}

input RegisterInstructorInput {
  firstName: String!
  lastName: String
  description: String
  email: String!
  contactNumber: String!
  gender: GlobalGenderType!
  brandId: ID!
  gymId: ID!
  photo: String!
  coverPhoto: String
  status: GlobalStatusType!
  services: [ID!]
  perSessionAmount: CurrencyValue!
  privateCoach: Boolean
  sessions: [InstructorSessionInput!]
  socialMediaReferences: [SocialMediaReferenceInput!]
  specialities: [ID!]
  certifications: [String!]
  # The longitude component of the geo coordinates for this inst, in degrees
  longitude: Float!
  # The longitude component of the geo coordinates for this inst, in degrees
  latitude: Float!
  serviceRange: Float!
}

type RegisterInstructorPayload {
  instructor: Instructor
  password: String
  error: InstructorError
  errors: [InstructorError!]
  errorMessage: String
}

input RejectMembershipRequestMutationInput {
  requestId: ID!
  type: MembershipActionRequestTypeEnum!
  note: String
}

type relocateMembership {
  membershipId: ID
  membershipType: String
  paymentUrl: String
}

input RelocateMembershipMutationInput {
  singleMembershipId: ID
  singleMembershipPlanId: ID
  groupMembershipId: ID
  groupMembershipPlanId: ID
  cocCardId: ID
  sessionPackId: ID
  sessionPackPlanId: ID
  paymentPlanId: ID
  gymId: ID!
  amount: Float
  paymentMethod: MembershipPaymentMethod!
  startDate: String
  adminId: ID
  note: String
  servicePacks: [RelocateMembershipServicePackInput]
}

type RelocateMembershipResponse {
  data: relocateMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input RelocateMembershipServicePackInput {
  userServicePackId: ID!
  serviceId: ID!
}

input RemoveFollowerGymBuddyInput {
  followerGymBuddyId: ID!
}

input ReportInput {
  description: String!
  type: ReportType!
  sessionId: ID
}

enum ReportType {
  ISNT_WORKING
  GENERAL_FEEDBACK
  PAYMENT_ISSUE
  QR_ISSUE
  OTHER
}

type ResendInviteEmailPayload {
  success: Boolean
  errorMessage: String
  error: ReferFriendError
  errors: [ReferFriendError]
}

type ReserveAnEvent {
  data: EventPurchase
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

input ReserveAnEventInput {
  eventId: ID!
  count: Int!
}

input ResetAdminPassInput {
  id: ID
}

type ResponseStatus {
  success: Boolean!
  error: String
}

type ResultWhiteListedNumberPayload {
  status: Boolean
  errorMessage: String
}

enum RevenueStreamHistoryInterval {
  DAILY
  MONTHLY
}

enum RevenueStreamHistoryOrderType {
  ALL
  PRIVATE_COACH
  MEMBERSHIP
  POS
  GYM_CLASS
}

input RevenueStreamHistoryReportFilters {
  countryId: ID!
  gymIds: [ID!]
  interval: RevenueStreamHistoryInterval!
  orderType: RevenueStreamHistoryOrderType!
}

type RevenueStreamHistoryReportType {
  list: [RevenueStreamHistoryReportTypeNode!]
}

type RevenueStreamHistoryReportTypeNode {
  total: String!
  groupBy: CurrencyValue!
}

input RevenueStreamReportFilters {
  countryId: ID!
  gymIds: [ID!]
}

type RevenueStreamReportMonthNode {
  memberships: CurrencyValue!
  pos: CurrencyValue!
  ptSessions: CurrencyValue!
  classes: CurrencyValue!
}

type RevenueStreamReportType {
  currentMonth: RevenueStreamReportMonthNode!
  lastMonth: RevenueStreamReportMonthNode!
}

# Role
type Role {
  id: ID!
  name: String!
  description: String
  status: StatusType!
  roleType: RoleType!
  permissions: [Permission]
  createdById: ID
  lastUpdatedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum RoleError {
  DUPLICATE_NAME
  INVALID_ID
  NOT_EDITABLE
}

# RolePermission
type RolePermission {
  id: ID!
  role: Role!
  permission: Permission!
  createdById: ID
  lastUpdatedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum RolePermissionError {
  DUPLICATE_PERMISSION
  INVALID_ID
}

input RolePermissionsFilter {
  searchText: String
  roleId: ID
  permissionId: ID
}

type RolePermissionsPayload {
  list: [RolePermission]
  paging: PaginatorOutput
}

input RolesFilter {
  searchText: String
  status: StatusType
}

type RolesPayload {
  list: [Role]
  paging: PaginatorOutputUpdated
}

enum RoleType {
  ALLUP
  SAAS
  VENDOR_PORTAL
}

input RollbackImportedLeadsInput {
  batchNo: String
}

input RulesInput {
  heading: String!
  description: String!
}

type RulesPayload {
  heading: String!
  description: String!
}

type SalesBy {
  id: ID!
  firstName: String
  lastName: String
  fullName: String
  photo: String
  email: String
}

enum SalesByType {
  CUSTOMER
  ADMIN
}

type SaveAccountDeletionRequestPayload {
  call: LeadCall
  error: FollowUpError
  errors: [FollowUpError]
  errorMessage: String
}

type SaveAddressFieldPayload {
  addressField: AddressField
  error: AddressFieldError
  errors: [AddressFieldError!]
}

input SaveAdminInput {
  id: ID
  firstName: String!
  lastName: String!
  email: String!
  contactNumber: String
  overwrite: Boolean
  gender: GlobalGenderType
  status: GlobalStatusType!
  roles: [String!]
  adminType: AdminType!
  referenceTypeId: ID
  isSysAdmin: Boolean
}

type SaveAdminPayload {
  admin: Admin
  password: String
  error: AdminError
  errors: [AdminError!]
  errorMessage: String
}

input SaveAdminPhotoInput {
  id: ID!
  photo: String!
}

input SaveAdminV2Input {
  id: ID
  firstName: String!
  lastName: String!
  email: String!
  contactNumber: String
  overwrite: Boolean
  gender: GlobalGenderType
  status: GlobalStatusType!
  roles: [String!]
  adminType: AdminType!
  referenceTypeId: [ID]
  isSysAdmin: Boolean
}

type SaveAmenityPayload {
  amenity: Amenity
  error: AmenityError
  errors: [AmenityError!]
  errorMessage: String
}

input SaveBrandAdminInput {
  id: ID
  brandId: ID!
  adminId: ID!
}

type SaveBrandAdminPayload {
  brandAdmin: BrandAdmin
  error: BrandAdminError
  errors: [BrandAdminError!]
}

type SaveBrandAdminTablePayload {
  updated: Boolean
  error: BrandAdminError
  errors: [BrandAdminError!]
}

input SaveBrandInput {
  id: ID
  name: String!
  email: String!
  logo: String!
  image: String
  legalName: String!
  phone: String!
  street: String!
  unitNumber: String!
  city: String!
  zipCode: String
  status: BrandStatus!
  countryId: ID!
  state: String!
  adminIds: [ID!]
}

type SaveBrandPayload {
  brand: Brand
  errorMessage: String
  error: BrandError
  errors: [BrandError!]
}

input SaveBrandsAdminsTableInput {
  adminId: ID!
}

input SaveBrandStatusInput {
  id: ID!
  status: BrandStatus!
}

input SaveCityPerCountryInput {
  id: ID
  name: String!
}

input SaveCommentInput {
  description: String
}

type SaveCommentPayload {
  comment: Comment
  error: CommentError
  errors: [CommentError!]
}

type SaveConfigurationPayload {
  configuration: Configuration
  error: ConfigurationError
  errors: [ConfigurationError!]
}

input SaveContentElementInput {
  id: ID
  reference: String!
  type: ContentElementType!
  options: [ContentElementDataOptionInput]
  data: ContentElementDataInput
  contentTypeId: ID!
  contentGroupId: ID!
  status: GlobalStatusType!
}

type SaveContentElementPayload {
  contentElement: ContentElement
  error: ContentElementError
  errors: [ContentElementError!]
}

input SaveContentElementValueInput {
  id: ID
  customerId: ID!
  contentElementId: ID!
  fieldValue: String!
}

type SaveContentElementValuePayload {
  contentElementValue: ContentElementValue
  error: ContentElementValueError
  errors: [ContentElementValueError!]
}

input SaveContentGroupInput {
  id: ID
  name: String!
  description: String
  contentTypeId: ID!
  status: GlobalStatusType!
}

type SaveContentGroupPayload {
  contentGroup: ContentGroup
  error: ContentGroupError
  errors: [ContentGroupError!]
}

input SaveContentTypeInput {
  id: ID
  type: ContentTypes!
  status: GlobalStatusType!
}

type SaveContentTypePayload {
  contentType: ContentType
  error: ContentTypeError
  errors: [ContentTypeError!]
}

input SaveCountryCityInput {
  id: ID
  name: String!
  countryId: ID!
  stateId: ID!
}

type SaveCountryCityPayload {
  city: CountryCity
  error: CountryCityError
  errors: [CountryCityError!]
  errorMessage: String
}

type SaveCountryPayload {
  country: Country
  error: CountryError
  errors: [CountryError]
  errorMessage: String
}

input SaveCountryStateInput {
  id: ID
  name: String!
  countryId: ID!
  isCapital: Boolean
}

type SaveCountryStatePayload {
  state: CountryState
  error: CountryStateError
  errors: [CountryStateError!]
  errorMessage: String
}

input SaveCourtAmenityInput {
  id: ID
  name: String!
  description: String
  image: String
  status: ConfigStatus!
}

type SaveCourtAmenityPayload {
  courtAmenity: CourtAmenity
  errorMessage: String
  error: CourtAmenityError
  errors: [CourtAmenityError!]
}

input SaveCourtCategoryInput {
  id: ID
  name: String!
  description: String
  image: String
  status: ConfigStatus!
}

type SaveCourtCategoryPayload {
  courtCategory: CourtCategory
  errorMessage: String
  error: CourtCategoryError
  errors: [CourtCategoryError!]
}

input SaveCourtCommentInput {
  id: ID
  description: String!
  courtId: ID!
  rating: [CRatingTypesInput!]!
}

type SaveCourtCommentPayload {
  courtComment: CourtComment
  error: CourtCommentErrors
  errors: [CourtCommentErrors!]
}

input SaveCourtInput {
  id: ID
  name: String!
  status: CourtStatus!
  description: String
  email: String
  phone: String!
  images: [String!]
  videos: [CourtVideoInput!]
  location: CourtLocationInput!
  slotDivider: Int!
  schedule: [CourtScheduleInput!]!
  packages: [CourtPackageInput!]!
  policy: String
  categoryIds: [ID!]!
  amenityIds: [ID!]!
  lastUpdatedById: ID
}

type SaveCourtPayload {
  court: Court
  error: CourtError
  errors: [CourtError!]
  errorMessage: String
}

input SaveCustomerAddressInput {
  id: ID
  isDefault: Boolean!
  countryId: ID!
  # The longitude component of the geo coordinates for this address, in degrees
  longitude: Float!
  # The longitude component of the geo coordinates for this address, in degrees
  latitude: Float!
  dynamicData: [DynamicAddressFieldsInput!]
}

type SaveCustomerAddressPayload {
  customerAddresses: [CustomerAddress!]
  error: CustomerAddressError
  errors: [CustomerAddressError!]
  errorMessage: String
}

type SaveCustomerGymClassPayload {
  booked: Boolean!
}

input SaveCustomerInput {
  firstName: String!
  lastName: String!
  email: String!
  contactNumber: String!
  gender: CustomerGenderType
  photo: String
  dob: Date
  accessedByMobile: Boolean
  newPassword: String
  isParent: Boolean
  isLinkedAccount: Boolean
  leadId: ID
  linkedAccountId: ID
  parentCustomerId: ID
  linkedCustomers: [ID]
}

type SaveCustomerPayload {
  customer: Customer
  error: CustomerError
  errors: [CustomerError]
  errorMessage: String
}

input SaveDiscountInput {
  id: ID
  name: String!
  status: DiscountStatus!
  gymId: ID!
  percentage: Float
  fixedAmount: Float
  currency: String
  maxLimit: Int
  forMembers: Boolean
  forNonMembers: Boolean
  startDate: Date!
  endDate: Date!
  externalId: String
  membershipIds: [String!]
  sessionContractIds: [String!]
  classIds: [String!]
  posProductIds: [String!]
}

type SaveDiscountPayload {
  discount: Discount
  error: DiscountError
  errors: [DiscountError!]
  errorMessage: String
}

input SaveFileCategoryInput {
  name: String!
  description: String
  iconURL: String!
}

type SaveFileCategoryPayload {
  fileCategory: FileCategory
  errorMessage: String
  error: FileCategoryError
  errors: [FileCategoryError!]
}

input SaveFileInput {
  description: String
  userId: ID!
  userType: UserType!
  fileURL: String!
  fileType: FileType!
  fileCategoryId: ID!
}

type SaveFilePayload {
  file: File
  errorMessage: String
  error: FileError
  errors: [FileError!]
}

input SaveFilesInput {
  userId: ID!
  userType: UserType!
  files: [FileTypeInput!]!
}

type SaveFilesPayload {
  files: [File!]
  errorMessage: String
  error: FileError
  errors: [FileError!]
}

input SaveGroupNotificationInput {
  diffusionType: GroupNotificationDiffusionType!
  title: String!
  description: String!
}

type SaveGroupNotificationPayload {
  notification: GroupNotification
  error: NotificationError
  errors: [NotificationError]
  errorMessage: String
}

type SaveGymAccessGatePayload {
  gate: GymAccessGate
  error: GymAccessGateError
  errors: [GymAccessGateError!]
  errorMessage: String
}

type SaveGymAccessLevelPayload {
  accessLevel: GymAccessLevel
  error: GymAccessLevelError
  errors: [GymAccessLevelError!]
  errorMessage: String
}

input SaveGymAdminInput {
  id: ID
  gymId: ID!
  adminId: ID!
}

type SaveGymAdminPayload {
  gymAdmin: GymAdmin
  error: GymAdminError
  errors: [GymAdminError!]
}

type SaveGymAdminTablePayload {
  updated: Boolean
  error: GymAdminError
  errors: [GymAdminError!]
}

input SaveGymBannerInput {
  id: ID
  image: String!
  link: String
  status: GlobalStatusType!
  gymId: ID!
}

type SaveGymBannerPayload {
  gymBanner: GymBanner
  success: Boolean
  error: GymBannerError
  errors: [GymBannerError!]
}

input SaveGymBuddyInput {
  customerId: ID!
  name: String
  description: String
  interests: [Interest]
  age: Int
  weight: Float
  weightUnit: ID
  height: Int
  heightUnit: ID
  trainingPlace: TrainingPlace
  photo: String
  backgroundImage: String
  locationName: String
  dob: Date
  gender: CustomerGenderType
}

type SaveGymBuddyPayload {
  gymBuddy: GymBuddy
  error: CustomerError
  errors: [CustomerError!]
  errorMessage: String
}

input SaveGymClassCategoryInput {
  id: ID
  name: String!
  description: String
  image: String
  status: GlobalStatusType!
}

type SaveGymClassCategoryPayload {
  gymClassCategory: GymClassCategory
  errorMessage: String
  error: GymClassCategoryError
  errors: [GymClassCategoryError!]
}

input SaveGymClassCommentInput {
  id: ID
  description: String!
  gymClassId: ID!
  rating: [GCRatingTypesInput!]!
}

type SaveGymClassCommentPayload {
  gymClassComment: GymClassComment
  error: GymClassCommentErrors
  errors: [GymClassCommentErrors!]
}

input SaveGymClassInput {
  id: ID
  name: String!
  description: String
  countryId: ID!
  gymClassCategoryIds: [ID!]!
  instructorIds: [ID!]
  gymId: ID!
  gymStudioId: ID
  duration: Float!
  spots: Int
  images: [String!]
  status: GlobalStatusType!
  startDate: Date!
  endDate: Date
  schedule: [GymClassScheduleInput!]
  difficultyLevel: DifficultyLevel!
  estimatedCaloriesBurnt: String!
  gender: GlobalGenderType!
  age: AgeInput!
  isPrivate: Boolean!
  classType: GymClassType!
  onlineLink: String
  dropInClient: Boolean!
  gymMemberClient: Boolean!
  sentNotification: Boolean!
  pricingType: GymClassPricingType!
  equipment: String
  equipmentLink: String
  dropInClientPrice: CurrencyValue!
  gymMemberClientPrice: CurrencyValue!
  classMembershipPrices: [ClassMembershipPricesInput]
}

input SaveGymClassInputNew {
  id: ID
  name: String!
  description: String
  countryId: ID
  gymClassCategoryIds: [ID!]!
  gymId: ID!
  images: [String!]
  status: GlobalStatusType
  age: AgeInput
  classType: GymClassType
  onlineLink: String
  equipment: String
  equipmentLink: String
  externalId: String
}

input SaveGymClassInputV2 {
  id: ID
  date: Date
  oldDate: Date
  name: String!
  description: String
  countryId: ID
  parentId: ID
  gymClassCategoryIds: [ID!]!
  instructorIds: [ID!]
  gymId: ID!
  gymStudioId: ID
  duration: Float
  spots: Int
  images: [String!]
  status: GlobalStatusType
  startDate: Date!
  endDate: Date!
  openTime: LocalTime!
  oldOpenTime: LocalTime
  schedule: [GymClassScheduleInput!]
  difficultyLevel: DifficultyLevel!
  estimatedCaloriesBurnt: String
  gender: GlobalGenderType!
  age: AgeInput!
  isRecursive: Boolean!
  isPrivate: Boolean!
  classType: GymClassType
  onlineLink: String
  dropInClient: Boolean
  gymMemberClient: Boolean!
  sentNotification: Boolean
  pricingType: GymClassPricingType!
  equipment: String
  equipmentLink: String
  dropInClientPrice: CurrencyValue!
  gymMemberClientPrice: CurrencyValue!
  classMembershipPrices: [ClassMembershipPricesInput]
}

type SaveGymClassNewPayloadV2 {
  gymClass: GymClassV2
  error: GymClassError
  errorMessage: String
  errors: [GymClassError!]
}

type SaveGymClassPayload {
  gymClass: GymClass
  error: GymClassError
  errorMessage: String
  errors: [GymClassError!]
}

type SaveGymClassPayloadV2 {
  gymClass: GymClassList
  error: GymClassError
  errorMessage: String
  errors: [GymClassError!]
}

input SaveGymClassStatusInput {
  id: ID
  status: GlobalStatusType!
}

type SaveGymDevicePayload {
  gymDevice: GymDevice
  error: GymDeviceError
  errors: [GymDeviceError!]
  errorMessage: String
}

input SaveGymInput {
  id: ID
  name: String!
  prefix: String
  description: String!
  email: String!
  brandId: ID!
  images: [String!]!
  legalName: String!
  phone: String!
  status: GymStatus!
  rules: [RulesInput!]
  rulesDescription: String
  termsAndConditions: String
  socialMediaReferences: [VSocialMediaReferenceInput!]
  amenities: [GymAmenityInput!]
  workoutMachines: [ID!]
  address: addressInput!
  adminIds: [ID!]
  priceType: PriceType
  freeTrial: Boolean
  trialForDays: Int
  trialSalientFeatures: [String!]
  trialRangeStartTime: LocalTime
  trialRangeEndTime: LocalTime
  trailSlotDivider: Int
  trailDisclaimer: String
  vatRegistrationNumber: String
  accessOrigins: [String!]
  apiKey: String
  isNotificationsDisabled: Boolean
  isPaymentGatewayEnabled: Boolean
  paymentProvider: GymPaymentGateway
  tapMerchantId: String
  masterMerchantId: String
  tapSecretKey: String
  tapPublicKey: String
  tapAndroidAppSecretKey: String
  tapIosAppSecretKey: String
  tapAppPublicKey: String
  isAccessGateEnabled: Boolean
  accessGateVendor: GateVendorType
  gateApiKey: String
}

input SaveGymOperatingHourlyPricesInput {
  startTime: LocalTime!
  endTime: LocalTime!
  notAvailable: Boolean!
  message: String
  compareAtPrice: CurrencyValue
  price: CurrencyValue!
  highlightType: HighlightType
}

type SaveGymOperatingHourlyPricesPayload {
  updated: Boolean
  error: GymOperatingHourlyPricesError
  errors: [GymOperatingHourlyPricesError!]
}

input SaveGymOperatingHoursInput {
  day: Int!
  openTime: LocalTime
  openDuration: Int
  openAllDay: Boolean
  closeAllDay: Boolean
  dailyPrice: Int
  compareAtDailyPrice: Int
  hourlyPrices: [SaveGymOperatingHourlyPricesInput!]
}

type SaveGymOperatingHoursPayload {
  updated: Boolean
  error: GymOperatingHoursError
  errors: [GymOperatingHoursError!]
}

type SaveGymPayload {
  gym: Gym
  error: GymError
  errors: [GymError!]
  errorMessage: String
}

type SaveGymPaymentGatewayPayload {
  gymPaymentGateway: GymPaymentGatewayDetail
  error: GymError
  errors: [GymError!]
  errorMessage: String
}

input SaveGymQrReviewInput {
  description: String
  rating: RatingInput!
  workedBodyParts: [WorkedBodyPart!]
}

type SaveGymQrReviewPayload {
  review: GymQrReview
  error: GymQrReviewError
  errors: [GymQrReviewError!]
}

input SaveGymsAdminsTableInput {
  adminId: ID!
}

input SaveGymStatusInput {
  id: ID!
  brandId: ID!
  status: GymStatus!
}

input SaveGymStudioInput {
  id: ID
  name: String!
  spots: Int!
  status: GlobalStatusType!
  gymId: ID!
}

type SaveGymStudioPayload {
  gymStudio: GymStudio
  success: Boolean
  error: GymStudioError
  errors: [GymStudioError!]
}

type SaveHomeScreenPayload {
  homeScreen: HomeScreen
  error: HomeScreenError
  errors: [HomeScreenError]
  errorMessage: String
}

input SaveIndividualNotificationInput {
  leadId: ID!
  title: String!
  description: String!
  notificationCreatedById: ID
}

type SaveIndividualNotificationPayload {
  notification: IndividualNotification
  error: NotificationError
  errors: [NotificationError]
  errorMessage: String
}

input SaveInstructorCommentInput {
  id: ID
  description: String!
  instructorId: ID!
  rating: [RatingTypesInput!]!
}

type SaveInstructorCommentPayload {
  instructorComment: InstructorComment
  error: InstructorCommentError
  errors: [InstructorCommentError!]
}

input SaveInstructorCoverPhotoInput {
  id: ID!
  coverPhoto: String
}

input SaveInstructorGalleryInput {
  id: ID
  url: String!
  mediaType: MediaType!
  srcId: String
  thumbnail: String
  status: GlobalStatusType!
  instructorId: ID!
  categoryId: ID!
}

type SaveInstructorGalleryPayload {
  instructorGallery: InstructorGallery
  error: InstructorGalleryError
  errors: [InstructorGalleryError!]
}

input SaveInstructorInput {
  id: ID!
  firstName: String!
  lastName: String
  description: String
  email: String!
  contactNumber: String!
  gender: GlobalGenderType
  photo: String!
  coverPhoto: String!
  brandId: ID!
  gymId: ID!
  services: [ID!]
  status: GlobalStatusType!
  privateCoach: Boolean
  perSessionAmount: CurrencyValue!
  socialMediaReferences: [SocialMediaReferenceInput!]
  sessions: [InstructorSessionInput!]
  specialities: [ID!]
  certifications: [String!]
  # The longitude component of the geo coordinates for this inst, in degrees
  longitude: Float!
  # The longitude component of the geo coordinates for this inst, in degrees
  latitude: Float!
  serviceRange: Float!
}

input SaveInstructorMobileInput {
  id: ID!
  firstName: String!
  lastName: String
  description: String
  dob: Date
  password: String
  email: String!
  photo: String!
  coverPhoto: String
  socialMediaReferences: [SocialMediaReferenceInput!]
}

input SaveInstructorPasswordMobileInput {
  id: ID!
  newPassword: String!
  confirmNewPassword: String!
}

type SaveInstructorPayload {
  instructor: Instructor
  error: InstructorError
  errors: [InstructorError!]
  errorMessage: String
}

type SaveInstructorSpecialityPayload {
  instructorSpeciality: InstructorSpeciality
  error: instructorSpecialityError
  errors: [instructorSpecialityError!]
}

input SaveInstructorStatusInput {
  id: ID!
  brandId: ID!
  gymId: ID!
  status: GlobalStatusType!
}

input SaveLanguageCountryInput {
  id: ID
  countryId: ID!
  languageId: ID!
}

type SaveLanguageCountryPayload {
  languageCountry: LanguageCountry
  error: LanguageCountryError
  errors: [LanguageCountryError!]
}

type SaveLanguagePayload {
  language: Language
  error: LanguageError
  errors: [LanguageError!]
}

input SaveLeadAppointmentInput {
  leadId: ID!
  appointmentDate: Date!
  appointmentTime: String!
  note: String
  appointmentCreatedById: ID
  outcome: AppointmentOutcome
  outcomeRescheduledDate: Date
  outcomeRescheduledTime: String
  outcomeRescheduledNote: String
  outcomeNotInterestedNote: String
}

type SaveLeadAppointmentPayload {
  appointment: LeadAppointment
  error: FollowUpError
  errors: [FollowUpError!]
  errorMessage: String
}

input SaveLeadCallInput {
  leadId: ID!
  callDate: Date!
  callTime: String!
  outcome: CallOutcome!
  note: String
  callConnectedStatus: CallConnectedStatus
  callUnreachedStatus: CallUnreachedStatus
  callFollowUpDate: Date
  callFollowUpTime: String
  callFollowUpBy: ID
  priority: FollowUpPriority
  callAppointmentDate: Date
  callAppointmentTime: String
  calledBy: ID
}

type SaveLeadCallPayload {
  call: LeadCall
  error: FollowUpError
  errors: [FollowUpError]
  errorMessage: String
}

input SaveLeadCompanyInput {
  id: ID
  name: String!
  industry: CompanyIndustry!
  address: String
}

type SaveLeadCompanyPayload {
  company: LeadCompany
  error: LeadCompanyError
  errors: [LeadCompanyError]
  errorMessage: String
}

input SaveLeadContactInput {
  id: ID
  leadId: ID
  phoneNumber: String!
  phoneCountryCode: String!
}

type SaveLeadContactPayload {
  contact: LeadContact
  error: LeadError
  errors: [LeadError!]
  errorMessage: String
}

input SaveLeadEmailInput {
  leadId: ID!
  subject: String!
  description: String!
}

type SaveLeadEmailPayload {
  email: LeadEmail
  error: FollowUpError
  errors: [FollowUpError!]
  errorMessage: String
}

input SaveLeadInput {
  firstName: String!
  middleName: String
  lastName: String
  description: String
  dob: Date
  photo: String
  nationality: String
  source: LeadSource!
  gender: CustomerGenderType
  address: String
  cityId: ID
  countryId: ID!
  email: String
  phoneNumber: String!
  leadType: LeadType
  leadStatus: LeadStatus!
  workStatus: WorkStatus
  jobTitle: String
  companyId: ID
  marketingConsentSms: Boolean
  marketingConsentEmail: Boolean
  contacts: [SaveLeadContactInput]!
  linkedAccounts: [SaveLinkedAccountWithLeadInput]
  emergencyContact: SaveLeadContactInput
  gymId: ID!
  adminId: ID
  assignedTo: ID
}

input SaveLeadNoteInput {
  leadId: ID!
  note: String!
}

type SaveLeadNotePayload {
  note: LeadNote
  error: FollowUpError
  errors: [FollowUpError!]
  errorMessage: String
}

input SaveLeadNotificationInput {
  leadId: ID!
  title: String
  description: String!
}

type SaveLeadNotificationPayload {
  notification: LeadNotification
  error: FollowUpError
  errors: [FollowUpError]
  errorMessage: String
}

type SaveLeadPayload {
  lead: Lead
  error: LeadError
  errors: [LeadError]
  errorMessage: String
}

input SaveLeadSalesTrainerInput {
  leadId: ID!
  gymId: ID!
  salesId: ID
  trainerId: ID
}

type SaveLeadSalesTrainerPayload {
  assigned: Boolean
  error: LeadSalesTrainerError
  errors: [LeadSalesTrainerError!]
  errorMessage: String
}

input SaveLeadTaskInput {
  leadId: ID!
  startDate: Date!
  endDate: Date!
  assigneeId: ID!
  title: String!
  description: String!
  priority: FollowUpPriority
  notes: String
}

type SaveLeadTaskPayload {
  task: LeadTask
  error: FollowUpError
  errors: [FollowUpError]
  errorMessage: String
}

input SaveLinkedAccountInput {
  id: ID
  leadId: ID
  firstName: String!
  lastName: String
  gender: CustomerGenderType
  dob: Date
  email: String
  phoneNumber: String!
  photo: String
  hasUniqueEmail: Boolean!
}

type SaveLinkedAccountPayload {
  account: LinkedAccount
  error: LeadAccountError
  errors: [LeadAccountError]
  errorMessage: String
}

input SaveLinkedAccountWithLeadInput {
  id: ID
  firstName: String!
  lastName: String
  gender: CustomerGenderType
  dob: Date
  email: String
  phoneNumber: String
  photo: String
  customerId: ID
  hasUniqueEmail: Boolean
}

type SaveMeasureUnitPayload {
  measureUnit: MeasureUnit
  error: MeasureUnitError
  errors: [MeasureUnitError!]
  errorMessage: String
}

type SaveMultiFileCategoryPayload {
  status: Boolean
  errorMessage: String
  error: FileCategoryError
  errors: [FileCategoryError!]
}

input SaveOfferInput {
  id: ID
  title: String!
  description: String!
  thumbnail: String!
  photo: String
  brandId: ID!
  gymId: ID
  status: GlobalStatusType!
  socialMediaReferences: [VSocialMediaReferenceInput!]
}

type SaveOfferPayload {
  success: Boolean
  error: OfferError
  errors: [OfferError!]
}

input SaveParentVideoTypeInput {
  id: ID
  label: String!
  createdBy: ID
  status: GlobalStatusType!
}

input SavePermissionInput {
  id: ID
  name: String!
  description: String
  status: StatusType!
}

type SavePermissionPayload {
  permission: Permission
  error: PermissionError
  errors: [PermissionError!]
}

type SavePosBrandPayload {
  posBrand: PosBrand
  errorMessage: String
  error: PosBrandError
  errors: [PosBrandError!]
}

type SavePosCategoryPayload {
  posCategory: PosCategory
  errorMessage: String
  error: PosCategoryError
  errors: [PosCategoryError!]
}

type SavePosProductPayload {
  posProduct: PosProduct
  errorMessage: String
  error: PosProductError
  errors: [PosProductError!]
}

input SaveProductCategoryInput {
  id: ID
  name: String!
  image: String
  createdBy: ID
  status: GlobalStatusType!
}

type SaveProductCategoryPayload {
  productCategory: ProductCategory
  error: ProductCategoryError
  errors: [ProductCategoryError!]
}

input SaveProductInput {
  id: ID
  name: String!
  description: String!
  categoryId: ID!
  brandId: ID!
  status: GlobalStatusType!
  bestSeller: GlobalStatusType
  listPrice: CurrencyValue!
  salePrice: CurrencyValue
  sku: String!
  barcode: String!
  warranty: Boolean!
  warrantyPeriod: Int
  warrantyDescription: String
  returnPolicy: Boolean!
  returnPolicyPeriod: Int
  returnPolicyDescription: String
  express: Boolean!
  countryId: ID!
  images: [String!]
  inventory: [SaveProductStockInProductInput!]
}

type SaveProductPayload {
  product: Product
  error: ProductError
  errors: [ProductError!]
}

input SaveProductStockInProductInput {
  id: ID
  gymId: ID!
  quantity: Int!
}

input SaveProductStockInput {
  id: ID
  productId: ID!
  gymId: ID!
  quantity: Int!
}

type SaveProductStockPayload {
  productStock: ProductStock
  error: ProductStockError
  errors: [ProductStockError!]
}

input SaveRoleInput {
  id: ID
  name: String!
  roleType: RoleType
  description: String
  status: StatusType!
  permissions: [ID]
}

type SaveRolePayload {
  role: Role
  error: RoleError
  errors: [RoleError!]
}

input SaveServiceCategoryInput {
  id: ID
  name: String!
  description: String
  image: String
  status: GlobalStatusType!
}

type SaveServiceCategoryPayload {
  serviceCategory: ServiceCategory
  errorMessage: String
  error: ServiceCategoryError
  errors: [ServiceCategoryError!]
}

input SaveServiceInput {
  id: ID
  name: String!
  code: String
  description: String
  benefits: [String!]
  serviceCategoryIds: [ID!]!
  pricePerSession: CurrencyValue!
  gymId: ID!
  # Validity in days
  serviceTime: Float
  cancellationTimeDays: Float
  cancellationTimeHours: Float
  cancellationTimeMin: Float
  status: GlobalStatusType
  sessionSiteType: SessionSiteType!
  onlineLink: String
  serviceType: ServiceTypes!
  # Duration of the single session (e.g. 40 (min))
  sessionPeriod: Int!
  # Number of total sessions in contract
  sessionTime: Int!
  groupNumber: Int
  isBookable: Boolean!
  gender: GlobalGenderType!
  packageFeatures: [String]!
  servicePack: Boolean
}

type SaveServicePayload {
  service: Service
  errorMessage: String
  error: ServiceError
  errors: [ServiceError!]
}

input SaveServiceSubCategoryInput {
  id: ID
  name: String!
  description: String
  serviceCategoryId: ID!
  image: String
  status: GlobalStatusType!
}

type SaveServiceSubCategoryPayload {
  serviceSubCategory: ServiceSubCategory
  errorMessage: String
  error: ServiceSubCategoryError
  errors: [ServiceSubCategoryError!]
}

input SaveSessionContractInput {
  id: ID
  customerId: ID!
  instructorId: ID!
  startDate: Date!
  endDate: Date!
  serviceId: ID!
  note: String
  status: SessionContractStatus!
  memberCodes: [String!]
  groupMembers: [String!]
  createdById: ID
}

type SaveSessionContractPayload {
  sessionContract: SessionContract
  errorMessage: String
  error: SessionContractError
  errors: [SessionContractError!]
}

input SaveStoreImageInput {
  id: ID
  name: String!
  image: String!
  status: GlobalStatusType!
  countryId: ID!
}

type SaveStoreImagePayload {
  storeImage: StoreImage
  error: StoreImageError
  errors: [StoreImageError!]
}

input SaveTermsConditionsInput {
  id: ID
  version: String!
  content: String!
  contentHTML: String!
}

type SaveTermsConditionsPayload {
  TermsConditions: TermsConditions
  error: TermsConditionsError
  errorMessage: String
  errors: [TermsConditionsError!]
}

input SaveVideoInput {
  id: ID!
  title: String!
  description: String!
  videoId: String!
  url: String!
  hero: String!
  duration: Int!
  brandId: ID!
  gymId: ID
  status: GlobalStatusType!
  instructorId: ID
  videoTypeId: ID!
  difficulty: VideoDifficulty!
  equipment: String!
  caloriesBurned: String!
}

type SaveVideoPayload {
  success: Boolean
  errorMessage: String
  error: VideoError
  errors: [VideoError!]
}

input SaveVideoTypeInput {
  id: ID
  label: String!
  createdBy: ID
  status: GlobalStatusType!
  videoParentTypeId: ID
  image: String
}

type SaveVideoTypePayload {
  videoType: VideoType
  error: VideoTypeError
  errors: [VideoTypeError!]
}

input SaveWhiteListedNumber {
  phoneNumber: String!
  otp: String
}

type SaveWhiteListedNumberPayload {
  whiteListedPhoneNumber: WhiteListedPhoneNumber
}

type SaveWorkoutMachinePayload {
  workoutMachine: WorkoutMachine
  errors: [WorkoutMachineError]
}

type Schedule {
  closeAllDay: Boolean
  closeTime: LocalTime
  day: Int
  openTime: LocalTime
  openDuration: Int
}

input ScheduleInput {
  closeAllDay: Boolean
  closeTime: LocalTime
  day: Int
  openTime: LocalTime
  openDuration: Int
}

input sendOTPInput {
  contactNumber: String!
  gymId: String!
}

type sendOTPPayload {
  customer: Lead
  send: Boolean
  error: SendOTPPError
  errors: [SendOTPPError]
  errorMessage: String
}

enum SendOTPPError {
  INVALID_LEAD
  LEAD_SOFT_DELETED
}

type SendVerificationEmailResponse {
  status: Boolean
  message: String
}

type Service {
  id: ID!
  name: String!
  code: String!
  description: String
  benefits: [String!]
  serviceCategoryId: ID!
  serviceCategoryIds: [ID!]!
  serviceSubCategoryId: ID
  gymId: ID!
  gym: ServiceGym
  extraCost: CurrencyValue!
  totalCost: CurrencyValue!
  pricePerSession: CurrencyValue!
  # Validity in days
  serviceTime: Float!
  cancellationTimeDays: Float!
  cancellationTimeHours: Float!
  cancellationTimeMin: Float!
  offAmount: Float!
  # Number of total sessions in contract.
  maxBooking: Int!
  status: GlobalStatusType
  gender: GlobalGenderType!
  sessionSiteType: SessionSiteType!
  onlineLink: String
  serviceType: ServiceTypes!
  # Duration of the single session (e.g. 40 (min))
  sessionPeriod: Int!
  # Number of total sessions in contract
  sessionTime: Int!
  groupNumber: Int
  isBookable: Boolean!
  packageFeatures: [String]!
  servicePack: Boolean
  createdAt: Datetime!
  updatedAt: Datetime!
}

type ServiceCategory {
  id: ID!
  name: String!
  description: String
  image: String
  status: GlobalStatusType
  createdAt: Datetime!
  updatedAt: Datetime!
  subCategories: [ServiceSubCategory!]
}

enum ServiceCategoryError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_BRAND_ID
  INVALID_GYM_ID
}

input ServiceCategoryFilter {
  searchText: String
  status: GlobalStatusType
}

type ServiceCategoryPayload {
  list: [ServiceCategory]
  paging: PaginatorOutputUpdated
}

type ServiceCountryCurrency {
  name: String
  code: String
  symbol: String
}

enum ServiceError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_GROUP_NUMBER
  INVALID_SERVICE_PACKAGE_FEATURES
  INTERNAL_SERVER_ERROR
  INVALID_GYM
  NOT_ALLOWED
}

input ServiceFilter {
  searchText: String
  status: GlobalStatusType
  servicePack: Boolean
  gymId: ID
}

type ServiceGym {
  id: ID
  name: String
  brand: ServiceGymBrand
  address: [ServiceGymAddress]
}

type ServiceGymAddress {
  id: ID
  city: String
  state: String
  floorNo: String
  street: String
  zipCode: String
  building: String
  unitNumber: String
  shortAddress: String
  geoLocation: ServiceGymAddressGeolocation
  country: ServiceGymAddressCountry
}

type ServiceGymAddressCountry {
  id: ID
  name: String
  isoCode: String
  dialCode: String
  vat: Float
  vatId: String
  currency: ServiceCountryCurrency
}

type ServiceGymAddressGeolocation {
  type: String
  coordinates: [String]
}

type ServiceGymBrand {
  id: ID
  name: String
}

input ServicePackInputType {
  serviceId: ID
  serviceQty: Int
  classId: ID
  classQty: Int
}

type ServicePackObjectType {
  id: ID!
  serviceId: ID
  serviceQty: Int
  classId: ID
  classQty: Int
  singleMembershipPlanId: ID
  groupMembershipPlanId: ID
  paymentPlanId: ID!
  service: ServicePackServiceType
}

type ServicePackServiceGymAddressCountryCurrencyType {
  name: String
  code: String
  symbol: String
}

type ServicePackServiceGymAddressCountryType {
  id: ID
  city: String
  state: String
  vat: Int
  vatId: String
  currency: ServicePackServiceGymAddressCountryCurrencyType
}

type ServicePackServiceGymAddressType {
  id: ID
  city: String
  state: String
  country: ServicePackServiceGymAddressCountryType
}

type ServicePackServiceGymType {
  id: ID
  name: String
  address: [ServicePackServiceGymAddressType]
}

type ServicePackServiceType {
  id: ID
  name: String
  totalCost: Float
  gym: ServicePackServiceGymType
}

type ServicePayload {
  list: [Service]
  paging: PaginatorOutputUpdated
}

enum SERVICES_LIMIT {
  LIMITED
  UNLIMITED
}

type ServiceSubCategory {
  id: ID!
  name: String!
  description: String
  image: String
  status: GlobalStatusType
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum ServiceSubCategoryError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_CATEGORY_ID
}

input ServiceSubCategoryFilter {
  searchText: String
  status: GlobalStatusType
  serviceCategoryId: ID
}

type ServiceSubCategoryPayload {
  list: [ServiceSubCategory]
  paging: PaginatorOutputUpdated
}

enum ServiceTypes {
  SESSION
  GROUP_SESSION
}

type SessionContract {
  id: ID!
  customerId: ID!
  instructorId: ID
  startDate: Date!
  endDate: Date!
  serviceId: ID!
  status: SessionContractStatus!
  isPaid: Boolean!
  sessionPeriod: Int!
  sessionTime: Int!
  totalCost: CurrencyValue!
  groupNumber: Int
  memberCodes: [String!]
  note: String
  isExpired: Boolean
  createdById: ID
  lastEditedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
  service: Service!
  instructor: Instructor
  lead: InstructorLead
  customer: InstructorCustomer
  salesBy: SalesBy
  userServicePack: String
  bookedSessions: Int
  remainingSessions: Int
  groupMembers: [GroupMemberCustomers]
}

input SessionContractBookingsParams {
  # User's current location
  timeZoneIdentifier: String!
  sessionContractId: ID!
  type: SessionContractBookingType!
}

enum SessionContractBookingType {
  PREVIOUS
  TODAY
  UPCOMING
  CANCELED
}

type SessionContractCapacityStatusPayload {
  total: Int!
  used: Int!
  remaining: Int!
  firstBookingDate: Date
}

enum SessionContractError {
  DUPLICATE_NAME
  INVALID_ID
  INVALID_GROUP_NUMBER
  INVALID_SERVICE_ID
  INVALID_MEMBER_CODES
  TRANSACTION_EXCEPTION
  EXCEPTION
  CUSTOMER_NOT_FOUND
  GROUP_MEMBERS_LIMIT_EXCEEDED
}

input SessionContractFilter {
  status: SessionContractStatus
  gymId: ID
  customerId: ID
  instructorId: ID
  instructorIds: [ID]
  isPaid: Boolean
  type: CountType
  buyerOnly: Boolean
}

type SessionContractPayload {
  list: [SessionContract]
  paging: PaginatorOutputUpdated
}

type SessionContractsCountsPayload {
  count: Int!
}

enum SessionContractStatus {
  ACTIVE
  INACTIVE
  CANCELED
  STARTED
  NOT_STARTED
  ENDED
  EXPIRED
  TERMINATED
}

type SessionPack {
  id: ID!
  name: String!
  startDate: String!
  status: MembershipStatus!
    @deprecated(reason: "Use classStatus and session Status instead.")
  membershipCode: String
  qrCode: String!
  classes: Int!
  allClasses: Boolean!
  classIds: [String]
  classCategories: [String]
  classExpiresAt: String!
  classStatus: MembershipStatus!
  courts: Int!
  sessions: Int!
  allSessions: Boolean!
  sessionIds: [String]
  sessionCategories: [String]
  sessionExpiresAt: String!
  sessionStatus: MembershipStatus!
  price: Float!
  joiningFee: Float!
  currency: String
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentRecursionDuration: Int
  hasEndDate: Boolean
  recursionPeriod: MembershipPlanTypePeriod
  recursionDuration: Int
  gracePeriodDays: Int
  allowFreeze: Boolean
  freezesList: [MembershipFreezeDetails]
  sessionPackPlan: SessionPackPlan!
  owner: MembershipUser!
  admin: MembershipAdmin
  gym: MembershipGym
  payments: [Payment]
  createdAt: String!
  updatedAt: String!
}

type SessionPackPlan {
  id: ID!
  name: String!
  description: String!
  color: String
  status: MembershipPlanTypeStatus!
  visible: Boolean!
  classes: Int!
  allClasses: Boolean!
  classIds: [String]
  classCategories: [String]
  classRecursionDuration: Int
  classRecursionPeriod: MembershipPlanTypePeriod
  courts: Int!
  sessions: Int!
  allSessions: Boolean!
  sessionIds: [String]
  sessionCategories: [String]
  sessionRecursionDuration: Int
  sessionRecursionPeriod: MembershipPlanTypePeriod
  paymentPlans: [PaymentPlan]
  gym: MembershipGym!
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
  admin: MembershipAdmin!
  createdAt: String!
  updatedAt: String!
}

type sessionPackPlans {
  sessionPackPlans: [SessionPackPlan]
}

enum SessionSiteType {
  ONSITE
  ONLINE
  ANY
}

input SignUpWithMobileNumberInput {
  firstName: String!
  lastName: String!
  email: String
  contactNumber: String!
  isEmailVerified: Boolean!
  isPhoneVerified: Boolean!
  authId: String
  countryId: ID!
}

type SimplifiedDocument {
  id: ID!
  fileURL: String!
  description: String
  fileType: String!
}

type SimulateRecurringPayment {
  log: [SimulatingPaymentLogs]
}

input SimulateRecurringPaymentMutationInput {
  periodType: PaymentRecursionTypeEnum!
  periodDuration: Int!
  executePayments: Boolean!
}

type SimulateRecurringPaymentMutationResponse {
  data: SimulateRecurringPayment
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type SimulateUnfreezeMembership {
  log: [SimulatingUnfreezeLogs]
}

input SimulateUnfreezeMembershipMutationInput {
  periodType: PaymentRecursionTypeEnum!
  periodDuration: Int!
  unfreezeMemberships: Boolean!
}

type SimulateUnfreezeMembershipMutationResponse {
  data: SimulateUnfreezeMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type SimulatingPaymentLogs {
  date: String!
  executedPaymentList: [PaymentLogLine]
}

type SimulatingUnfreezeLogs {
  date: String!
  executedUnfreezeList: [UnfreezeLogLine]
}

type SingleEvent {
  data: Event
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

type SingleMembership {
  id: ID!
  name: String!
  status: MembershipStatus!
  membershipCode: String
  startDate: String!
  endDate: String
  membershipId: String!
  qrCode: String!
  price: Float!
  discountedPrice: Float
  joiningFee: Float!
  currency: String
  frozenById: String
  paymentRecursionType: PaymentRecursionTypeEnum
  paymentRecursionDuration: Int
  chargeOnFirst: Boolean
  hasEndDate: Boolean
  recursionPeriod: MembershipPlanTypePeriod
  recursionDuration: Int
  gracePeriodDays: Int
  allowFreeze: Boolean
  freezesList: [MembershipFreezeDetails]
  giftPeriodFree: Boolean
  previousMembershipId: ID
  membershipPlan: SingleMembershipPlan!
  owner: MembershipUser!
  admin: MembershipAdmin
  payments: [Payment]
  gyms: [MembershipGym]
  userServicePacks: [UserServicePackType]
  paymentPlan: PaymentPlan
  isChampion: Boolean
  championType: ChampionType
  champAppId: String
  subDomesticGymIds: [String]
  createdAt: String!
  updatedAt: String!
  pendingAmount: Float!
  champId: String
}

type SingleMembershipPlan {
  id: ID!
  name: String!
  description: String!
  color: String
  status: MembershipPlanTypeStatus!
  trial: Boolean!
  visible: Boolean!
  targetGender: GenderEnum
  targetMinAge: Int
  targetMaxAge: Int
  paymentPlans: [PaymentPlan]
  gyms: [MembershipGym]
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
  admin: MembershipAdmin!
  servicePacks: [ServicePackObjectType]
  isChampion: Boolean
  championType: ChampionType
  champAppId: String
  subDomesticGymIds: [String]
  createdAt: String!
  updatedAt: String!
}

type SingleMembershipPlans {
  singleMembershipPlans: [SingleMembershipPlan]
}

# Payments bought by customers
type SingleTransaction {
  invoiceId: String!
  invoiceNo: String
  srNo: Int
  shortCode: String!
  paymentStatus: PaymentStatus!
  paymentMethod: String
  paymentScheme: OrderPaymentScheme!
  cardType: String
  amount: CurrencyValue!
  discountedAmount: CurrencyValue
  discountDetails: DiscountDetails
  totalVat: CurrencyValue
  singleMembership: TransactionSingleMembership
  groupMembership: TransactionGroupMembership
  sessionPack: TransactionSessionPack
  membershipAction: TransactionMembershipAction
  orderGymClass: TransactionOrderGymClass
  orderPrivateCoach: TransactionOrderPrivateCoach
  orderPOS: TransactionOrderPOS
  orderEvent: TransactionOrderEvent
  vatPercentage: CurrencyValue
  currencyCode: String!
  customerName: String
  brandId: ID
  brandName: String
  customerId: ID
  orderId: ID!
  orderType: String!
  gymId: ID
  gymName: String
  gym: TransactionGym
  lead: TransactionLead
  isRecurring: Boolean!
  isRefunded: Boolean!
  pgStatus: String
  pgMessage: String
  invoiceDate: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!
  walkinCustomer: Boolean!
  chargeAmount: Float
  refundAmount: Float
  qrCode: String
  invoices: [SingleTransactionInvoice]
  isSplitPayment: Boolean
  isInstallmentPayment: Boolean
}

type SingleTransactionInvoice {
  amount: Float
  currency: String
  date: Datetime
  installmentScheduledDate: Datetime
  paymentMethod: SingleTransactionPaymentMethod
  status: InvoicePaymentStatus
}

type SingleTransactionPaymentMethod {
  paymentScheme: OrderPaymentScheme
  cardType: String
}

type SocialAccount {
  type: SocialMediaAccountType!
  accountAddress: String!
}

input SocialAccountInput {
  type: SocialMediaAccountType!
  accountAddress: String!
}

input SocialAccountsInput {
  customerId: ID
  socialAccounts: [SocialAccountInput]
}

input SocialGymClassesFilters {
  searchText: String
  # User's current location
  location: GISLocationInput!
  countryId: ID
  categoryId: ID
  timeZoneIdentifier: String
  free: Boolean
  showForOnlyGymId: ID
  gymClassPref: CustomerGymClassDefaultPrefInput
  filterType: String
}

type SocialGymClassesPayload {
  list: [GymClassListSocial!]
  paging: PaginatorOutputUpdated
}

enum SocialMediaAccountType {
  TWITTER
  FACEBOOK
  INSTAGRAM
  YOUTUBE
  TIKTOK
}

type SocialMediaReference {
  profileType: SocialMedias!
  profileLink: String!
}

input SocialMediaReferenceInput {
  profileType: SocialMedias!
  profileLink: String!
}

enum SocialMedias {
  FACEBOOK
  TWITTER
  INSTAGRAM
  YOUTUBE
  LINKEDIN
  TIKTOK
  SNAPCHAT
}

type SoftDeleteLeadPayload {
  status: Boolean
  error: LeadError
  errors: [LeadError]
  errorMessage: String
}

enum SortingOrderType {
  ASC
  DESC
}

type StartQrSessionPayload {
  qrSession: QrSession
  error: QrSessionError
  errors: [QrSessionError!]
  errorMessage: String
}

enum StatusType {
  ACTIVE
  INACTIVE
  DELETED
}

input StoreHomeInput {
  countryId: String!
}

type StoreHomePayload {
  storeImages: [StoreImage!]
  stores: [ExternalBrand_Vendors!]
  categories: [ProductCategory!]
  bestSellers: [Product!]
}

# Store Image.
type StoreImage {
  id: ID!
  name: String!
  image: String!
  status: GlobalStatusType!
  countryId: ID!
  createdBy: ID!
  lastUpdatedBy: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum StoreImageError {
  INVALID_ID
}

input StoreImagesFilter {
  searchText: String
  status: GlobalStatusType
  countryId: String
}

type StoreImagesPayload {
  list: [StoreImage]
  paging: PaginatorOutput
}

input StoreOrderInvoiceCart {
  productId: ID!
  quantity: Int!
}

input StoreOrderInvoiceInput {
  cart: [StoreOrderInvoiceCart!]!
  countryId: ID!
}

enum StoreOrderStatus {
  ACTIVE
  INACTIVE
  CANCELED
}

type StringBox {
  stringVal: String
}

enum SubscriptionTypes {
  INACTIVE
  VENDOR_PORTAL
  SAAS
}

type SyncLeadMembershipsPayload {
  status: Boolean
  errorMessage: String
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
  FAILED
}

# Temporary Lead
type TemporaryLead {
  id: String!
  firstName: String!
  lastName: String!
  email: String
  phoneNumber: String!
  gymId: String!
}

enum TemporaryLeadErrors {
  INVALID_PHONE_NUMBER_FORMAT
  GYM_ID_REQUIRED
  INTERNAL_SERVER_ERROR
}

type TemporaryLeadPayload {
  customer: TemporaryLead
  error: TemporaryLeadErrors
  errors: [TemporaryLeadErrors]
  errorMessage: String
}

type terminateMembership {
  amount: Float
  currency: String
}

input TerminateMembershipMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
  customerId: ID!
  refundType: RefundType!
  refundCustomAmount: Float
  terminationReason: TerminationReasonEnum!
  note: String
  cashRefundConfirmation: Boolean
}

type TerminateMembershipMutationResponse {
  data: terminateMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

enum TerminationReasonEnum {
  BUDGET_CONCERNS
  HEALTH_ISSUES
  RULES_VIOLATION
  OTHER
}

type TerminationReasonType {
  key: String!
  description: String!
}

# TermsConditions
type TermsConditions {
  id: ID!
  content: String!
  contentHTML: String!
  version: String!
  createdById: ID
  lastUpdatedById: ID
  createdAt: Datetime!
  updatedAt: Datetime!
}

enum TermsConditionsError {
  DUPLICATE_VERSION
  INVALID_ID
  UPDATE_REFUSED
  INTERNAL_SERVER_ERROR
  REQUIRED_FIELD
}

input TermsConditionssFilter {
  searchText: String
  version: ID
}

type TermsConditionssPayload {
  list: [TermsConditions]
  paging: PaginatorOutput
}

type TestCustomerData {
  customerGender: String
  customerDob: String
  customerYears: Int
  classGender: String
  classAgeFrom: String
  classAgeTo: String
}

type TestRecurringPayment {
  singleMembership: SingleMembership
}

input TestRecurringPaymentMutationInput {
  singleMembershipPlanId: ID!
  paymentPlan: CreatePaymentPlanMutationInput!
  paymentMethod: MembershipPaymentMethod!
  paid: Boolean!
  startDate: String
  userId: ID
  adminId: ID
}

type TestRecurringPaymentMutationResponse {
  data: TestRecurringPayment
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

enum TimeInterval {
  TODAY
  WEEK
  MONTH
  YEAR
}

enum TimeIntervalType {
  DAY
  WEEK
  MONTH
  YEAR
}

type TimeRange {
  begin: Datetime!
  end: Datetime!
}

type tNode {
  id: ID
}

input ToggleAdminInput {
  id: ID
  status: GlobalStatusType!
}

type ToggleAdminPayload {
  status: Boolean!
}

input toggleGymSignupEnabledInput {
  gymId: ID!
  signupEnabled: Boolean!
}

type topMembers {
  type: QuantityOrRevenueEnum!
  total: Float!
  topMembers: [topMembersType]
}

type topMembersCsv {
  link: String!
  records: [topMembersReportType]
}

type topMembersCsvQueryResponse {
  data: topMembersCsv
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type topMembersQueryResponse {
  data: topMembers
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type topMembersReportType {
  name: String
  email: String
  revenue: Float
  quantity: Int
  gymName: String
}

type topMembersType {
  total: Float!
  totalDiscountedPrice: Float!
  percentage: Float!
  salesBy: String!
}

type totalPayload {
  totalComments: Int!
  avgRatingScore: Float
}

type Trainer {
  id: ID!
  firstName: String!
  lastName: String
  description: String
  email: String!
  contactNumber: String
  status: String!
  gender: String!
  photo: String!
  coverPhoto: String
}

enum TrainingPlace {
  HOME
  GYM
}

# ZkSecurity
type Transaction {
  id: ID!
  eventTime: String
  pin: String
  name: String
  lastName: String
  deptName: String
  areaName: String
  cardNo: String
  devSn: String
  verifyModeName: String
  eventName: String
  eventPointName: String
  readerName: String
  accZone: String
  devName: String
  logId: Int
  eventNo: Int
  eventLevel: Int
  doorName: String
}

input TransactionFilter {
  startDate: Date
  endDate: Date
  personPin: String
}

type TransactionGroupMembership {
  id: ID
  name: String
  price: Float
  joiningFee: Float
  paymentType: String
  currency: String
  startDate: String
  endDate: String
  ownerId: String
  adminId: ID
  salesByName: String
  frozenById: ID
  frozenByName: String
  freezeNoDays: Int
  freezeDate: Date
  freezeTypeName: String
  ownerName: String
}

type TransactionGym {
  id: ID
  name: String
  allowMembershipOnFullPayment: Boolean
  brand: TransactionGymBrand
  address: TransactionGymAddress
  vatRegistrationNumber: String
  legalName: String
}

type TransactionGymAddress {
  id: ID
  city: String
  state: String
  floorNo: String
  street: String
  zipCode: String
  building: String
  unitNumber: String
  shortAddress: String
  geoLocation: TransactionGymAddressGeolocation
  country: TransactionGymAddressCountry
}

type TransactionGymAddressCountry {
  id: ID
  name: String
  isoCode: String
  dialCode: String
  vat: Float
  vatId: String
}

type TransactionGymAddressGeolocation {
  type: String
  coordinates: [String]
}

type TransactionGymBrand {
  id: ID
  name: String
}

type TransactionGymClass {
  id: ID
  name: String
}

type TransactionLead {
  id: ID
  firstName: String
  middleName: String
  lastName: String
  email: String
  dob: Date
  phoneNumber: String
  source: String
  customerCode: String
  country: TransactionLeadCountry
}

type TransactionLeadCountry {
  id: ID
  name: String
  isoCode: String
  dialCode: String
  vat: Float
  vatId: String
}

type TransactionMembershipAction {
  id: ID
  type: String
  reason: String
  note: String
}

type TransactionOrderEvent {
  id: ID
  shortCode: String
  userId: ID
  count: Int
  subtotal: Float
  total: Float
  amountDue: Float
  currency: String
  paymentStatus: String
  status: String
  event: TransactionOrderEventEvent
}

type TransactionOrderEventEvent {
  id: ID
  name: String
  startDate: Date
  endDate: Date
  price: Float
  currency: String
}

type TransactionOrderGymClass {
  id: ID
  shortCode: String
  code: String
  bookedFor: Date
  bookedTime: String
  duration: Int
  salesBy: String
  salesByName: String
  gymClass: TransactionGymClass
}

type TransactionOrderPOS {
  id: ID
  shortCode: String
  total: Float
  vatPercentage: CurrencyValue
  salesBy: String
  salesByName: String
  items: [TransactionPOSItems]
}

type TransactionOrderPrivateCoach {
  id: ID
  shortCode: String
  subtotal: Float
  total: Float
  amountDue: Float
  paymentStatus: String
  source: String
  status: String
  orderPrivateCoachSession: [TransactionOrderPrivateCoachSession]
  salesBy: TransactionOrderPrivateCoachSalesBy
}

type TransactionOrderPrivateCoachSalesBy {
  id: ID
  name: String
  type: SalesByType
}

type TransactionOrderPrivateCoachSession {
  sessionDate: Date
  status: String
  ratingScore: Int
  amount: Float
  openTime: String
  openDuration: Int
  customerId: ID
  sessionContract: TransactionSessionContract
}

type TransactionPOSItems {
  id: ID
  name: String
  quantity: Int
  sku: String
}

type TransactionSessionContract {
  startDate: Date
  endDate: Date
  status: String
  instructorId: ID
  instructorName: String
  createdById: ID
  service: TransactionSessionContractService
}

type TransactionSessionContractService {
  id: ID
  name: String
}

type TransactionSessionPack {
  id: ID
  name: String
  price: Float
  paymentType: String
  currency: String
  startDate: String
  ownerId: String
  adminId: ID
  salesByName: String
  frozenById: ID
  frozenByName: String
  freezeNoDays: Int
  freezeDate: Date
  freezeTypeName: String
  ownerName: String
}

input TransactionsFilters {
  customerId: ID
  orderType: OrderType
  orderTypes: [OrderType!]
  gymIds: [ID!]
  paymentStatus: PaymentStatus
  sort: DateSorting
  startDate: Date
  endDate: Date
  discounted: Boolean
  isLeadOrders: Boolean
  paymentMethod: OrderPaymentScheme
  invoiceType: InvoiceType
  leadSource: [String!]
}

type TransactionSingleMembership {
  id: ID
  name: String
  price: Float
  discountedPrice: Float
  joiningFee: Float
  paymentType: String
  currency: String
  startDate: String
  endDate: String
  ownerId: String
  adminId: ID
  salesByName: String
  frozenById: ID
  frozenByName: String
  freezeNoDays: Int
  freezeDate: Date
  freezeTypeName: String
  ownerName: String
  status: String
  pendingAmount: Float
}

type TransactionsPayload {
  list: [Transaction]
  paging: PaginatorOutputUpdated
}

type transferMembership {
  membershipType: String
  paymentUrl: String
}

input TransferMembershipMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  cocCardId: ID
  sessionPackId: ID
  leadId: ID!
  amount: Float
  paymentMethod: MembershipPaymentMethod!
}

type TransferMembershipResponse {
  data: transferMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type TrialInfo {
  startDate: Date!
  expiryDate: Date!
  status: OrderTrialStatus!
}

type TypeQAType {
  name: String!
  question: String!
  type: String!
  options: [TypeQATypeOption!]
  multiSelectVal: [String!]
  stringVal: String
  boolVal: Boolean
}

type TypeQATypeOption {
  label: String!
  value: String!
}

type UnBookedSlotsPayload {
  leftBooking: Int!
  usedBooking: Int!
  firstBookingDate: Date
  totalBooking: Int!
}

type UndoSoftDeleteLeadPayload {
  status: Boolean
  error: LeadError
  errors: [LeadError]
  errorMessage: String
}

type UnfreezeLogLine {
  unfreezeScheduledDate: String!
  freezeDays: Float!
  membershipId: ID!
  customerId: ID!
  status: String!
  notes: String
}

input UnfreezeMembershipFromAdminMutationInput {
  singleMembershipId: ID
  groupMembershipId: ID
  sessionPackId: ID
}

input UpdateABookingFromAdminPlatformInput {
  id: ID!
  message: String
  sessionContractId: ID!
  instructorId: ID
  forDate: Date!
  openTime: LocalTime!
  closeTime: LocalTime!
  gymStudioId: ID
  groupMembers: [String!]
}

type UpdateABookingFromAdminPlatformPayload {
  success: Boolean
  error: OrderPrivateCoachError
  errors: [OrderPrivateCoachError!]
  errorMessage: String
}

input UpdateAccountDeletionRequestInput {
  id: ID!
  adminNote: String
}

input UpdateAllowMembershipOnFullPayment {
  gymId: ID!
  allowMembershipOnFullPayment: Boolean!
}

input UpdateAllowPTOnFullPayment {
  gymId: ID!
  allowPTOnFullPayment: Boolean!
}

input UpdateAPosStoreOrderFromAdminPlatformInput {
  orderId: ID!
  salesById: ID!
}

type UpdateAPosStoreOrderFromAdminPlatformPayload {
  success: Boolean
  errors: [PosOrderError!]
  errorMessage: String
}

input UpdateAppIdBasicInfoInput {
  appId: String!
  status: GlobalStatusType!
  name: String
}

input UpdateAppIdBrandsInput {
  appId: String!
  brandIds: [String!]!
}

type UpdateAppIdBrandsPayload {
  brandIds: [String]
  errors: [AppIdErrors]
  error: AppIdErrors
  errorMessage: String
}

input UpdateAppIdInput {
  appId: String!
  name: String
  status: GlobalStatusType
  wlAndroidAppLink: String
  wlIosAppLink: String
  minVersionIOS: String
  minVersionAndroid: String
}

input UpdateAppIdMinVersionInput {
  appId: String!
  minVersionIOS: String
  minVersionAndroid: String
}

type UpdateAppIdPayload {
  appId: AppId
  errors: [AppIdErrors]
  error: AppIdErrors
  errorMessage: String
}

input UpdateCountryCityInput {
  id: ID!
  name: String
  countryId: ID
  stateId: ID
}

input UpdateCountryInput {
  id: ID!
  name: String
  status: StatusType
  isoCode: String
  dialCode: String
  flagPhoto: String
  vat: Float
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
  currency: CurrencyDetailsInput
  cities: [SaveCityPerCountryInput]
}

input UpdateCountryStateInput {
  id: ID!
  name: String
  countryId: ID
  isCapital: Boolean
}

input UpdateCustomerInfoInput {
  id: ID!
  firstName: String
  lastName: String
  email: String
  contactNumber: String
  dob: Date
  newPassword: String
  oldPassword: String
}

input UpdateCustomerInput {
  firstName: String
  lastName: String
  email: String
  contactNumber: String
  gender: CustomerGenderType
  dob: Date
  countryId: ID
  isEmailVerified: Boolean
  isPhoneVerified: Boolean
  accessedByMobile: Boolean
  authId: String
  photo: String
}

type UpdateEvent {
  data: Event
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

input UpdateEventInput {
  id: ID!
  name: String
  description: String
  startDate: String
  endDate: String
  latitude: Float
  longitude: Float
  address: String
  capacity: Int
  price: Float
  pictures: [String]
  videos: [String]
  difficulty: EventDifficulty
  equipment: String
  rules: String
  cancelationPolicy: String
  status: EventStatus
  trainers: [String]
  creatorPhoneNumber: String
  createdById: ID
  gymId: ID
  brandId: ID
  countryId: ID
}

input UpdateFileCategoryInput {
  id: ID!
  name: String
  description: String
  iconURL: String
}

type UpdateFileCategoryPayload {
  fileCategory: FileCategory
  errorMessage: String
  error: FileCategoryError
  errors: [FileCategoryError!]
}

input UpdateFileInput {
  id: ID!
  description: String
  fileURL: String
  fileType: FileType
  fileCategoryId: ID
}

type UpdateFilePayload {
  file: File
  errorMessage: String
  error: FileError
  errors: [FileError!]
}

type UpdateGroupMembershipPlan {
  groupMembershipPlan: GroupMembershipPlan
}

input UpdateGroupMembershipPlanMutationInput {
  id: ID!
  name: String
  description: String
  status: MembershipPlanTypeStatus
  color: String
  visible: Boolean
  hasEndDate: Boolean
  recursionDuration: Int
  recursionPeriod: MembershipPlanTypePeriod
  maxMemberCount: Int
  paymentPlanIds: [ID]
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
  isChampion: Boolean
  championType: ChampionType
  subDomesticGymIds: [String]
}

type UpdateGroupMembershipPlanMutationResponse {
  data: UpdateGroupMembershipPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input UpdateGroupNotificationInput {
  id: ID!
  title: String
  description: String
}

input UpdateGymBuddyInput {
  customerId: ID!
  firstName: String
  lastName: String
  name: String
  email: String
  description: String
  interests: [Interest]
  age: Int
  weight: Float
  weightUnit: ID
  height: Int
  heightUnit: ID
  trainingPlace: TrainingPlace
  photo: String
  backgroundImage: String
  status: GymBuddyOnlineStatus
  locationName: String
  dob: Date
  gender: CustomerGenderType
}

input UpdateGymClassBookingSettingsInput {
  id: ID!
  missingClassLimit: Int!
  classBookingBlockDays: Int!
}

input UpdateGymDeviceInput {
  id: ID!
  gymId: ID!
  deviceId: String!
}

input UpdateGymNotificationsInput {
  gymId: ID!
  isNotificationsDisabled: Boolean!
}

input UpdateGymPaymentGatewayInput {
  gymId: ID!
  paymentProvider: GymPaymentGateway!
  isPaymentGatewayEnabled: Boolean!
  tapMerchantId: String!
  masterMerchantId: String!
  tapSecretKey: String!
  tapPublicKey: String!
  tapAndroidAppSecretKey: String!
  tapIosAppSecretKey: String!
  tapAppPublicKey: String!
}

input UpdateGymWebsiteIntegrationInput {
  gymId: ID!
  isWebsiteIntegrationEnabled: Boolean
  websiteIntegrationSecretKey: String
  websiteUrls: [String!]
}

input UpdateIndividualNotificationInput {
  id: ID!
  title: String
  description: String
  notificationCreatedById: ID
}

input UpdateLeadAppointmentInput {
  id: ID!
  appointmentDate: Date
  appointmentTime: String
  note: String
  appointmentCreatedById: ID
  outcome: AppointmentOutcome
  outcomeRescheduledDate: Date
  outcomeRescheduledTime: String
  outcomeRescheduledNote: String
  outcomeNotInterestedNote: String
}

input UpdateLeadCallInput {
  id: ID!
  callDate: Date
  callTime: String
  outcome: CallOutcome
  note: String
  callConnectedStatus: CallConnectedStatus
  callUnreachedStatus: CallUnreachedStatus
  callFollowUpDate: Date
  callFollowUpTime: String
  callFollowUpBy: ID
  priority: FollowUpPriority
  callAppointmentDate: Date
  callAppointmentTime: String
  calledBy: ID
}

input UpdateLeadClassBookingStatusInput {
  id: ID!
  isClassBookingBlocked: Boolean!
}

input UpdateLeadCompanyInput {
  id: ID!
  name: String
  industry: CompanyIndustry
  address: String
}

input UpdateLeadContactInput {
  id: ID!
  phoneNumber: String
  phoneCountryCode: String
}

input UpdateLeadEmailInput {
  id: ID!
  subject: String
  description: String
}

input UpdateLeadInput {
  id: ID!
  firstName: String
  middleName: String
  lastName: String
  email: String
  phoneNumber: String
  description: String
  dob: Date
  photo: String
  nationality: String
  source: LeadSource
  gender: CustomerGenderType
  address: String
  cityId: ID
  countryId: ID
  leadType: LeadType
  leadStatus: LeadStatus
  workStatus: WorkStatus
  jobTitle: String
  companyId: ID
  contacts: [SaveLeadContactInput]
  marketingConsentSms: Boolean
  marketingConsentEmail: Boolean
  linkedAccounts: [SaveLinkedAccountWithLeadInput]
  emergencyContact: SaveLeadContactInput
  gymId: ID!
  adminId: ID
  assignedTo: ID
}

input UpdateLeadNoteInput {
  id: ID!
  note: String
}

input UpdateLeadNotificationInput {
  id: ID!
  title: String
  description: String
}

input UpdateLeadStatusInput {
  id: ID!
  leadStatus: InitialLeadStatus!
}

input UpdateLeadTaskInput {
  id: ID!
  startDate: Date
  endDate: Date
  assigneeId: ID
  title: String
  description: String
  priority: FollowUpPriority
  notes: String
}

input UpdateLinkedAccountInput {
  id: ID!
  firstName: String
  lastName: String
  gender: CustomerGenderType
  dob: Date
  email: String
  phoneNumber: String
  photo: String
  hasUniqueEmail: Boolean
}

type UpdateMembershipFreezeType {
  membershipFreezeType: MembershipFreezeType
}

input UpdateMembershipFreezeTypeMutationInput {
  id: ID!
  name: String
  status: MembershipGlobalStatusEnum
  numberDays: Int
  price: Float
  singleMembershipPlansIds: [ID]
  groupMembershipPlansIds: [ID]
  gymId: ID
  brandId: ID
}

type UpdateMembershipFreezeTypeMutationResponse {
  data: UpdateMembershipFreezeType
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type UpdateMembershipPlanGroup {
  membershipPlanGroup: MembershipPlanGroup
}

input UpdateMembershipPlanGroupMutationInput {
  id: ID!
  name: String
  description: String
  gymId: ID!
}

type UpdateMembershipPlanGroupMutationResponse {
  data: UpdateMembershipPlanGroup
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type UpdatePaymentPlan {
  paymentPlan: PaymentPlan
}

input UpdatePaymentPlanMutationInput {
  id: ID!
  name: String
  type: PaymentTypeEnum
  price: Float
  joiningFee: Float
  paymentRecursionDuration: Int
  paymentRecursionType: PaymentRecursionTypeEnum
  hasEndDate: Boolean
  recursionDuration: Int
  recursionPeriod: MembershipPlanTypePeriod
  chargeOnFirst: Boolean
  giftPeriodFree: Boolean
  gracePeriodDays: Int
  gymId: String
  countryId: String
  singleMembershipPlanId: String
  groupMembershipPlanId: String
  sessionPackPlanId: String
  servicePacks: [ServicePackInputType]
  installmentAmount: Float
  surcharge: Float
  installmentRounds: Int
  installmentFrequencyType: InstallmentFrequencyTypeEnum
}

type UpdatePaymentPlanMutationResponse {
  data: UpdatePaymentPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input UpdatePosBrandInput {
  id: ID!
  name: String!
  description: String
  image: String
  gymId: ID!
  status: PosStatusInput!
}

input UpdatePosCategoryInput {
  id: ID!
  name: String!
  description: String
  image: String
  gymId: ID!
  status: PosStatusInput!
}

input UpdatePosProductInput {
  id: ID!
  name: String!
  description: String
  images: [String!]
  posBrandId: ID!
  posCategoryId: ID!
  price: CurrencyValue!
  sku: String!
  status: PosStatusInput!
  vatAdjusted: Boolean!
}

input UpdateProductInventoryInput {
  id: ID!
  quantity: Int!
}

type UpdateSessionPackPlan {
  sessionPackPlan: SessionPackPlan
}

input UpdateSessionPackPlanMutationInput {
  id: ID!
  name: String
  description: String
  color: String
  status: MembershipPlanTypeStatus
  visible: Boolean
  classes: Int
  allClasses: Boolean
  classIds: [String]
  classCategories: [String]
  classRecursionDuration: Int
  classRecursionPeriod: MembershipPlanTypePeriod
  courts: Int
  sessions: Int
  allSessions: Boolean
  sessionIds: [String]
  sessionCategories: [String]
  sessionRecursionDuration: Int
  sessionRecursionPeriod: MembershipPlanTypePeriod
  paymentPlanIds: [ID]
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
}

type UpdateSessionPackPlanMutationResponse {
  data: UpdateSessionPackPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type updateSingleMembership {
  singleMembership: SingleMembership
}

input UpdateSingleMembershipMutationInput {
  singleMembershipId: ID!
  startDate: String
  adminId: String
}

type UpdateSingleMembershipMutationResponse {
  data: updateSingleMembership
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type UpdateSingleMembershipPlan {
  singleMembershipPlan: SingleMembershipPlan
}

input UpdateSingleMembershipPlanMutationInput {
  id: ID!
  name: String
  description: String
  color: String
  status: MembershipPlanTypeStatus
  trial: Boolean
  visible: Boolean
  hasEndDate: Boolean
  recursionDuration: Int
  recursionPeriod: MembershipPlanTypePeriod
  targetGender: GenderEnum
  targetMinAge: Int
  targetMaxAge: Int
  paymentPlanIds: [ID]
  gracePeriodCancellation: Int
  gracePeriodChange: Int
  gracePeriodTransfer: Int
  gracePeriodRelocation: Int
  gracePeriodEarlyRenewal: Int
  isChampion: Boolean
  championType: ChampionType
  subDomesticGymIds: [String]
}

type UpdateSingleMembershipPlanMutationResponse {
  data: UpdateSingleMembershipPlan
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

input UpdateUserAccessLevelInput {
  levelIds: String!
  pin: String!
}

type UpdateUserAccessLevelPayload {
  code: Int
  message: String
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  contactNumber: String!
  status: String!
  gender: String
  photo: String
  authId: String
  country: EventCountry!
}

enum UserByAuthError {
  ACCOUNT_DELETED
  DELETION_REQUEST_PENDING
  UNKNOWN_ISSUE
  INTERNAL_SERVER_ERROR
}

type UserDetailPayload {
  found: Boolean!
  type: UserTypeEnum
  user: AnyUserSchema
  r: [String]
  error: UserByAuthError
  errorMessage: String
}

type UserDeviceCountType {
  source: String!
  total: Int!
}

input UserDeviceReportFilters {
  countryId: ID
}

type UserDeviceReportPaylad {
  total: Int!
  list: [UserDeviceCountType!]
}

type UserEventPurchases {
  data: [EventPurchase]
  index: Int
  paging: PaginatorOutput
  status: EventsResponseStatus!
}

type UserEventReviewsResponse {
  eventReviews: [EventReview]
  averageRating: Float
  reviewCount: Int
  canReview: Boolean
}

type UserLikedEventsResponse {
  events: [Event]
}

type UserNotificationMessage {
  id: ID!
  title: String
  description: String!
  createdAt: Date!
  viewed: Boolean!
}

enum UserOSEnum {
  ANDROID
  IOS
  OTHER
}

type UserQrSessionCountPayload {
  count: Int
  error: String
}

type UserQrSessionsPayload {
  qrSessions: [QrSession]
  error: String
}

type UserServicePackType {
  id: ID!
  userId: ID!
  singleMembershipId: ID
  groupMembershipId: ID
  paymentPlanId: ID
  serviceId: ID
  serviceQty: Int
  classId: ID
  classQty: Int
  service: ServicePackServiceType
}

input UserSlotsByAuthFilters {
  gymId: ID
}

type UserSlotsByAuthPayload {
  found: Boolean!
  slots: [AnyUserSchema!]
}

type UserSocialMediaReference {
  profileType: String!
  profileLink: String!
}

enum UserType {
  ADMIN
  CUSTOMER
  INSTRUCTOR
}

enum UserTypeEnum {
  CUSTOMER
  GYM_BUDDY
  INSTRUCTOR
}

input ValidateAccessByMemberInput {
  deviceId: String!
  customerId: String!
  direction: GymDeviceDirection
}

type ValidateAccessPayload {
  allow: Boolean
  error: GymDeviceError
  errors: [GymDeviceError!]
  errorMessage: String
}

type valXper {
  value: Int!
  percentage: Float!
}

type VendorCountry_Common {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: VendorCurrency_Common!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type VendorCurrency_Common {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

type VendorPermission_Common {
  id: ID!
  name: String
  status: GlobalStatusType!
}

type VendorPlanCountry_Common {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: VendorPlanCurrency_Common!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type VendorPlanCurrency_Common {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

type VendorPlanCustomer {
  id: ID!
  firstName: String!
  lastName: String!
  fullName: String!
  email: String
  contactNumber: String
  photo: String
}

type VendorPlanLead {
  id: ID!
  firstName: String!
  lastName: String!
  fullName: String!
  photo: String
}

type VendorRole_Common {
  id: ID!
  name: String
  status: GlobalStatusType!
  permissions: [VendorPermission_Common!]
}

type VendorsShopCountry_Common {
  id: ID!
  name: String!
  status: GlobalStatusType
  currency: VendorsShopCurrency_Common!
  isoCode: String!
  dialCode: String
  flagPhoto: String
  vat: Float!
  servicePhoneNumber: String
  timeZoneIdentifier: String
  vatId: String
}

type VendorsShopCurrency_Common {
  name: String!
  code: String!
  symbol: String
  decimalPlace: Int!
  lowestDenomination: Float!
  subUnitName: String!
}

enum VerifyMobileError {
  INVALID_PHONE
  UNKNOWN_ISSUE
  INTERNAL_SERVER_ERROR
  INVALID_LEAD
  INVALID_OTP
  RESEND_OTP_AFTER_ONE_MINUTE
  OTP_EXPIRED
  NO_MEMBERSHIP_ASSIGNED
  ALREADY_A_MEMBER
  GYM_SIGNUP_DISABLED
  INVALID_SALES_MANAGER
}

input VerifyOTPInput {
  contactNumber: String!
  gymId: String!
  otp: String!
  refId: String
}

type VerifyOTPPayload {
  accessToken: String
  error: VerifyMobileError
  errors: [VerifyMobileError]
  errorMessage: String
}

# Product Categories.
type Video {
  id: ID!
  title: String!
  description: String!
  videoId: String!
  thumbnail: String
  url: String!
  hero: String!
  duration: Int!
  brandId: ID!
  gymId: ID
  status: GlobalStatusType!
  instructorId: ID!
  videoTypeId: ID!
  difficulty: VideoDifficulty!
  equipment: String!
  caloriesBurned: String
  createdAt: Datetime!
  updatedAt: Datetime!
  brand: Brand
  videoType: VideoType
  distance: Float
}

enum VideoDifficulty {
  BEGINNER
  INTERMEDIATE
  ADVANCE
}

enum VideoError {
  DUPLICATE_NAME
  INVALID_ID
  INTERNAL_SERVER_ERROR
  NOT_ALLOWED
}

type VideoListView {
  id: ID!
  title: String!
  description: String!
  videoId: String!
  thumbnail: String
  url: String!
  hero: String!
  duration: Int!
  brandId: ID!
  gymId: ID
  instructorId: ID!
  videoTypeId: ID!
  videoTypeName: String!
  difficulty: VideoDifficulty!
  equipment: String!
  caloriesBurned: String
  createdAt: Datetime!
  updatedAt: Datetime!
  distance: Float
}

input VideosFilter {
  searchText: String
  status: GlobalStatusType
  brandId: ID
  gymId: ID
  videoTypeId: ID
  instructorId: ID
  difficulty: VideoDifficulty
  durationMin: Int
  durationMax: Int
  burnedCaloriesMin: Int
  burnedCaloriesMax: Int
  equipment: String
}

type VideosPayload {
  list: [Video]
  paging: PaginatorOutput
}

# Product Categories.
type VideoType {
  id: ID!
  label: String!
  status: GlobalStatusType!
  videos: [Video!]
  videoParentType: VideoType
  subTypes: [VideoType!]
  createdAt: Datetime!
  updatedAt: Datetime!
  image: String
  videoCount: Int
}

enum VideoTypeError {
  DUPLICATE_NAME
  INVALID_ID
}

input VideoTypesFilter {
  searchText: String
}

type VideoTypesPayload {
  list: [VideoType]
  paging: PaginatorOutput
}

type VisitorCount {
  date: Date
  count: Int
}

type VisitorCountResponse {
  data: [VisitorCount]
  status: ResponseStatus!
}

type VisitorDuration {
  date: Date
  duration: Int
}

type VisitorDurationResponse {
  data: [VisitorDuration]
  status: ResponseStatus!
}

type visitsType {
  _noVisits: valXper!
  _1To2Visits: valXper!
  _3To6Visits: valXper!
  _7To12Visits: valXper!
  _above12Visits: valXper!
}

input VOrderQrSessionInput {
  qrSessionId: ID!
  customerId: ID!
  endedGymQrCodeId: ID
  amount: Float!
  paymentStatus: String!
}

type VSocialMediaReference {
  profileType: SocialMedias!
  profileLink: String!
}

input VSocialMediaReferenceInput {
  profileType: SocialMedias!
  profileLink: String!
}

type WasEverAMember {
  member: Boolean
}

input WasEverAMemberQueryArgs {
  gymId: ID!
  customerId: ID!
}

type WasEverAMemberQueryResponse {
  data: WasEverAMember
  index: Int
  paging: PaginatorOutputUpdated
  status: MembershipResponseStatus!
}

type WhiteListedPhoneNumber {
  id: ID!
  phoneNumber: String!
  otp: String!
  createdAt: Date
  updatedAt: Date
}

enum WorkedBodyPart {
  CHEST
  SHOULDER
  ABS
  ARMS
  LEGS
  GLUTES
  BACK
}

type WorkoutMachine {
  id: ID!
  name: String!
  icon: String
  status: GlobalStatusType!
}

enum WorkoutMachineError {
  DUPLICATE_NAME
}

input WorkoutMachineFilter {
  status: GlobalStatusType
}

input WorkoutMachineInput {
  id: ID
  name: String!
  icon: String
  status: GlobalStatusType!
}

enum WorkStatus {
  UNEMPLOYED
  EMPLOYED
  STUDENT
}

enum ZkSecurityError {
  INVALID_PIN
}

input ZkUpdateUserInput {
  accEndTime: String
  accLevelIds: String
  accStartTime: String
  birthday: String
  cardNo: String
  deptCode: String
  email: String
  gender: String
  hireDate: String
  lastName: String
  mobilePhone: String
  name: String
  pin: String
  supplyCards: String
}

type ZkUpdateUserPayload {
  code: Int
  message: String
}

type ZkUserDetail {
  id: ID!
  pin: String
  deptCode: String
  deptName: String
  name: String
  lastName: String
  gender: String
  birthday: String
  cardNo: String
  supplyCards: String
  personPhoto: String
  selfPwd: String
  isSendMail: Boolean
  mobilePhone: String
  personPwd: String
  carPlate: String
  email: String
  ssn: String
  accLevelIds: String
  accStartTime: String
  accEndTime: String
  certType: String
  certNumber: String
  photoPath: String
  hireDate: Float
  isDisabled: Boolean
  vislightPhoto: String
  vislightPhotoPath: String
}

type ZkUserDetailPayload {
  code: Int
  message: String
  data: ZkUserDetail
}

